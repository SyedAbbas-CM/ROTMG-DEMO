# MAP SYSTEM - BACKEND

Extraction Date: 2025-04-27T00:27:23.367Z



## FILE: MapManager.js.txt

```javascript
// File: /src/managers/MapManager.js

import { TILE_IDS, CHUNK_SIZE, TILE_SIZE } from './world/constants.js';
import { PerlinNoise } from './world/PerlinNoise.js';
import { Tile } from './world/tile.js';
import { EnhancedPerlinNoise } from './world/AdvancedPerlinNoise.js';
/**
 * MapManager handles the game world, tiles, and chunks.
 * This is a unified implementation that consolidates functionality
 * from both the original MapManager and GameMap classes.
 */
export class MapManager {
  /**
   * Creates a map manager
   */
  constructor(options = {}) {
    this.chunks = new Map(); // Map of "x,y" -> chunk data
    this.width = 0;          // Width of the world in tiles
    this.height = 0;         // Height of the world in tiles
    this.tileSize = options.tileSize || TILE_SIZE;  // Size of each tile in pixels
    
    // For procedural generation
    this.perlin = new EnhancedPerlinNoise(options.seed || Math.random());
    this.proceduralEnabled = true;
    this.isFixedMap = false;
    
    // Map storage (for server)
    this.mapStoragePath = options.mapStoragePath || '';
    this.maps = new Map(); // For storing multiple maps (id -> mapData)
    this.nextMapId = 1;
  }
  
  /**
   * Generate or load a world
   * @param {number} width - Width of the world in tiles
   * @param {number} height - Height of the world in tiles
   * @param {Object} options - Additional options
   * @returns {string} Map ID
   */
  generateWorld(width, height, options = {}) {
    this.width = width;
    this.height = height;
    
    // Clear existing chunks
    this.chunks.clear();
    
    console.log(`World initialized with size ${width}x${height}`);
    
    // Create a map ID
    const mapId = `map_${this.nextMapId++}`;
    
    // Store map metadata
    this.maps.set(mapId, {
      id: mapId,
      width,
      height,
      tileSize: this.tileSize,
      chunkSize: CHUNK_SIZE,
      name: options.name || 'Untitled Map',
      procedural: this.proceduralEnabled,
      seed: this.perlin.seed
    });
    
    return mapId;
  }
  
  /**
   * Get world info for clients
   * @param {string} mapId - Map ID
   * @returns {Object} World metadata
   */
  getMapInfo(mapId) {
    if (mapId && this.maps.has(mapId)) {
      return this.maps.get(mapId);
    }
    
    return {
      width: this.width,
      height: this.height,
      tileSize: this.tileSize,
      chunkSize: CHUNK_SIZE
    };
  }
  
  /**
   * Get data for a specific chunk
   * @param {string} mapId - Map ID
   * @param {number} chunkX - Chunk X coordinate
   * @param {number} chunkY - Chunk Y coordinate
   * @returns {Object|null} Chunk data or null if not found
   */
  getChunkData(mapId, chunkX, chunkY) {
    const key = `${mapId || 'default'}_${chunkX},${chunkY}`;
    
    // If chunk exists in cache, return it
    if (this.chunks.has(key)) {
      return this.chunks.get(key);
    }
    
    // Otherwise generate it
    if (this.proceduralEnabled && !this.isFixedMap) {
      const chunkData = this.generateChunkData(chunkX, chunkY);
      this.chunks.set(key, chunkData);
      return chunkData;
    }
    
    return null;
  }
  
  /**
   * Generate data for a chunk procedurally using RotMG-style terrain generation
   * @param {number} chunkRow - Chunk row (Y coordinate)
   * @param {number} chunkCol - Chunk column (X coordinate)
   * @returns {Object} Generated chunk data
   */
  generateChunkData(chunkRow, chunkCol) {
    const tiles = [];
    
    // Parameters for multi-octave noise
    const OCTAVES = 4;        // Number of noise layers to blend
    const PERSISTENCE = 0.5;  // How much each octave contributes
    const BASE_SCALE = 50;    // Base scale/zoom of the noise (higher = more zoomed out)
    
    for (let y = 0; y < CHUNK_SIZE; y++) {
      const row = [];
      for (let x = 0; x < CHUNK_SIZE; x++) {
        const globalX = chunkCol * CHUNK_SIZE + x;
        const globalY = chunkRow * CHUNK_SIZE + y;
        
        // Skip if out of world bounds
        if (globalX >= this.width || globalY >= this.height) {
          row.push(new Tile(TILE_IDS.WALL)); // Use wall for out of bounds
          continue;
        }
        
        // Generate multiple octaves of noise for more natural terrain
        let height = 0;
        let amplitude = 1.0;
        let frequency = 1.0;
        let maxValue = 0;
        
        // Sum multiple noise octaves
        for (let o = 0; o < OCTAVES; o++) {
          // Scale coordinates based on frequency
          const sampleX = globalX / (BASE_SCALE / frequency);
          const sampleY = globalY / (BASE_SCALE / frequency);
          
          // Add scaled noise value
          height += this.perlin.get(sampleX, sampleY) * amplitude;
          
          // Keep track of max possible value for normalization
          maxValue += amplitude;
          
          // Increase frequency, decrease amplitude for next octave
          amplitude *= PERSISTENCE;
          frequency *= 2;
        }
        
        // Normalize to -1 to 1 range
        height /= maxValue;
        
        // Apply a curve to create more interesting terrain
        // Emphasize extremes (more mountains and water, less flat land)
        height = Math.pow(height, 3);
        
        // For coasts: add a high-frequency noise to create more jagged coastlines
        if (height > -0.4 && height < -0.2) {
          const coastDetail = this.perlin.get(globalX / 10, globalY / 10) * 0.1;
          height += coastDetail;
        }
        
        // Determine tile type based on height and position
        const tileType = this.determineTileType(height, globalX, globalY);
        
        row.push(new Tile(tileType, height));
      }
      tiles.push(row);
    }
    
    return {
      x: chunkCol,
      y: chunkRow,
      tiles: tiles
    };
  }
  
  /**
   * Determine tile type based on height value and create biomes like in RotMG
   * @param {number} heightValue - Perlin noise height value
   * @param {number} x - Global X coordinate
   * @param {number} y - Global Y coordinate
   * @returns {number} TILE_IDS value
   */
  determineTileType(heightValue, x, y) {
    // Absolute border walls
    if (x === 0 || y === 0 || x === this.width - 1 || y === this.height - 1) {
      return TILE_IDS.WALL;
    }
    
    // Generate additional noise values for biome variety
    // Use different frequency/scale for variety
    const temperatureNoise = this.perlin.get(x / 100, y / 100);  
    const moistureNoise = this.perlin.get(x / 80 + 500, y / 80 + 500);
    
    // Determine biome based on height, temperature and moisture
    // RotMG-style biome system
    
    // Deep water
    if (heightValue < -0.6) {
      return TILE_IDS.WATER;
    }
    
    // Shallow water/beaches
    if (heightValue < -0.3) {
      // Sometimes place obstacles in shallow water (like reeds or rocks)
      if (moistureNoise > 0.7 && Math.random() < 0.03) {
        return TILE_IDS.OBSTACLE;
      }
      return TILE_IDS.WATER;
    }
    
    // Lowlands (main gameplay areas)
    if (heightValue < 0.2) {
      // Cold biomes with temperature noise
      if (temperatureNoise < -0.5) {
        // Occasionally place obstacles (like ice formations)
        if (Math.random() < 0.02 && moistureNoise > 0.5) {
          return TILE_IDS.OBSTACLE;
        }
        return TILE_IDS.FLOOR; // Could be a special "snow" tile if we add more tile types
      }
      
      // Wet/swampy areas with high moisture
      if (moistureNoise > 0.6) {
        // More obstacles in swampy areas (like bogs)
        if (Math.random() < 0.05) {
          return TILE_IDS.OBSTACLE;
        }
        return TILE_IDS.FLOOR;
      }
      
      // Desert-like areas (low moisture, high temperature)
      if (moistureNoise < -0.3 && temperatureNoise > 0.4) {
        // Few obstacles in deserts
        if (Math.random() < 0.01) {
          return TILE_IDS.OBSTACLE;
        }
        return TILE_IDS.FLOOR;
      }
      
      // Default lowland (grassy fields)
      // Place natural obstacles occasionally
      if (Math.random() < 0.02) {
        return TILE_IDS.OBSTACLE;
      }
      return TILE_IDS.FLOOR;
    }
    
    // Hills and forests (medium elevation)
    if (heightValue < 0.5) {
      // Denser obstacles in hilly/forest areas
      if (Math.random() < 0.1 + (moistureNoise * 0.1)) {
        return TILE_IDS.OBSTACLE;
      }
      return TILE_IDS.FLOOR;
    }
    
    // Mountains (high elevation)
    if (heightValue < 0.7) {
      // Very dense obstacles in mountains
      if (Math.random() < 0.3) {
        return TILE_IDS.OBSTACLE;
      }
      // Some walls in mountains too
      if (Math.random() < 0.15) {
        return TILE_IDS.WALL;
      }
      return TILE_IDS.MOUNTAIN;
    }
    
    // Peaks (highest elevation)
    // Almost impassable
    if (Math.random() < 0.7) {
      return TILE_IDS.WALL;
    }
    return TILE_IDS.MOUNTAIN;
  }
  
  /**
   * Get a specific tile
   * @param {number} x - Tile X coordinate
   * @param {number} y - Tile Y coordinate
   * @returns {Tile|null} Tile object or null if not found
   */
  getTile(x, y) {
    // Convert to chunk coordinates
    const chunkX = Math.floor(x / CHUNK_SIZE);
    const chunkY = Math.floor(y / CHUNK_SIZE);
    const localX = x % CHUNK_SIZE;
    const localY = y % CHUNK_SIZE;
    
    // Get chunk
    const chunk = this.getChunkData(null, chunkX, chunkY);
    if (!chunk) return null;
    
    // Get tile from chunk
    return chunk.tiles[localY][localX];
  }
  
  /**
   * Get the tile type at a specific coordinate
   * @param {number} x - Tile X coordinate
   * @param {number} y - Tile Y coordinate
   * @returns {number|null} Tile type or null if not found
   */
  getTileType(x, y) {
    const tile = this.getTile(x, y);
    return tile ? tile.type : null;
  }
  
  /**
   * Check if a position is a wall or out of bounds
   * @param {number} x - World X coordinate
   * @param {number} y - World Y coordinate
   * @returns {boolean} True if wall or out of bounds
   */
  isWallOrOutOfBounds(x, y) {
    // Convert to tile coordinates
    const tileX = Math.floor(x / this.tileSize);
    const tileY = Math.floor(y / this.tileSize);
    
    // Debug coordinate conversion occasionally
    if (Math.random() < 0.0001) {
      console.log(`[SERVER] Wall check: World (${x.toFixed(2)}, ${y.toFixed(2)}) -> Tile (${tileX}, ${tileY})`);
    }
    
    // Check if out of bounds
    if (tileX < 0 || tileY < 0 || tileX >= this.width || tileY >= this.height) {
      return true;
    }
    
    // Get tile type
    const tileType = this.getTileType(tileX, tileY);
    
    // Check if wall or other solid obstacle
    const isBlocked = tileType === TILE_IDS.WALL || 
                     tileType === TILE_IDS.MOUNTAIN || 
                     tileType === TILE_IDS.WATER;
    
    // Debug collisions occasionally
    if (isBlocked && Math.random() < 0.0001) {
      console.log(`[SERVER] Collision at tile (${tileX}, ${tileY}), type: ${tileType}`);
    }
    
    return isBlocked;
  }
  
  /**
   * Load a fixed map from a JSON file
   * @param {string} url - URL or path to map JSON file
   * @returns {Promise<string>} - Promise resolving to map ID
   */
  async loadFixedMap(url) {
    try {
      let mapData;
      
      // Browser fetch
      if (typeof fetch === 'function') {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Failed to load map: ${response.statusText}`);
        }
        mapData = await response.json();
      } 
      // Node.js file read
      else if (typeof require === 'function') {
        const fs = require('fs');
        const path = require('path');
        const resolvedPath = path.isAbsolute(url) ? url : path.join(this.mapStoragePath, url);
        const data = fs.readFileSync(resolvedPath, 'utf8');
        mapData = JSON.parse(data);
      }
      else {
        throw new Error('No valid method to load map data');
      }
      
      // Set map data and get ID
      const mapId = this.setMapData(mapData);
      this.isFixedMap = true;
      this.proceduralEnabled = false;
      console.log('Fixed map loaded successfully:', mapId);
      return mapId;
    } catch (error) {
      console.error('Failed to load fixed map:', error);
      throw error;
    }
  }
  
  /**
   * Save map to a file
   * @param {string} mapId - Map ID to save
   * @param {string} filename - Filename to save as
   * @returns {Promise<boolean>} - Promise resolving to success status
   */
  async saveMap(mapId, filename) {
    if (!this.maps.has(mapId)) {
      console.error(`Map ${mapId} not found`);
      return false;
    }
    
    // Check if we're running in Node.js - use dynamic import for ES modules
    let fs, path;
    try {
      // Use dynamic import for ES modules
      const fsModule = await import('fs');
      const pathModule = await import('path');
      fs = fsModule.default || fsModule;
      path = pathModule.default || pathModule;
      console.log("Using ES dynamic import");
    } catch (e) {
      console.error("Cannot access the file system:", e.message);
      return false;
    }
    
    try {
      // Get map metadata
      const mapData = this.maps.get(mapId);
      console.log(`DEBUG: Preparing to save map ${mapId} with dimensions ${mapData.width}x${mapData.height}`);
      
      // Make sure directory exists
      if (!fs.existsSync(this.mapStoragePath)) {
        console.log(`DEBUG: Creating map storage directory: ${this.mapStoragePath}`);
        fs.mkdirSync(this.mapStoragePath, { recursive: true });
      }
      
      // Collect all chunks for this map
      const chunks = {};
      for (const [key, chunk] of this.chunks.entries()) {
        if (key.startsWith(`${mapId}_`)) {
          chunks[key.substring(mapId.length + 1)] = chunk;
        }
      }
      
      console.log(`DEBUG: Found ${Object.keys(chunks).length} chunks to save`);
      
      // Prepare the full map data
      const fullMapData = {
        ...mapData,
        chunks
      };
      
      // Save to file
      const filePath = path.join(this.mapStoragePath, filename);
      console.log(`DEBUG: Attempting to save map to path: ${filePath}`);
      
      // Create maps directory if it doesn't exist
      if (!fs.existsSync(path.dirname(filePath))) {
        fs.mkdirSync(path.dirname(filePath), { recursive: true });
        console.log(`DEBUG: Created directory: ${path.dirname(filePath)}`);
      }
      
      fs.writeFileSync(filePath, JSON.stringify(fullMapData, null, 2));
      
      console.log(`Map saved to ${filePath} successfully!`);
      return true;
    } catch (error) {
      console.error('Failed to save map:', error);
      console.error(`ERROR DETAILS: ${error.message}`);
      console.error(`Stack trace: ${error.stack}`);
      console.error(`Map storage path: ${this.mapStoragePath}`);
      return false;
    }
  }
  
  /**
   * Save map as a simple 2D array of tile types
   * @param {string} mapId - Map ID to save
   * @param {string} filename - Filename to save as
   * @returns {Promise<boolean>} - Promise resolving to success status
   */
  async saveSimpleMap(mapId, filename) {
    if (!this.maps.has(mapId)) {
      console.error(`Map ${mapId} not found`);
      return false;
    }
    
    // Check if we're running in Node.js - use dynamic import for ES modules
    let fs, path;
    try {
      // Use dynamic import for ES modules
      const fsModule = await import('fs');
      const pathModule = await import('path');
      fs = fsModule.default || fsModule;
      path = pathModule.default || pathModule;
      console.log("Using ES dynamic import");
    } catch (e) {
      console.error("Cannot access the file system:", e.message);
      return false;
    }
    
    try {
      // Get map metadata
      const mapData = this.maps.get(mapId);
      const width = mapData.width;
      const height = mapData.height;
      
      console.log(`DEBUG: Preparing to save simple map ${mapId} with dimensions ${width}x${height}`);
      
      // Make sure directory exists
      if (!fs.existsSync(this.mapStoragePath)) {
        console.log(`DEBUG: Creating map storage directory: ${this.mapStoragePath}`);
        fs.mkdirSync(this.mapStoragePath, { recursive: true });
      }
      
      // Create a 2D array initialized with -1 (unknown)
      const tileMap = Array(height).fill().map(() => Array(width).fill(-1));
      
      // FIXED: Use the direct approach to get tile types
      console.log(`Trying direct tile lookup for map ${mapId} - width=${width}, height=${height}`);
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          // Get tile directly using getTile method
          const tile = this.getTile(x, y);
          if (tile) {
            tileMap[y][x] = tile.type;
          }
        }
      }
      
      // Check if we still have all -1s, if so try the chunk approach as backup
      let allNegativeOne = true;
      for (let y = 0; y < height && allNegativeOne; y++) {
        for (let x = 0; x < width && allNegativeOne; x++) {
          if (tileMap[y][x] !== -1) {
            allNegativeOne = false;
            break;
          }
        }
      }
      
      // If all still -1, try the chunk approach
      if (allNegativeOne) {
        console.log(`WARNING: Direct tile lookup failed, trying chunk-based approach`);
        let processedChunks = 0;
        
        for (const [key, chunk] of this.chunks.entries()) {
          // Log all keys for debugging
          console.log(`DEBUG: Checking chunk key: ${key} for map prefix ${mapId}_`);
          
          if (!key.startsWith(`${mapId}_`)) continue;
          
          const chunkKey = key.substring(mapId.length + 1);
          const [chunkX, chunkY] = chunkKey.split(',').map(Number);
          const startX = chunkX * this.maps.get(mapId).chunkSize;
          const startY = chunkY * this.maps.get(mapId).chunkSize;
          
          console.log(`DEBUG: Processing chunk ${chunkKey} at position (${startX}, ${startY})`);
          
          // Debug chunk data structure
          console.log(`DEBUG: Chunk structure: ${JSON.stringify(Object.keys(chunk))}`);
          console.log(`DEBUG: Chunk tiles length: ${chunk.tiles ? chunk.tiles.length : 'undefined'}`);
          
          // Fill in the tile types from this chunk
          if (chunk.tiles) {
            for (let y = 0; y < chunk.tiles.length; y++) {
              if (!chunk.tiles[y]) continue;
              
              for (let x = 0; x < chunk.tiles[y].length; x++) {
                const globalX = startX + x;
                const globalY = startY + y;
                
                // Skip if outside map bounds
                if (globalX >= width || globalY >= height) continue;
                
                const tile = chunk.tiles[y][x];
                if (tile) {
                  tileMap[globalY][globalX] = tile.type;
                }
              }
            }
          }
          
          processedChunks++;
        }
        
        console.log(`DEBUG: Processed ${processedChunks} chunks for the simple map`);
      }
      
      // Save to file
      const filePath = path.join(this.mapStoragePath, filename);
      console.log(`DEBUG: Attempting to save simple map to path: ${filePath}`);
      
      // Create maps directory if it doesn't exist
      if (!fs.existsSync(path.dirname(filePath))) {
        fs.mkdirSync(path.dirname(filePath), { recursive: true });
        console.log(`DEBUG: Created directory: ${path.dirname(filePath)}`);
      }
      
      // Format the map with one row per line for readability
      const formattedJson = "[\n" + 
        tileMap.map(row => "  " + JSON.stringify(row)).join(",\n") + 
        "\n]";
      
      fs.writeFileSync(filePath, formattedJson);
      
      console.log(`Simple map saved to ${filePath} successfully!`);
      return true;
    } catch (error) {
      console.error('Failed to save simple map:', error);
      console.error(`ERROR DETAILS: ${error.message}`);
      console.error(`Stack trace: ${error.stack}`);
      console.error(`Map storage path: ${this.mapStoragePath}`);
      return false;
    }
  }
  
  /**
   * Sets the map data from a loaded map
   * @param {Object} mapData - The map data object
   * @returns {string} Map ID
   */
  setMapData(mapData) {
    const mapId = mapData.id || `map_${this.nextMapId++}`;
    
    // Clear existing chunks for this map
    for (const [key] of this.chunks.entries()) {
      if (key.startsWith(`${mapId}_`)) {
        this.chunks.delete(key);
      }
    }
    
    // Store metadata
    this.maps.set(mapId, {
      id: mapId,
      width: mapData.width,
      height: mapData.height,
      tileSize: mapData.tileSize || this.tileSize,
      chunkSize: mapData.chunkSize || CHUNK_SIZE,
      name: mapData.name || 'Loaded Map',
      procedural: false
    });
    
    // Update current dimensions
    this.width = mapData.width;
    this.height = mapData.height;
    
    // Load chunks if provided
    if (mapData.chunks) {
      for (const [chunkKey, chunkData] of Object.entries(mapData.chunks)) {
        this.chunks.set(`${mapId}_${chunkKey}`, chunkData);
      }
    }
    
    return mapId;
  }
  
  /**
   * Function to get tiles in a range
   * @param {number} xStart - Start X coordinate
   * @param {number} yStart - Start Y coordinate 
   * @param {number} xEnd - End X coordinate
   * @param {number} yEnd - End Y coordinate
   * @returns {Array} Array of tile objects with coordinates
   */
  getTilesInRange(xStart, yStart, xEnd, yEnd) {
    const tiles = [];
    for (let y = yStart; y <= yEnd; y++) {
      for (let x = xStart; x <= xEnd; x++) {
        const tile = this.getTile(x, y);
        if (tile) {
          tiles.push({ x, y, tile });
        }
      }
    }
    return tiles;
  }
  
  /**
   * Enable procedural generation
   */
  enableProceduralGeneration() {
    this.proceduralEnabled = true;
    this.isFixedMap = false;
  }
  
  /**
   * Disable procedural generation
   */
  disableProceduralGeneration() {
    this.proceduralEnabled = false;
  }
  
  /**
   * Create a procedural map (server-side helper)
   * @param {Object} options - Map options
   * @returns {string} Map ID
   */
  createProceduralMap(options = {}) {
    const width = options.width || 256;
    const height = options.height || 256;
    this.enableProceduralGeneration();
    return this.generateWorld(width, height, options);
  }
  
  /**
   * Get map metadata (server-side helper)
   * @param {string} mapId - Map ID
   * @returns {Object} Map metadata
   */
  getMapMetadata(mapId) {
    return this.maps.has(mapId) ? this.maps.get(mapId) : null;
  }
}

// Export a singleton instance for client use
export const mapManager = new MapManager();

// For CommonJS compatibility
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    MapManager,
    mapManager
  };
}
```

---


## FILE: AdvancedPerlinNoise.js.txt

```javascript
// Enhanced PerlinNoise class with additional features
export class EnhancedPerlinNoise {
    constructor(seed = Math.random()) {
      this.seed = seed;
      this.gradients = {};
      this.memory = {};
    }
  
    // Generate a random gradient vector
    randomGradient(ix, iy) {
      const random = 2920 * Math.sin(ix * 21942 + iy * 171324 + this.seed * 8912) *
                    Math.cos(ix * 23157 * iy * 217832 + this.seed * 9758);
      return { x: Math.cos(random), y: Math.sin(random) };
    }
  
    // Dot product of the distance and gradient vectors
    dotGridGradient(ix, iy, x, y) {
      const key = `${ix},${iy}`;
      const gradient = this.gradients[key] || (this.gradients[key] = this.randomGradient(ix, iy));
  
      const dx = x - ix;
      const dy = y - iy;
  
      return dx * gradient.x + dy * gradient.y;
    }
  
    // Improved smoothing function (smoother than linear interpolation)
    fade(t) {
      return t * t * t * (t * (t * 6 - 15) + 10);
    }
  
    // Interpolation function
    lerp(a0, a1, w) {
      return (1 - w) * a0 + w * a1;
    }
  
    // Compute Perlin noise at coordinates x, y
    get(x, y) {
      const memKey = `${x.toFixed(3)},${y.toFixed(3)}`;
      if (this.memory[memKey] !== undefined) {
        return this.memory[memKey];
      }
      
      const x0 = Math.floor(x);
      const x1 = x0 + 1;
      const y0 = Math.floor(y);
      const y1 = y0 + 1;
  
      // Interpolation weights with improved smoothing
      const sx = this.fade(x - x0);
      const sy = this.fade(y - y0);
  
      // Interpolate between grid point gradients
      const n0 = this.dotGridGradient(x0, y0, x, y);
      const n1 = this.dotGridGradient(x1, y0, x, y);
      const ix0 = this.lerp(n0, n1, sx);
  
      const n2 = this.dotGridGradient(x0, y1, x, y);
      const n3 = this.dotGridGradient(x1, y1, x, y);
      const ix1 = this.lerp(n2, n3, sx);
  
      const value = this.lerp(ix0, ix1, sy);
      
      // Cache result for repeated lookups
      this.memory[memKey] = value;
      
      return value;
    }
    
    // Fractal Brownian Motion (fBm) - multiple octaves of noise
    fbm(x, y, octaves = 6, lacunarity = 2.0, persistence = 0.5) {
      let total = 0;
      let frequency = 1;
      let amplitude = 1;
      let maxValue = 0;
      
      for (let i = 0; i < octaves; i++) {
        total += this.get(x * frequency, y * frequency) * amplitude;
        maxValue += amplitude;
        
        // Increase frequency, decrease amplitude for each octave
        amplitude *= persistence;
        frequency *= lacunarity;
      }
      
      return total / maxValue;
    }
    
    // Ridged multifractal noise - creates ridges and valleys
    ridged(x, y, octaves = 6, lacunarity = 2.0, persistence = 0.5) {
      let total = 0;
      let frequency = 1;
      let amplitude = 1;
      let maxValue = 0;
      
      for (let i = 0; i < octaves; i++) {
        // Get noise value
        let noise = this.get(x * frequency, y * frequency);
        
        // Transform to create ridges
        noise = 1 - Math.abs(noise);
        noise = noise * noise; // Square for sharper ridges
        
        total += noise * amplitude;
        maxValue += amplitude;
        
        amplitude *= persistence;
        frequency *= lacunarity;
      }
      
      return total / maxValue;
    }
    
    // Domain warping - distorts the input space for more organic patterns
    warp(x, y, strength = 10.0) {
      // Warp the input coordinates
      const warpX = x + this.get(x * 0.05, y * 0.05) * strength;
      const warpY = y + this.get(x * 0.05 + 100, y * 0.05 + 100) * strength;
      
      // Get noise at warped coordinates
      return this.get(warpX, warpY);
    }
    
    // Clear cache to save memory
    clearCache() {
      this.memory = {};
    }
  }
  
  // Enhanced MapGenerator class using the improved noise generation
  export class EnhancedMapGenerator {
    constructor(options = {}) {
      this.seed = options.seed || Math.random();
      this.perlin = new EnhancedPerlinNoise(this.seed);
      
      // Map dimensions
      this.width = options.width || 256;
      this.height = options.height || 256;
      
      // Optional parameters
      this.waterLevel = options.waterLevel || 0.3;
      this.mountainLevel = options.mountainLevel || 0.7;
      this.forestLevel = options.forestLevel || 0.5;
      
      // Configure tile IDs
      this.TILE_IDS = options.TILE_IDS || {
        FLOOR: 0,
        WALL: 1,
        OBSTACLE: 2,
        WATER: 3,
        MOUNTAIN: 4
      };
    }
    
    // Generate a complete world map
    generateWorld() {
      // Create temperature and moisture maps
      const temperatureMap = this.generateTemperatureMap();
      const moistureMap = this.generateMoistureMap();
      
      // Generate base terrain using multiple noise techniques
      const heightMap = this.generateHeightMap();
      
      // Convert height map to tile types
      const tiles = this.convertToTiles(heightMap, temperatureMap, moistureMap);
      
      // Ensure map edges have walls
      this.addMapBorders(tiles);
      
      // Generate rivers if desired
      // this.generateRivers(tiles, heightMap);
      
      return {
        width: this.width,
        height: this.height,
        tiles: tiles,
        seed: this.seed
      };
    }
    
    // Generate temperature variation across the map (equator to poles)
    generateTemperatureMap() {
      const map = Array(this.height).fill().map(() => Array(this.width).fill(0));
      
      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          // Base temperature gradient from south to north (equator in middle)
          const latitudeFactor = 1.0 - Math.abs((y / this.height) - 0.5) * 2;
          
          // Add some noise for local variations
          const noise = this.perlin.get(x * 0.01, y * 0.01) * 0.2;
          
          map[y][x] = latitudeFactor * 0.8 + noise;
        }
      }
      
      return map;
    }
    
    // Generate moisture map (used for biome determination)
    generateMoistureMap() {
      const map = Array(this.height).fill().map(() => Array(this.width).fill(0));
      
      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          // Use domain warping for more interesting moisture patterns
          const warpX = x + this.perlin.get(x * 0.02, y * 0.02) * 20;
          const warpY = y + this.perlin.get(x * 0.02 + 40, y * 0.02 + 30) * 20;
          
          map[y][x] = this.perlin.fbm(warpX * 0.01, warpY * 0.01, 4, 2.0, 0.5);
        }
      }
      
      return map;
    }
    
    // Generate base height map using multiple noise techniques
    generateHeightMap() {
      const map = Array(this.height).fill().map(() => Array(this.width).fill(0));
      
      // Parameter for continent vs detailed noise
      const continentScale = 0.002; // Large scale continent shapes
      const detailScale = 0.01;     // Medium scale terrain features
      const microScale = 0.05;      // Small scale details
      
      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          // Continent shapes (large scale)
          const continentNoise = this.perlin.fbm(x * continentScale, y * continentScale, 3, 2.0, 0.5);
          
          // Apply some ridged noise for mountain ranges
          const ridgeNoise = this.perlin.ridged(x * detailScale, y * detailScale, 4, 2.0, 0.5);
          
          // Detailed noise
          const detailNoise = this.perlin.fbm(x * microScale, y * microScale, 3, 2.0, 0.5);
          
          // Combine the different scales
          const combinedNoise = continentNoise * 0.6 + ridgeNoise * 0.3 + detailNoise * 0.1;
          
          // Apply curve to emphasize landmasses and oceans
          map[y][x] = this.applyHeightCurve(combinedNoise);
        }
      }
      
      return map;
    }
    
    // Apply non-linear curve to height values to create clearer distinctions
    applyHeightCurve(height) {
      // This makes flatter areas for oceans and land, with steeper transitions
      if (height < this.waterLevel - 0.1) {
        // Deep ocean
        return height * 0.5;
      } else if (height < this.waterLevel + 0.1) {
        // Coastline transition
        return this.waterLevel + (height - this.waterLevel) * 0.8;
      } else if (height > this.mountainLevel) {
        // Mountains get exaggerated
        return this.mountainLevel + (height - this.mountainLevel) * 1.5;
      }
      
      // Normal lands
      return height;
    }
    
    // Convert height map to actual tile types
    convertToTiles(heightMap, temperatureMap, moistureMap) {
      const tiles = Array(this.height).fill().map(() => Array(this.width).fill(0));
      
      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          const height = heightMap[y][x];
          const temperature = temperatureMap[y][x];
          const moisture = moistureMap[y][x];
          
          // Use determineTileType to set the tile type
          tiles[y][x] = this.determineTileType(height, temperature, moisture, x, y);
        }
      }
      
      return tiles;
    }
    
    // Determine tile type based on height, temperature, and moisture
    determineTileType(height, temperature, moisture, x, y) {
      // We're explicitly NOT checking for map borders here!
      // That will be handled separately to ensure only the edges get walls
      
      // Determine base tile type from height
      if (height < this.waterLevel) {
        return this.TILE_IDS.WATER;
      } else if (height > this.mountainLevel) {
        return this.TILE_IDS.MOUNTAIN;
      } else {
        // Land tiles - could be floor or obstacle based on biome
        if (moisture > this.forestLevel && temperature > 0.3) {
          // Forest/obstacle in moderate to wet areas
          return this.TILE_IDS.OBSTACLE;
        } else {
          // Basic floor for most land
          return this.TILE_IDS.FLOOR;
        }
      }
    }
    
    // Add walls only at map borders
    addMapBorders(tiles) {
      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          // Only put walls at the absolute edges of the map
          if (x === 0 || y === 0 || x === this.width - 1 || y === this.height - 1) {
            tiles[y][x] = this.TILE_IDS.WALL;
          }
        }
      }
    }
    
    // Generate a chunk for the given coordinates
    generateChunkData(chunkRow, chunkCol, chunkSize) {
      const tiles = [];
      
      for (let y = 0; y < chunkSize; y++) {
        const row = [];
        for (let x = 0; x < chunkSize; x++) {
          const globalX = chunkCol * chunkSize + x;
          const globalY = chunkRow * chunkSize + y;
          
          // Check if this position is within the world bounds
          if (globalX >= this.width || globalY >= this.height || globalX < 0 || globalY < 0) {
            // Out of bounds - use floor instead of wall
            row.push({ type: this.TILE_IDS.FLOOR, height: 0 });
            continue;
          }
          
          // Generate the necessary data for this tile
          const heightValue = this.getHeightAt(globalX, globalY);
          const temperature = this.getTemperatureAt(globalX, globalY);
          const moisture = this.getMoistureAt(globalX, globalY);
          
          // Determine tile type (excluding border walls, those are added separately)
          const tileType = this.determineTileType(heightValue, temperature, moisture, globalX, globalY);
          
          // Create a tile object with the type and height value
          row.push({ type: tileType, height: heightValue });
        }
        tiles.push(row);
      }
      
      // Now check and apply border walls ONLY at the edges of the world
      for (let y = 0; y < chunkSize; y++) {
        for (let x = 0; x < chunkSize; x++) {
          const globalX = chunkCol * chunkSize + x;
          const globalY = chunkRow * chunkSize + y;
          
          // Only put walls at the absolute edges of the map
          if (globalX === 0 || globalY === 0 || 
              globalX === this.width - 1 || globalY === this.height - 1) {
            tiles[y][x] = { type: this.TILE_IDS.WALL, height: 0 };
          }
        }
      }
      
      return {
        x: chunkCol,
        y: chunkRow,
        tiles: tiles
      };
    }
    
    // Helper methods to get values at specific coordinates
    getHeightAt(x, y) {
      const continentNoise = this.perlin.fbm(x * 0.002, y * 0.002, 3, 2.0, 0.5);
      const ridgeNoise = this.perlin.ridged(x * 0.01, y * 0.01, 4, 2.0, 0.5);
      const detailNoise = this.perlin.fbm(x * 0.05, y * 0.05, 3, 2.0, 0.5);
      
      const combinedNoise = continentNoise * 0.6 + ridgeNoise * 0.3 + detailNoise * 0.1;
      return this.applyHeightCurve(combinedNoise);
    }
    
    getTemperatureAt(x, y) {
      const latitudeFactor = 1.0 - Math.abs((y / this.height) - 0.5) * 2;
      const noise = this.perlin.get(x * 0.01, y * 0.01) * 0.2;
      return latitudeFactor * 0.8 + noise;
    }
    
    getMoistureAt(x, y) {
      const warpX = x + this.perlin.get(x * 0.02, y * 0.02) * 20;
      const warpY = y + this.perlin.get(x * 0.02 + 40, y * 0.02 + 30) * 20;
      return this.perlin.fbm(warpX * 0.01, warpY * 0.01, 4, 2.0, 0.5);
    }
  }
  
  // Example usage to replace your current MapManager implementation
  
  /**
   * Implementation to integrate with your existing code
   * This shows how to replace the procedural generation parts while
   * keeping your existing MapManager interface
   */
  export function enhanceMapManager(MapManager) {
    // Store the original methods we're going to override
    const originalGenerateChunkData = MapManager.prototype.generateChunkData;
    const originalDetermineTileType = MapManager.prototype.determineTileType;
    
    // Enhanced tile type determination
    MapManager.prototype.determineTileType = function(heightValue, x, y) {
      // ONLY put walls at the absolute edges of the map
      // This is the key fix for your wall problem
      if (x === 0 || y === 0 || x === this.width - 1 || y === this.height - 1) {
        return TILE_IDS.WALL;
      }
      
      // Use enhanced algorithm for everything else
      if (heightValue < -0.4) return TILE_IDS.WATER;
      if (heightValue < 0.3) return TILE_IDS.FLOOR; // Increased this threshold for more floor tiles
      if (heightValue < 0.6) return TILE_IDS.OBSTACLE; // Moved obstacle threshold up
      return TILE_IDS.MOUNTAIN;
    };
    
    // Enhanced chunk generation with better noise
    MapManager.prototype.generateChunkData = function(chunkRow, chunkCol) {
      // Check if we've already created an enhanced perlin instance
      if (!this.enhancedPerlin) {
        this.enhancedPerlin = new EnhancedPerlinNoise(this.perlin.seed);
      }
      
      const tiles = [];
      
      for (let y = 0; y < CHUNK_SIZE; y++) {
        const row = [];
        for (let x = 0; x < CHUNK_SIZE; x++) {
          const globalX = chunkCol * CHUNK_SIZE + x;
          const globalY = chunkRow * CHUNK_SIZE + y;
          
          // Skip if out of world bounds
          if (globalX >= this.width || globalY >= this.height) {
            row.push(new Tile(TILE_IDS.FLOOR)); // Use FLOOR instead of WALL for out of bounds
            continue;
          }
          
          // Use enhanced noise functions for better terrain
          // Combined noise at different scales
          const continentNoise = this.enhancedPerlin.fbm(globalX * 0.002, globalY * 0.002, 3, 2.0, 0.5);
          const ridgeNoise = this.enhancedPerlin.ridged(globalX * 0.01, globalY * 0.01, 4, 2.0, 0.5);
          const detailNoise = this.enhancedPerlin.fbm(globalX * 0.05, globalY * 0.05, 3, 2.0, 0.5);
          
          // Combine noise layers
          const heightValue = continentNoise * 0.6 + ridgeNoise * 0.3 + detailNoise * 0.1;
          
          // Determine tile type with our improved function
          const tileType = this.determineTileType(heightValue, globalX, globalY);
          
          row.push(new Tile(tileType, heightValue));
        }
        tiles.push(row);
      }
      
      return {
        x: chunkCol,
        y: chunkRow,
        tiles: tiles
      };
    };
    
    return MapManager;
  }
  
  // Standalone map generator that you can use if you prefer
  export class ImprovedMapManager {
    constructor(options = {}) {
      this.chunks = new Map(); // Map of "x,y" -> chunk data
      this.width = options.width || 256;
      this.height = options.height || 256;
      this.tileSize = options.tileSize || 12;
      
      // Create enhanced noise generator
      this.seed = options.seed || Math.random();
      this.perlin = new EnhancedPerlinNoise(this.seed);
      
      // Map settings
      this.proceduralEnabled = true;
      this.isFixedMap = false;
      
      console.log(`Improved MapManager initialized with seed: ${this.seed}`);
    }
    
    // Generate a new world
    generateWorld(width, height, options = {}) {
      this.width = width;
      this.height = height;
      
      // Clear existing chunks
      this.chunks.clear();
      
      console.log(`World initialized with size ${width}x${height}`);
      
      // Create a map ID
      const mapId = options.id || `map_${Date.now()}`;
      
      return mapId;
    }
    
    // Get a chunk (generate if needed)
    getChunkData(mapId, chunkX, chunkY) {
      const key = `${mapId || 'default'}_${chunkX},${chunkY}`;
      
      // If chunk exists in cache, return it
      if (this.chunks.has(key)) {
        return this.chunks.get(key);
      }
      
      // Otherwise generate it
      if (this.proceduralEnabled && !this.isFixedMap) {
        const chunkData = this.generateChunkData(chunkX, chunkY);
        this.chunks.set(key, chunkData);
        return chunkData;
      }
      
      return null;
    }
    
    // Generate chunk data with enhanced algorithm
    generateChunkData(chunkRow, chunkCol) {
      const tiles = [];
      
      for (let y = 0; y < CHUNK_SIZE; y++) {
        const row = [];
        for (let x = 0; x < CHUNK_SIZE; x++) {
          const globalX = chunkCol * CHUNK_SIZE + x;
          const globalY = chunkRow * CHUNK_SIZE + y;
          
          // Skip if out of world bounds
          if (globalX >= this.width || globalY >= this.height) {
            row.push(new Tile(TILE_IDS.FLOOR)); // Use FLOOR instead of WALL for out of bounds
            continue;
          }
          
          // Multi-scale noise for better terrain
          const continentNoise = this.perlin.fbm(globalX * 0.002, globalY * 0.002, 3, 2.0, 0.5);
          const ridgeNoise = this.perlin.ridged(globalX * 0.01, globalY * 0.01, 4, 2.0, 0.5);
          const detailNoise = this.perlin.fbm(globalX * 0.05, globalY * 0.05, 3, 2.0, 0.5);
          
          // Combined noise
          const heightValue = continentNoise * 0.6 + ridgeNoise * 0.3 + detailNoise * 0.1;
          
          // Determine tile type
          const tileType = this.determineTileType(heightValue, globalX, globalY);
          
          row.push(new Tile(tileType, heightValue));
        }
        tiles.push(row);
      }
      
      return {
        x: chunkCol,
        y: chunkRow,
        tiles: tiles
      };
    }
    
    // Enhanced tile type determination
    determineTileType(heightValue, x, y) {
      // ONLY put walls at the absolute edges of the map
      if (x === 0 || y === 0 || x === this.width - 1 || y === this.height - 1) {
        return TILE_IDS.WALL;
      }
      
      // Determine tile type based on height - adjusted thresholds
      if (heightValue < -0.4) return TILE_IDS.WATER;
      if (heightValue < 0.3) return TILE_IDS.FLOOR; // More walkable space
      if (heightValue < 0.6) return TILE_IDS.OBSTACLE;
      return TILE_IDS.MOUNTAIN;
    }
    
    // Get a specific tile
    getTile(x, y) {
      // Convert to chunk coordinates
      const chunkX = Math.floor(x / CHUNK_SIZE);
      const chunkY = Math.floor(y / CHUNK_SIZE);
      const localX = x % CHUNK_SIZE;
      const localY = y % CHUNK_SIZE;
      
      // Get chunk
      const chunk = this.getChunkData(null, chunkX, chunkY);
      if (!chunk) return null;
      
      // Get tile from chunk
      return chunk.tiles[localY][localX];
    }
    
    // Check if a position is a wall or obstacle
    isWallOrOutOfBounds(x, y) {
      // Convert to tile coordinates
      const tileX = Math.floor(x / this.tileSize);
      const tileY = Math.floor(y / this.tileSize);
      
      // Check if out of bounds
      if (tileX < 0 || tileY < 0 || tileX >= this.width || tileY >= this.height) {
        return true;
      }
      
      // Get tile type
      const tileType = this.getTileType(tileX, tileY);
      
      // Check if wall or other solid obstacle
      return tileType === TILE_IDS.WALL || 
             tileType === TILE_IDS.MOUNTAIN || 
             tileType === TILE_IDS.WATER;
    }
    
    // Get the tile type at a specific coordinate
    getTileType(x, y) {
      const tile = this.getTile(x, y);
      return tile ? tile.type : null;
    }
  }
```

---
