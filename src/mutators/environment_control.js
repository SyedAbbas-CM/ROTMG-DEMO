// src/mutators/environment_control.js
// Control map environment, terrain, lighting, and physics

/**
 * Control and modify the game environment dynamically
 * @param {object} state - per-action scratch object
 * @param {{action:string, intensity:number, duration:number, radius:number,
 *          pattern:string, color:number, speed:number, frequency:number}} args
 * @param {number} dt - deltaTime (seconds)
 * @param {*} bossMgr - BossManager instance
 * @param {*} bulletMgr - BulletManager instance
 * @param {*} mapMgr - MapManager instance
 * @param {*} enemyMgr - EnemyManager instance
 * @returns {boolean} finished?
 */
export function environment_control(state, args, dt, bossMgr, bulletMgr, mapMgr, enemyMgr) {
  const idx = 0;
  
  if (!state.init) {
    state.init = true;
    state.action = args.action ?? 'earthquake';\n    state.intensity = args.intensity ?? 1.0;\n    state.duration = args.duration ?? 3.0;\n    state.radius = args.radius ?? 10;\n    state.pattern = args.pattern ?? 'radial';\n    state.color = args.color ?? 0xffffff;\n    state.speed = args.speed ?? 2;\n    state.frequency = args.frequency ?? 1;\n    \n    state.time = 0;\n    state.originalState = {};\n    \n    // Store original environment state\n    storeOriginalState(state, mapMgr);\n  }\n  \n  state.time += dt;\n  const progress = state.time / state.duration;\n  \n  // Apply environment effect\n  switch (state.action) {\n    case 'earthquake':\n      applyEarthquake(state, progress, bossMgr, mapMgr, idx);\n      break;\n    case 'darkness':\n      applyDarkness(state, progress, mapMgr);\n      break;\n    case 'fog':\n      applyFog(state, progress, mapMgr);\n      break;\n    case 'lava_rising':\n      applyLavaRising(state, progress, mapMgr, bulletMgr);\n      break;\n    case 'ice_freeze':\n      applyIceFreeze(state, progress, mapMgr);\n      break;\n    case 'wind_storm':\n      applyWindStorm(state, progress, bulletMgr);\n      break;\n    case 'gravity_shift':\n      applyGravityShift(state, progress, bulletMgr);\n      break;\n    case 'time_slow':\n      applyTimeSlow(state, progress, mapMgr);\n      break;\n    case 'reality_warp':\n      applyRealityWarp(state, progress, mapMgr);\n      break;\n    case 'arena_shrink':\n      applyArenaShrink(state, progress, mapMgr, bulletMgr, bossMgr, idx);\n      break;\n  }\n  \n  // Cleanup when finished\n  if (progress >= 1.0) {\n    restoreOriginalState(state, mapMgr);\n    return true;\n  }\n  \n  return false;\n}\n\nfunction storeOriginalState(state, mapMgr) {\n  if (mapMgr.lighting) {\n    state.originalState.lighting = { ...mapMgr.lighting };\n  }\n  if (mapMgr.physics) {\n    state.originalState.physics = { ...mapMgr.physics };\n  }\n  if (mapMgr.weather) {\n    state.originalState.weather = { ...mapMgr.weather };\n  }\n}\n\nfunction restoreOriginalState(state, mapMgr) {\n  if (state.originalState.lighting && mapMgr.lighting) {\n    Object.assign(mapMgr.lighting, state.originalState.lighting);\n  }\n  if (state.originalState.physics && mapMgr.physics) {\n    Object.assign(mapMgr.physics, state.originalState.physics);\n  }\n  if (state.originalState.weather && mapMgr.weather) {\n    Object.assign(mapMgr.weather, state.originalState.weather);\n  }\n}\n\nfunction applyEarthquake(state, progress, bossMgr, mapMgr, idx) {\n  const intensity = state.intensity * Math.sin(progress * Math.PI);\n  const shakeAmount = intensity * 0.5;\n  \n  // Screen shake effect\n  if (mapMgr.camera) {\n    mapMgr.camera.shakeX = (Math.random() - 0.5) * shakeAmount;\n    mapMgr.camera.shakeY = (Math.random() - 0.5) * shakeAmount;\n  }\n  \n  // Falling debris\n  if (Math.random() < intensity * 0.1) {\n    const debrisX = bossMgr.x[idx] + (Math.random() - 0.5) * state.radius * 2;\n    const debrisY = bossMgr.y[idx] + (Math.random() - 0.5) * state.radius * 2;\n    \n    if (mapMgr.addDebris) {\n      mapMgr.addDebris({\n        x: debrisX,\n        y: debrisY,\n        damage: state.intensity * 50,\n        radius: 1,\n        lifetime: 2.0\n      });\n    }\n  }\n}\n\nfunction applyDarkness(state, progress, mapMgr) {\n  const darknessLevel = state.intensity * Math.sin(progress * Math.PI);\n  \n  if (mapMgr.lighting) {\n    mapMgr.lighting.ambient = Math.max(0.1, 1.0 - darknessLevel);\n    mapMgr.lighting.darkness = darknessLevel;\n  }\n  \n  // Reduce visibility range\n  if (mapMgr.visibility) {\n    mapMgr.visibility.range = Math.max(3, 15 - darknessLevel * 10);\n  }\n}\n\nfunction applyFog(state, progress, mapMgr) {\n  const fogDensity = state.intensity * Math.sin(progress * Math.PI);\n  \n  if (mapMgr.weather) {\n    mapMgr.weather.fog = {\n      density: fogDensity,\n      color: state.color,\n      speed: state.speed\n    };\n  }\n  \n  // Reduce visibility\n  if (mapMgr.visibility) {\n    mapMgr.visibility.range = Math.max(2, 12 - fogDensity * 8);\n  }\n}\n\nfunction applyLavaRising(state, progress, mapMgr, bulletMgr) {\n  const lavaHeight = progress * state.intensity * 5;\n  \n  if (mapMgr.hazards) {\n    mapMgr.hazards.lava = {\n      height: lavaHeight,\n      damage: state.intensity * 100,\n      rising: true\n    };\n  }\n  \n  // Create lava damage zones\n  if (bulletMgr.addDamageZone && Math.random() < 0.1) {\n    bulletMgr.addDamageZone({\n      x: Math.random() * 50,\n      y: Math.random() * 50,\n      radius: 2,\n      damage: state.intensity * 80,\n      duration: 1.0,\n      type: 'lava',\n      visual: 'lava_bubble'\n    });\n  }\n}\n\nfunction applyIceFreeze(state, progress, mapMgr) {\n  const freezeIntensity = state.intensity * Math.sin(progress * Math.PI);\n  \n  if (mapMgr.physics) {\n    mapMgr.physics.friction = Math.max(0.1, 1.0 - freezeIntensity * 0.8);\n    mapMgr.physics.slippery = freezeIntensity > 0.5;\n  }\n  \n  if (mapMgr.weather) {\n    mapMgr.weather.ice = {\n      intensity: freezeIntensity,\n      temperature: -freezeIntensity * 50\n    };\n  }\n}\n\nfunction applyWindStorm(state, progress, bulletMgr) {\n  const windForce = state.intensity * Math.sin(progress * Math.PI * 2);\n  const windAngle = state.time * state.speed;\n  \n  // Apply wind force to projectiles\n  if (bulletMgr.applyWind) {\n    bulletMgr.applyWind({\n      forceX: Math.cos(windAngle) * windForce,\n      forceY: Math.sin(windAngle) * windForce,\n      radius: state.radius\n    });\n  }\n}\n\nfunction applyGravityShift(state, progress, bulletMgr) {\n  const gravityAngle = progress * Math.PI * 2;\n  const gravityStrength = state.intensity;\n  \n  if (bulletMgr.setGravity) {\n    bulletMgr.setGravity({\n      x: Math.cos(gravityAngle) * gravityStrength,\n      y: Math.sin(gravityAngle) * gravityStrength\n    });\n  }\n}\n\nfunction applyTimeSlow(state, progress, mapMgr) {\n  const slowFactor = 1.0 - (state.intensity * Math.sin(progress * Math.PI) * 0.8);\n  \n  if (mapMgr.timeScale) {\n    mapMgr.timeScale.global = slowFactor;\n    mapMgr.timeScale.bullets = slowFactor;\n    mapMgr.timeScale.enemies = slowFactor;\n  }\n}\n\nfunction applyRealityWarp(state, progress, mapMgr) {\n  const warpIntensity = state.intensity * Math.sin(progress * Math.PI);\n  \n  if (mapMgr.distortion) {\n    mapMgr.distortion.wave = {\n      amplitude: warpIntensity,\n      frequency: state.frequency,\n      speed: state.speed,\n      time: state.time\n    };\n  }\n  \n  // Random teleportation zones\n  if (Math.random() < warpIntensity * 0.05 && mapMgr.addTeleportZone) {\n    mapMgr.addTeleportZone({\n      x: Math.random() * 50,\n      y: Math.random() * 50,\n      radius: 2,\n      targetX: Math.random() * 50,\n      targetY: Math.random() * 50,\n      duration: 3.0\n    });\n  }\n}\n\nfunction applyArenaShrink(state, progress, mapMgr, bulletMgr, bossMgr, idx) {\n  const shrinkAmount = progress * state.intensity;\n  const centerX = bossMgr.x[idx];\n  const centerY = bossMgr.y[idx];\n  const currentRadius = state.radius * (1 - shrinkAmount);\n  \n  // Create damage wall at arena edge\n  if (bulletMgr.addDamageZone) {\n    const wallThickness = 1;\n    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {\n      const wallX = centerX + Math.cos(angle) * currentRadius;\n      const wallY = centerY + Math.sin(angle) * currentRadius;\n      \n      bulletMgr.addDamageZone({\n        x: wallX,\n        y: wallY,\n        radius: wallThickness,\n        damage: state.intensity * 200,\n        duration: 0.5,\n        type: 'arena_wall',\n        visual: 'energy_wall'\n      });\n    }\n  }\n  \n  // Update arena bounds\n  if (mapMgr.bounds) {\n    mapMgr.bounds.radius = currentRadius;\n    mapMgr.bounds.centerX = centerX;\n    mapMgr.bounds.centerY = centerY;\n  }\n}