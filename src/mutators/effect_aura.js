// src/mutators/effect_aura.js
// Apply status effects and auras to players and environment

/**
 * Create auras and apply status effects dynamically
 * @param {object} state - per-action scratch object
 * @param {{auraType:string, radius:number, effect:string, intensity:number,
 *          duration:number, pulseRate:number, stackable:boolean, friendly:boolean,
 *          visual:boolean, sound:boolean, damage:number, heal:number}} args
 * @param {number} dt - deltaTime (seconds)
 * @param {*} bossMgr - BossManager instance
 * @param {*} bulletMgr - BulletManager instance
 * @param {*} mapMgr - MapManager instance
 * @param {*} enemyMgr - EnemyManager instance
 * @returns {boolean} finished?
 */
export function effect_aura(state, args, dt, bossMgr, bulletMgr, mapMgr, enemyMgr) {
  const idx = 0;
  
  if (!state.init) {
    state.init = true;
    state.auraType = args.auraType ?? 'damage';\n    state.radius = args.radius ?? 5;\n    state.effect = args.effect ?? 'poison';\n    state.intensity = args.intensity ?? 1;\n    state.duration = args.duration ?? 5.0;\n    state.pulseRate = args.pulseRate ?? 1.0;\n    state.stackable = args.stackable ?? false;\n    state.friendly = args.friendly ?? false;\n    state.visual = args.visual ?? true;\n    state.sound = args.sound ?? true;\n    state.damage = args.damage ?? 30;\n    state.heal = args.heal ?? 0;\n    \n    state.time = 0;\n    state.pulseTimer = 0;\n    state.affectedTargets = new Set();\n  }\n  \n  state.time += dt;\n  state.pulseTimer += dt;\n  \n  const cx = bossMgr.x[idx];\n  const cy = bossMgr.y[idx];\n  \n  // Apply aura effects on pulse\n  if (state.pulseTimer >= 1.0 / state.pulseRate) {\n    state.pulseTimer = 0;\n    applyAuraEffects(state, cx, cy, bossMgr, bulletMgr, enemyMgr);\n  }\n  \n  // Visual effects\n  if (state.visual && bulletMgr.addEffect) {\n    addAuraVisuals(state, cx, cy, bulletMgr);\n  }\n  \n  return state.time >= state.duration;\n}\n\nfunction applyAuraEffects(state, cx, cy, bossMgr, bulletMgr, enemyMgr) {\n  switch (state.auraType) {\n    case 'damage':\n      applyDamageAura(state, cx, cy, bulletMgr);\n      break;\n    case 'heal':\n      applyHealAura(state, cx, cy, enemyMgr);\n      break;\n    case 'slow':\n      applySlowAura(state, cx, cy);\n      break;\n    case 'poison':\n      applyPoisonAura(state, cx, cy);\n      break;\n    case 'confusion':\n      applyConfusionAura(state, cx, cy);\n      break;\n    case 'fear':\n      applyFearAura(state, cx, cy);\n      break;\n    case 'rage':\n      applyRageAura(state, cx, cy, enemyMgr);\n      break;\n    case 'shield':\n      applyShieldAura(state, cx, cy);\n      break;\n    case 'speed':\n      applySpeedAura(state, cx, cy, enemyMgr);\n      break;\n    case 'drain':\n      applyDrainAura(state, cx, cy, bossMgr);\n      break;\n  }\n}\n\nfunction applyDamageAura(state, cx, cy, bulletMgr) {\n  // Create damage zone\n  if (bulletMgr.addDamageZone) {\n    bulletMgr.addDamageZone({\n      x: cx,\n      y: cy,\n      radius: state.radius,\n      damage: state.damage,\n      duration: 1.0 / state.pulseRate,\n      owner: 'boss',\n      type: 'aura_damage',\n      effect: state.effect\n    });\n  }\n}\n\nfunction applyHealAura(state, cx, cy, enemyMgr) {\n  // Heal nearby enemies (minions)\n  const nearbyEnemies = getNearbyEnemies(cx, cy, state.radius, enemyMgr);\n  \n  for (const enemy of nearbyEnemies) {\n    if (enemyMgr.heal) {\n      enemyMgr.heal(enemy.index, state.heal);\n    }\n  }\n}\n\nfunction applySlowAura(state, cx, cy) {\n  // Apply slow effect to nearby players\n  const nearbyPlayers = getNearbyPlayers(cx, cy, state.radius);\n  \n  for (const player of nearbyPlayers) {\n    applyStatusEffect(player, 'slow', state.intensity, 1.0 / state.pulseRate);\n  }\n}\n\nfunction applyPoisonAura(state, cx, cy) {\n  const nearbyPlayers = getNearbyPlayers(cx, cy, state.radius);\n  \n  for (const player of nearbyPlayers) {\n    applyStatusEffect(player, 'poison', state.damage, 3.0);\n  }\n}\n\nfunction applyConfusionAura(state, cx, cy) {\n  const nearbyPlayers = getNearbyPlayers(cx, cy, state.radius);\n  \n  for (const player of nearbyPlayers) {\n    applyStatusEffect(player, 'confusion', 1, 2.0);\n  }\n}\n\nfunction applyFearAura(state, cx, cy) {\n  const nearbyPlayers = getNearbyPlayers(cx, cy, state.radius);\n  \n  for (const player of nearbyPlayers) {\n    // Force players to move away from boss\n    const dx = player.x - cx;\n    const dy = player.y - cy;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    \n    if (distance > 0) {\n      const pushForce = state.intensity;\n      player.vx = (dx / distance) * pushForce;\n      player.vy = (dy / distance) * pushForce;\n    }\n  }\n}\n\nfunction applyRageAura(state, cx, cy, enemyMgr) {\n  // Boost nearby minions\n  const nearbyEnemies = getNearbyEnemies(cx, cy, state.radius, enemyMgr);\n  \n  for (const enemy of nearbyEnemies) {\n    if (enemyMgr.boost) {\n      enemyMgr.boost(enemy.index, {\n        damage: state.intensity,\n        speed: state.intensity * 0.5,\n        duration: 1.0 / state.pulseRate\n      });\n    }\n  }\n}\n\nfunction applyShieldAura(state, cx, cy) {\n  const nearbyEnemies = getNearbyEnemies(cx, cy, state.radius);\n  \n  for (const enemy of nearbyEnemies) {\n    applyStatusEffect(enemy, 'shield', state.intensity, 1.0 / state.pulseRate);\n  }\n}\n\nfunction applySpeedAura(state, cx, cy, enemyMgr) {\n  const nearbyEnemies = getNearbyEnemies(cx, cy, state.radius, enemyMgr);\n  \n  for (const enemy of nearbyEnemies) {\n    if (enemyMgr.boost) {\n      enemyMgr.boost(enemy.index, {\n        speed: state.intensity,\n        duration: 1.0 / state.pulseRate\n      });\n    }\n  }\n}\n\nfunction applyDrainAura(state, cx, cy, bossMgr) {\n  const nearbyPlayers = getNearbyPlayers(cx, cy, state.radius);\n  const drainPerPlayer = state.heal / Math.max(1, nearbyPlayers.length);\n  \n  if (nearbyPlayers.length > 0 && bossMgr.heal) {\n    bossMgr.heal(0, drainPerPlayer * nearbyPlayers.length);\n  }\n  \n  for (const player of nearbyPlayers) {\n    applyStatusEffect(player, 'drain', state.damage, 1.0);\n  }\n}\n\nfunction addAuraVisuals(state, cx, cy, bulletMgr) {\n  const visualType = getAuraVisualType(state.auraType);\n  const color = getAuraColor(state.auraType);\n  \n  bulletMgr.addEffect({\n    type: visualType,\n    x: cx,\n    y: cy,\n    radius: state.radius,\n    color: color,\n    intensity: state.intensity,\n    pulseRate: state.pulseRate,\n    duration: 0.5\n  });\n}\n\nfunction getAuraVisualType(auraType) {\n  const visualMap = {\n    damage: 'aura_damage',\n    heal: 'aura_heal',\n    slow: 'aura_slow',\n    poison: 'aura_poison',\n    confusion: 'aura_confusion',\n    fear: 'aura_fear',\n    rage: 'aura_rage',\n    shield: 'aura_shield',\n    speed: 'aura_speed',\n    drain: 'aura_drain'\n  };\n  return visualMap[auraType] || 'aura_generic';\n}\n\nfunction getAuraColor(auraType) {\n  const colorMap = {\n    damage: 0xff0000,    // Red\n    heal: 0x00ff00,      // Green\n    slow: 0x0000ff,      // Blue\n    poison: 0x800080,    // Purple\n    confusion: 0xffff00, // Yellow\n    fear: 0x8b0000,      // Dark red\n    rage: 0xff4500,      // Orange red\n    shield: 0x00ffff,    // Cyan\n    speed: 0x00ff80,     // Green-cyan\n    drain: 0x800080      // Purple\n  };\n  return colorMap[auraType] || 0xffffff;\n}\n\n// Helper functions\nfunction getNearbyPlayers(cx, cy, radius) {\n  // Mock implementation - would get actual players in range\n  return [\n    { x: cx + 2, y: cy + 1, id: 'player1' },\n    { x: cx - 1, y: cy + 3, id: 'player2' }\n  ].filter(p => {\n    const dist = Math.sqrt((p.x - cx) ** 2 + (p.y - cy) ** 2);\n    return dist <= radius;\n  });\n}\n\nfunction getNearbyEnemies(cx, cy, radius, enemyMgr) {\n  // Mock implementation - would get actual enemies in range\n  return [\n    { x: cx + 1, y: cy - 2, index: 0 },\n    { x: cx - 3, y: cy + 1, index: 1 }\n  ].filter(e => {\n    const dist = Math.sqrt((e.x - cx) ** 2 + (e.y - cy) ** 2);\n    return dist <= radius;\n  });\n}\n\nfunction applyStatusEffect(target, effect, intensity, duration) {\n  // Mock implementation - would apply actual status effect\n  console.log(`Applied ${effect} (${intensity}) to ${target.id || target.index} for ${duration}s`);\n}