// src/mutators/conditional_trigger.js
// Trigger other mutators based on conditions - enables complex behavior trees

/**
 * Conditional trigger system for complex behavior branching
 * @param {object} state - per-action scratch object
 * @param {{condition:string, threshold:number, target:string, actions:array, 
 *          onTrue:array, onFalse:array, once:boolean, cooldown:number, 
 *          priority:string, interrupt:boolean}} args
 * @param {number} dt - deltaTime (seconds)
 * @param {*} bossMgr - BossManager instance
 * @param {*} bulletMgr - BulletManager instance
 * @param {*} mapMgr - MapManager instance
 * @param {*} enemyMgr - EnemyManager instance
 * @returns {boolean} finished?
 */
export function conditional_trigger(state, args, dt, bossMgr, bulletMgr, mapMgr, enemyMgr) {
  const idx = 0;
  
  if (!state.init) {
    state.init = true;
    state.condition = args.condition ?? 'hp_below';
    state.threshold = args.threshold ?? 0.5;
    state.target = args.target ?? 'self';
    state.actions = args.actions ?? [];\n    state.onTrue = args.onTrue ?? [];\n    state.onFalse = args.onFalse ?? [];\n    state.once = args.once ?? false;\n    state.cooldown = args.cooldown ?? 1.0;\n    state.priority = args.priority ?? 'normal';\n    state.interrupt = args.interrupt ?? false;\n    \n    state.triggered = false;\n    state.lastTrigger = 0;\n    state.conditionMet = false;\n  }\n  \n  // Update cooldown\n  state.lastTrigger += dt;\n  \n  // Check if on cooldown\n  if (state.lastTrigger < state.cooldown) {\n    return false;\n  }\n  \n  // Evaluate condition\n  const conditionResult = evaluateCondition(state, bossMgr, bulletMgr, enemyMgr, idx);\n  \n  // Check if condition state changed\n  const conditionChanged = conditionResult !== state.conditionMet;\n  state.conditionMet = conditionResult;\n  \n  // Skip if already triggered and set to once\n  if (state.once && state.triggered) {\n    return true;\n  }\n  \n  // Only trigger on condition change or continuous conditions\n  if (!conditionChanged && state.once) {\n    return false;\n  }\n  \n  // Trigger appropriate actions\n  if (conditionResult && state.onTrue.length > 0) {\n    triggerActions(state.onTrue, state, bossMgr);\n    state.triggered = true;\n    state.lastTrigger = 0;\n  } else if (!conditionResult && state.onFalse.length > 0) {\n    triggerActions(state.onFalse, state, bossMgr);\n    state.triggered = true;\n    state.lastTrigger = 0;\n  }\n  \n  // Legacy action support\n  if (conditionResult && state.actions.length > 0) {\n    triggerActions(state.actions, state, bossMgr);\n    state.triggered = true;\n    state.lastTrigger = 0;\n  }\n  \n  return state.once && state.triggered;\n}\n\nfunction evaluateCondition(state, bossMgr, bulletMgr, enemyMgr, idx) {\n  switch (state.condition) {\n    case 'hp_below':\n      return getHealthPercentage(bossMgr, idx) < state.threshold;\n    \n    case 'hp_above':\n      return getHealthPercentage(bossMgr, idx) > state.threshold;\n    \n    case 'time_elapsed':\n      return state.lastTrigger >= state.threshold;\n    \n    case 'players_nearby':\n      return getPlayersInRange(bossMgr, idx, state.threshold) > 0;\n    \n    case 'players_far':\n      return getPlayersInRange(bossMgr, idx, state.threshold) === 0;\n    \n    case 'minions_alive':\n      return getMinionCount(enemyMgr, idx) >= state.threshold;\n    \n    case 'minions_dead':\n      return getMinionCount(enemyMgr, idx) < state.threshold;\n    \n    case 'damage_taken':\n      return getDamageTaken(bossMgr, idx) >= state.threshold;\n    \n    case 'phase_time':\n      return getPhaseTime(bossMgr, idx) >= state.threshold;\n    \n    case 'player_count':\n      return getPlayerCount() >= state.threshold;\n    \n    case 'random':\n      return Math.random() < state.threshold;\n    \n    case 'position_x':\n      return bossMgr.x[idx] >= state.threshold;\n    \n    case 'position_y':\n      return bossMgr.y[idx] >= state.threshold;\n    \n    case 'distance_from_spawn':\n      return getDistanceFromSpawn(bossMgr, idx) >= state.threshold;\n    \n    case 'bullets_fired':\n      return getBulletsFired(bossMgr, idx) >= state.threshold;\n    \n    case 'ability_ready':\n      return isAbilityReady(bossMgr, idx, state.target);\n    \n    case 'stunned':\n      return isStunned(bossMgr, idx);\n    \n    case 'invulnerable':\n      return isInvulnerable(bossMgr, idx);\n    \n    default:\n      return false;\n  }\n}\n\nfunction triggerActions(actions, state, bossMgr) {\n  // Add actions to boss action queue\n  if (bossMgr.actionQueue && bossMgr.actionQueue[0]) {\n    const queue = bossMgr.actionQueue[0];\n    \n    for (const action of actions) {\n      // Handle priority and interruption\n      if (state.interrupt && state.priority === 'high') {\n        queue.unshift({ ...action, _state: {} }); // Add to front\n      } else {\n        queue.push({ ...action, _state: {} }); // Add to back\n      }\n    }\n  }\n}\n\n// Helper functions for condition evaluation\nfunction getHealthPercentage(bossMgr, idx) {\n  if (bossMgr.hp && bossMgr.maxHp) {\n    return bossMgr.hp[idx] / bossMgr.maxHp[idx];\n  }\n  return 1.0; // Default to full health\n}\n\nfunction getPlayersInRange(bossMgr, idx, range) {\n  // Mock implementation - would check actual player positions\n  const distance = Math.random() * 20;\n  return distance <= range ? 1 : 0;\n}\n\nfunction getMinionCount(enemyMgr, idx) {\n  // Mock implementation - would count actual minions\n  return Math.floor(Math.random() * 5);\n}\n\nfunction getDamageTaken(bossMgr, idx) {\n  // Mock implementation - would track actual damage\n  return bossMgr.damageTaken ? bossMgr.damageTaken[idx] : 0;\n}\n\nfunction getPhaseTime(bossMgr, idx) {\n  // Mock implementation - would track phase duration\n  return bossMgr.phaseTime ? bossMgr.phaseTime[idx] : 0;\n}\n\nfunction getPlayerCount() {\n  // Mock implementation - would get actual player count\n  return Math.floor(Math.random() * 8) + 1;\n}\n\nfunction getDistanceFromSpawn(bossMgr, idx) {\n  // Mock implementation - would calculate from spawn point\n  return Math.sqrt(\n    Math.pow(bossMgr.x[idx] - 0, 2) + \n    Math.pow(bossMgr.y[idx] - 0, 2)\n  );\n}\n\nfunction getBulletsFired(bossMgr, idx) {\n  // Mock implementation - would track bullets fired\n  return bossMgr.bulletsFired ? bossMgr.bulletsFired[idx] : 0;\n}\n\nfunction isAbilityReady(bossMgr, idx, abilityName) {\n  // Mock implementation - would check ability cooldowns\n  return Math.random() < 0.3;\n}\n\nfunction isStunned(bossMgr, idx) {\n  return bossMgr.stunned ? bossMgr.stunned[idx] : false;\n}\n\nfunction isInvulnerable(bossMgr, idx) {\n  return bossMgr.invulnerable ? bossMgr.invulnerable[idx] : false;\n}