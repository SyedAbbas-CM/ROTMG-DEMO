<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Map Editor ‚Äì Enhanced Multi‚Äëlayer with Zoom</title>
  <style>
    body{margin:0;display:flex;height:100vh;font-family:Arial,sans-serif;background:#222;color:#eee;overflow:hidden}
    #sidebar{width:340px;background:#111;padding:10px;overflow:auto;box-sizing:border-box}
    #sidebar h2{margin:0 0 10px 0}
    #sidebar input,#sidebar button,#sidebar select{width:100%;margin:4px 0;padding:4px;box-sizing:border-box}
    #sidebar label{display:block;margin:8px 0 4px 0;font-weight:bold}
    #sidebar hr{border:1px solid #333;margin:12px 0}
    
    .flex-row{display:flex;gap:4px;margin:4px 0}
    .flex-row > *{flex:1}
    .center-buttons{display:flex;gap:4px;justify-content:center;margin:8px 0}
    
    #canvasWrap{flex:1;display:flex;justify-content:center;align-items:center;background:#333;position:relative;overflow:auto}
    #mapCanvas{image-rendering:pixelated;border:2px solid #555;cursor:crosshair;display:block}

    /* Tile picker */
    #tilePicker{display:grid;grid-template-columns:repeat(auto-fill,32px);gap:4px;margin-top:6px;max-height:180px;overflow:auto}
    #tilePicker canvas{cursor:pointer;border:1px solid #333}
    #tilePicker canvas:hover{border-color:#666}

    /* Current tile display */
    #currentTileDisplay{width:64px;height:64px;border:2px solid #555;margin:8px auto;display:block;background:#000;image-rendering:pixelated}

    /* Enemy panel */
    #enemyPanel{position:absolute;right:10px;top:10px;width:240px;background:#111;padding:0;border:1px solid #444;border-radius:4px;user-select:none;box-shadow:0 0 8px #000;display:block}
    #enemyPanel.hidden{display:none}
    #enemyPanelHeader{cursor:move;background:#222;padding:8px;font-weight:bold;text-align:center;position:relative;border-radius:4px 4px 0 0}
    #enemyPanelClose{position:absolute;right:8px;top:50%;transform:translateY(-50%);cursor:pointer;color:#999;font-size:16px}
    #enemyPanelClose:hover{color:#fff}
    #enemyPanelContent{padding:8px}
    #enemyList{display:grid;grid-template-columns:repeat(auto-fill,36px);gap:4px;max-height:300px;overflow:auto}
    #enemyList canvas{cursor:pointer;border:1px solid #333}
    #enemyList canvas:hover{border-color:#666}
    #enemyList canvas.selected{border-color:#fff;border-width:2px}

    /* Layer controls */
    .layer-controls{display:flex;gap:4px;align-items:center}
    .layer-controls select{flex:1}
    .layer-controls button{width:32px;height:28px;padding:0}

    /* Rotation display */
    .rotation-display{text-align:center;margin:4px 0;font-size:12px;color:#aaa}

    /* Zoom controls */
    .zoom-controls{display:flex;gap:4px;align-items:center;justify-content:center;margin:8px 0}
    .zoom-display{font-size:12px;color:#aaa;min-width:50px;text-align:center}

    /* Status bar */
    #statusBar{position:absolute;bottom:10px;left:10px;background:rgba(0,0,0,0.7);padding:4px 8px;border-radius:4px;font-size:12px;pointer-events:none}

    /* Brush size indicator */
    .brush-controls{display:flex;gap:4px;align-items:center;margin:8px 0}
    .brush-size{width:40px}

    /* Layer visibility */
    .layer-item{display:flex;align-items:center;gap:4px;margin:2px 0}
    .layer-item input[type="checkbox"]{width:auto;margin:0}
    .layer-item label{margin:0;flex:1;font-weight:normal}

    /* Quick tools */
    .quick-tools{display:grid;grid-template-columns:1fr 1fr;gap:4px;margin:8px 0}
    .quick-tools button{margin:0}
  </style>
</head>
<body>
  <div id="sidebar">
    <h2>Map Editor</h2>
    
    <label>New Map Size</label>
    <div class="flex-row">
      <input id="mapW" type="number" value="32" min="4" placeholder="Width"/>
      <input id="mapH" type="number" value="32" min="4" placeholder="Height"/>
    </div>
    <button id="newMapBtn">New Map</button>

    <hr>

    <label>Layer Management</label>
    <div class="layer-controls">
      <select id="layerSelect"></select>
      <button id="addLayerBtn" title="Add Layer">Ôºã</button>
      <button id="delLayerBtn" title="Delete Layer">‚àí</button>
    </div>
    
    <div id="layerVisibility"></div>

    <label>Paint Mode</label>
    <select id="modeSelect">
      <option value="tile">Tile</option>
      <option value="enemy">Enemy</option>
      <option value="portal">Portal</option>
      <option value="spawn">Spawn Point</option>
    </select>

    <div class="layer-controls" style="margin-top:6px">
      <label style="margin:0;flex:unset">Live Mode</label>
      <input id="liveMode" type="checkbox" title="Apply changes live to server (admin protected)"/>
    </div>

    <label>Brush Size</label>
    <div class="brush-controls">
      <input id="brushSize" type="range" min="1" max="5" value="1" class="brush-size"/>
      <span id="brushSizeDisplay">1x1</span>
    </div>

    <hr>

    <label>View Controls</label>
    <div class="zoom-controls">
      <button id="zoomOut">‚àí</button>
      <div class="zoom-display"><span id="zoomDisplay">100%</span></div>
      <button id="zoomIn">+</button>
      <button id="resetView" title="Reset Zoom & Pan">‚åÇ</button>
    </div>

    <div class="quick-tools">
      <button id="fillTool" title="Flood Fill">ü™£</button>
      <button id="eyedropperTool" title="Eyedropper">üíß</button>
      <button id="clearLayer" title="Clear Current Layer">üóëÔ∏è</button>
      <button id="copyLayer" title="Duplicate Layer">üìã</button>
    </div>

    <button id="reloadEnemiesBtn" title="Reload enemy list from database">Reload Enemies</button>

    <hr>

    <label>Sprite Group</label>
    <select id="groupSelect"></select>
    
    <label>Current Selection</label>
    <canvas id="currentTileDisplay"></canvas>
    <div class="rotation-display">Rotation: <span id="rotDisplay">0¬∞</span></div>
    
    <div class="center-buttons">
      <button id="rotLeft" title="Rotate Left">‚ü≤</button>
      <button id="rotRight" title="Rotate Right">‚ü≥</button>
    </div>

    <label>Tile/Object Palette</label>
    <div id="tilePicker"></div>

    <hr>
    
    <label>Portal Destination Map ID</label>
    <input id="portalDestInput" type="text" placeholder="e.g. map_2" />

    <button id="saveMapBtn">Save Map (Ctrl+S)</button>
    <button id="saveActiveBtn" title="Persist live changes to server maps folder (Shift+Ctrl+S)">Save Active</button>
    <label>Existing Maps</label>
    <select id="mapList"></select>
    <button id="loadMapBtn">Load Selected Map</button>
    
    <hr>
    <button id="openSettingsBtn">Editor Settings</button>
    
    <hr>
    <div style="font-size:12px;color:#999">
      <strong>Controls:</strong><br>
      ‚Ä¢ Left click: Paint<br>
      ‚Ä¢ Right click: Erase<br>
      ‚Ä¢ Shift+Click+Drag: Draw rectangle<br>
      ‚Ä¢ Middle click: Pan<br>
      ‚Ä¢ Wheel: Zoom<br>
      ‚Ä¢ R: Rotate selection<br>
      ‚Ä¢ Shift+E: Toggle enemy panel<br>
      ‚Ä¢ Space: Eyedropper mode<br>
      ‚Ä¢ Ctrl+Z: Undo<br>
      ‚Ä¢ Ctrl+Y: Redo
    </div>
  </div>

  <div id="canvasWrap">
    <canvas id="mapCanvas" width="640" height="640"></canvas>
    <div id="statusBar">Ready</div>

    <!-- Enemy/Entity Panel -->
    <div id="enemyPanel">
      <div id="enemyPanelHeader">
        Entity Panel
        <span id="enemyPanelClose">‚úï</span>
      </div>
      <div id="enemyPanelContent">
        <div id="enemyList"></div>
      </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" style="display:none;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:#111;border:1px solid #444;border-radius:4px;box-shadow:0 0 10px #000;width:360px;z-index:1000">
      <div style="padding:10px;border-bottom:1px solid #333;font-weight:bold">Editor Settings</div>
      <div style="padding:10px;display:flex;flex-direction:column;gap:6px">
        <label>Admin Token</label>
        <input id="adminTokenInput" type="password" placeholder="x-admin-token"/>
        <label>Current Map ID</label>
        <input id="currentMapIdInput" type="text" placeholder="default"/>
        <div style="display:flex;gap:6px;justify-content:flex-end;margin-top:8px">
          <button id="settingsCancelBtn">Cancel</button>
          <button id="settingsSaveBtn">Save</button>
        </div>
      </div>
    </div>

    <!-- Unsaved Live Changes Banner -->
    <div id="unsavedBanner" style="position:absolute;top:10px;left:50%;transform:translateX(-50%);background:rgba(255,165,0,0.9);color:#111;padding:6px 10px;border-radius:4px;display:none;z-index:999">Live changes pending save</div>
  </div>

  <script type="module">
    import { spriteDatabase } from '../src/assets/SpriteDatabase.js';
    import { entityDatabase } from '../src/assets/EntityDatabase.js';

    // ============= DOM REFERENCES =============
    const tilePicker = document.getElementById('tilePicker');
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');
    const layerSelect = document.getElementById('layerSelect');
    const layerVisibility = document.getElementById('layerVisibility');
    const modeSelect = document.getElementById('modeSelect');
    const groupSelect = document.getElementById('groupSelect');
    const enemyPanel = document.getElementById('enemyPanel');
    const enemyHeader = document.getElementById('enemyPanelHeader');
    const enemyClose = document.getElementById('enemyPanelClose');
    const enemyListDiv = document.getElementById('enemyList');
    let lastMousePos = null;
    const reloadEnemiesBtn = document.getElementById('reloadEnemiesBtn');
    const currentTileDisplay = document.getElementById('currentTileDisplay');
    const rotDisplay = document.getElementById('rotDisplay');
    const addLayerBtn = document.getElementById('addLayerBtn');
    const delLayerBtn = document.getElementById('delLayerBtn');
    const rotLeftBtn = document.getElementById('rotLeft');
    const rotRightBtn = document.getElementById('rotRight');
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    const resetViewBtn = document.getElementById('resetView');
    const zoomDisplay = document.getElementById('zoomDisplay');
    const statusBar = document.getElementById('statusBar');
    const brushSizeSlider = document.getElementById('brushSize');
    const brushSizeDisplay = document.getElementById('brushSizeDisplay');
    const portalDestInput = document.getElementById('portalDestInput');
    const liveModeCheckbox = document.getElementById('liveMode');
    const openSettingsBtn = document.getElementById('openSettingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const adminTokenInput = document.getElementById('adminTokenInput');
    const currentMapIdInput = document.getElementById('currentMapIdInput');
    const settingsSaveBtn = document.getElementById('settingsSaveBtn');
    const settingsCancelBtn = document.getElementById('settingsCancelBtn');
    const unsavedBanner = document.getElementById('unsavedBanner');

    // Settings state
    let currentLoadedMapId = localStorage.getItem('CURRENT_MAP_ID') || 'default';
    const ADMIN_TOKEN = localStorage.getItem('ADMIN_TOKEN') || '';

    // Populate modal with stored values
    function openSettings(){
      adminTokenInput.value = localStorage.getItem('ADMIN_TOKEN') || '';
      currentMapIdInput.value = localStorage.getItem('CURRENT_MAP_ID') || currentLoadedMapId || 'default';
      settingsModal.style.display = 'block';
    }
    function closeSettings(){ settingsModal.style.display = 'none'; }

    openSettingsBtn.onclick = openSettings;
    settingsCancelBtn.onclick = closeSettings;
    settingsSaveBtn.onclick = ()=>{
      localStorage.setItem('ADMIN_TOKEN', adminTokenInput.value || '');
      currentLoadedMapId = (currentMapIdInput.value || 'default').trim();
      localStorage.setItem('CURRENT_MAP_ID', currentLoadedMapId);
      closeSettings();
      updateStatus('Settings saved');
    };

    // Track unsaved live changes when live mode is on
    let liveDirty = false;
    function markLiveDirty(){ if (liveModeCheckbox?.checked) { liveDirty = true; unsavedBanner.style.display = 'block'; } }
    async function saveActive(){
      try {
        const resp = await fetch('/api/maps/save-active', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'x-admin-token': (localStorage.getItem('ADMIN_TOKEN')||'') },
          body: JSON.stringify({ mapId: currentLoadedMapId })
        });
        const js = await resp.json();
        if (js.ok) {
          liveDirty = false;
          unsavedBanner.style.display = 'none';
          updateStatus(`Saved active map to ${js.file}`);
        } else {
          updateStatus('Save active failed');
        }
      } catch { updateStatus('Save active failed'); }
    }

    // Attach save active via shift+Ctrl+S
    document.addEventListener('keydown', (e)=>{
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase()==='s'){
        e.preventDefault();
        saveActive();
      }
    });

    // When we do live operations, mark dirty
    // Hook into existing live calls by wrapping fetch
    const _fetch = window.fetch.bind(window);
    window.fetch = async (...args)=>{
      const res = await _fetch(...args);
      try {
        const url = String(args[0]||'');
        if (url.includes('/api/portals/') || url.includes('/api/enemies/') || url.includes('/api/maps/entrypoints')){
          markLiveDirty();
        }
      } catch {}
      return res;
    };

    // ============= UNIFIED DATA MODEL =============
    let tileW = 16, tileH = 16;
    let mapW = 32, mapH = 32;

    // Unified structure: layers[] + entities[]
    let layers = [];   // [{name: string, grid: cell[][], visible: bool}, ...] where cell = {sprite, rot} or null
    let entities = []; // [{type: 'enemy'|'portal'|'spawn', x, y, sprite, rot, destMap?}, ...]

    let currentTile = null;
    let currentEnemyId = null;
    let currentPortalDest = '';
    let currentRot = 0;
    let currentLayer = 0;
    let brushSize = 1;
    let isMouseDown = false;
    let isPanning = false;
    let isEyedropping = false;

    // Camera/zoom system
    let camera = { x: 0, y: 0, zoom: 1 };
    const zoomLevels = [0.25, 0.5, 0.75, 1, 1.5, 2, 3, 4, 6, 8];
    let zoomIndex = 3; // Start at 100%

    // Drawing modes
    let isDragDrawing = false;
    let dragStart = null;
    let dragEnd = null;

    // Undo/Redo system
    let undoStack = [];
    let redoStack = [];
    const maxUndoSteps = 50;

    // ============= LOCAL STORAGE PERSISTENCE =============
    const STORAGE_PREFIX = 'mapEditor_';
    const CURRENT_MAP_KEY = 'mapEditor_currentMap';
    let currentMapName = 'untitled';
    let autoSaveTimer = null;

    // Save current map to localStorage
    function saveToLocalStorage() {
      const mapData = {
        name: currentMapName,
        width: mapW,
        height: mapH,
        tileW: tileW,
        tileH: tileH,
        layers: layers,
        entities: entities,
        lastModified: Date.now()
      };

      try {
        localStorage.setItem(STORAGE_PREFIX + currentMapName, JSON.stringify(mapData));
        localStorage.setItem(CURRENT_MAP_KEY, currentMapName);
        updateStatus(`Auto-saved to localStorage: ${currentMapName}`);
      } catch (e) {
        console.error('localStorage save failed:', e);
        updateStatus('Warning: localStorage full - maps not saved locally');
      }
    }

    // Debounced auto-save (saves 1 second after last edit)
    function scheduleAutoSave() {
      if (autoSaveTimer) clearTimeout(autoSaveTimer);
      autoSaveTimer = setTimeout(() => {
        saveToLocalStorage();
      }, 1000);
    }

    // Load map from localStorage
    function loadFromLocalStorage(mapName) {
      try {
        const data = localStorage.getItem(STORAGE_PREFIX + mapName);
        if (!data) {
          updateStatus(`Map "${mapName}" not found in localStorage`);
          return false;
        }

        const mapData = JSON.parse(data);

        // Apply map data
        currentMapName = mapData.name || mapName;
        mapW = mapData.width || 32;
        mapH = mapData.height || 32;
        tileW = mapData.tileW || 16;
        tileH = mapData.tileH || 16;
        layers = mapData.layers || [{ name: 'ground', grid: createEmptyGrid(), visible: true }];
        entities = mapData.entities || [];

        canvas.width = mapW * tileW;
        canvas.height = mapH * tileH;
        updateCanvasSize();
        drawMap();

        updateStatus(`Loaded from localStorage: ${currentMapName}`);
        return true;
      } catch (e) {
        console.error('localStorage load failed:', e);
        updateStatus('Failed to load from localStorage');
        return false;
      }
    }

    // List all maps in localStorage
    function listLocalMaps() {
      const maps = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith(STORAGE_PREFIX) && key !== CURRENT_MAP_KEY) {
          const mapName = key.substring(STORAGE_PREFIX.length);
          try {
            const data = JSON.parse(localStorage.getItem(key));
            maps.push({
              name: mapName,
              lastModified: data.lastModified || 0,
              source: 'local'
            });
          } catch (e) {
            console.error('Error parsing map:', key, e);
          }
        }
      }
      return maps.sort((a, b) => b.lastModified - a.lastModified);
    }

    // Delete map from localStorage
    function deleteFromLocalStorage(mapName) {
      try {
        localStorage.removeItem(STORAGE_PREFIX + mapName);
        updateStatus(`Deleted from localStorage: ${mapName}`);
        return true;
      } catch (e) {
        console.error('localStorage delete failed:', e);
        return false;
      }
    }

    // Load last edited map on startup
    function loadLastMap() {
      const lastMap = localStorage.getItem(CURRENT_MAP_KEY);
      if (lastMap) {
        return loadFromLocalStorage(lastMap);
      }
      return false;
    }

    // ============= INITIALIZATION =============
    async function init() {
      try {
        // Load sprite atlases - try API first, fallback to hardcoded list
        let atlasPaths = [];
        try {
          const atlRes = await fetch('/api/assets/atlases');
          if (!atlRes.ok) throw new Error('API unavailable');
          const atlJson = await atlRes.json();
          atlasPaths = atlJson.atlases || [];
        } catch (e) {
          console.warn('[MapEditor] API unavailable, using fallback atlas list');
          // Fallback: hardcoded atlas paths for local development
          atlasPaths = [
            '/assets/atlases/chars.json',
            '/assets/atlases/chars2.json',
            '/assets/atlases/tiles.json',
            '/assets/atlases/tiles2.json',
            '/assets/atlases/lofi_obj.json',
            '/assets/atlases/lofi_environment.json',
            '/assets/atlases/Mixed_Units.json'
          ];
        }
        if (!atlasPaths.length) {
          alert('No atlases found');
          return;
        }
        await spriteDatabase.loadAtlases(atlasPaths.map(p => p.startsWith('/') ? p : '/' + p));
        
        // Load entity database
        await entityDatabase.load();

        // Setup UI
        populateGroupSelect();
        buildEnemyList();
        updateTilePicker();
        await refreshMapList();
        newMap();

        // Try to load last edited map from localStorage
        const loaded = loadLastMap();
        if (loaded) {
          updateStatus('Restored last edited map from localStorage');
        }

        setupEventListeners();
        enableEnemyPanelDrag();
        
        // Restore editor session
        try {
          const savedGroup = localStorage.getItem('EDITOR_GROUP');
          if (savedGroup && Array.from(groupSelect.options).some(o=>o.value===savedGroup)) groupSelect.value = savedGroup;
          const savedLayer = +localStorage.getItem('EDITOR_LAYER_INDEX');
          if (!Number.isNaN(savedLayer) && savedLayer>=0) currentLayer = savedLayer;
          const savedZoomIndex = +localStorage.getItem('EDITOR_ZOOM_INDEX');
          if (!Number.isNaN(savedZoomIndex) && savedZoomIndex>=0 && savedZoomIndex<zoomLevels.length) { zoomIndex = savedZoomIndex; camera.zoom = zoomLevels[zoomIndex]; }
          const savedBrush = +localStorage.getItem('EDITOR_BRUSH');
          if (!Number.isNaN(savedBrush) && savedBrush>=1 && savedBrush<=5) { brushSize = savedBrush; brushSizeSlider.value = brushSize; }
          if (liveModeCheckbox) liveModeCheckbox.checked = localStorage.getItem('EDITOR_LIVE')==='1';
        } catch {}

        // Set initial displays
        updateCurrentTileDisplay();
        updateRotationDisplay();
        updateZoomDisplay();
        updateBrushSizeDisplay();
        updateStatus('Editor loaded successfully');
        
      } catch (error) {
        console.error('Initialization failed:', error);
        alert('Failed to initialize editor: ' + error.message);
      }
    }

    // ============= UNDO/REDO SYSTEM =============
    function saveState() {
      const state = {
        layers: JSON.parse(JSON.stringify(layers)),
        entities: JSON.parse(JSON.stringify(entities))
      };
      undoStack.push(state);
      if (undoStack.length > maxUndoSteps) {
        undoStack.shift();
      }
      redoStack = []; // Clear redo stack when new action is performed
    }

    function undo() {
      if (undoStack.length === 0) return;
      
      // Save current state to redo stack
      const currentState = {
        layers: JSON.parse(JSON.stringify(layers)),
        entities: JSON.parse(JSON.stringify(entities))
      };
      redoStack.push(currentState);
      
      // Restore previous state
      const previousState = undoStack.pop();
      layers = previousState.layers;
      entities = previousState.entities;
      
      buildLayerSelect();
      buildLayerVisibility();
      drawMap();
      updateStatus('Undid last action');
    }

    function redo() {
      if (redoStack.length === 0) return;
      
      // Save current state to undo stack
      saveState();
      
      // Restore next state
      const nextState = redoStack.pop();
      layers = nextState.layers;
      entities = nextState.entities;
      
      buildLayerSelect();
      buildLayerVisibility();
      drawMap();
      updateStatus('Redid last action');
    }

    // ============= UI BUILDERS =============
    function populateGroupSelect() {
      groupSelect.innerHTML = '';
      const allOption = new Option('(all)', 'all');
      groupSelect.appendChild(allOption);
      
      spriteDatabase.getAllGroupNames().forEach(groupName => {
        groupSelect.appendChild(new Option(groupName, groupName));
      });
      
      groupSelect.onchange = (e)=>{ updateTilePicker(); localStorage.setItem('EDITOR_GROUP', e.target.value||'all'); };
      const savedGroup = localStorage.getItem('EDITOR_GROUP');
      if (savedGroup && Array.from(groupSelect.options).some(o=>o.value===savedGroup)) {
        groupSelect.value = savedGroup;
      }
    }

    function buildLayerSelect() {
      layerSelect.innerHTML = '';
      layers.forEach((layer, index) => {
        const option = new Option(`${index}: ${layer.name}`, index);
        layerSelect.appendChild(option);
      });
      layerSelect.value = currentLayer;
      const savedLayer = +localStorage.getItem('EDITOR_LAYER_INDEX');
      if (!Number.isNaN(savedLayer) && savedLayer >=0 && savedLayer < layers.length){ currentLayer = savedLayer; layerSelect.value = currentLayer; }
    }

    function buildLayerVisibility() {
      layerVisibility.innerHTML = '';
      layers.forEach((layer, index) => {
        const div = document.createElement('div');
        div.className = 'layer-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = layer.visible !== false; // Default to visible
        checkbox.onchange = () => {
          layer.visible = checkbox.checked;
          drawMap();
        };
        
        const label = document.createElement('label');
        label.textContent = `${index}: ${layer.name}`;
        label.style.fontSize = '12px';
        
        div.appendChild(checkbox);
        div.appendChild(label);
        layerVisibility.appendChild(div);
      });
    }

    function buildEnemyList() {
      enemyListDiv.innerHTML = '';
      const enemyDefs = entityDatabase.getAll('enemies');
      const minSlots = 3;
      const total = Math.max(enemyDefs.length, minSlots);
      
      for (let idx = 0; idx < total; idx++) {
        const enemyDef = enemyDefs[idx];
        const thumb = document.createElement('canvas');
        thumb.width = 36;
        thumb.height = 36;
        thumb.style.cursor = 'pointer';
        
        const thumbCtx = thumb.getContext('2d');
        if (enemyDef && enemyDef.sprite && spriteDatabase.hasSprite(enemyDef.sprite)) {
          spriteDatabase.drawSprite(thumbCtx, enemyDef.sprite, 2, 2, 32, 32);
          thumb.title = `${enemyDef.id || '?'}: ${enemyDef.name || enemyDef.sprite || ''}`;
          thumb.onclick = () => {
            enemyListDiv.querySelectorAll('canvas').forEach(c => c.classList.remove('selected'));
            thumb.classList.add('selected');
            currentTile = enemyDef.sprite;
            currentEnemyId = enemyDef.id || null;
            currentRot = 0;
            modeSelect.value = 'enemy';
            updateCurrentTileDisplay();
            updateRotationDisplay();
          };
        } else {
          // Placeholder slot with simple sprite box
          thumbCtx.fillStyle = '#333';
          thumbCtx.fillRect(2, 2, 32, 32);
          thumbCtx.fillStyle = '#666';
          thumbCtx.fillRect(10, 10, 16, 16);
          thumb.title = 'Empty Slot';
        }
        enemyListDiv.appendChild(thumb);
      }
    }

    function updateTilePicker() {
      const selectedGroup = groupSelect.value;
      const spriteNames = selectedGroup && selectedGroup !== 'all' 
        ? spriteDatabase.getGroup(selectedGroup).map(s => s.name)
        : spriteDatabase.getAllSpriteNames();
      
      tilePicker.innerHTML = '';
      
      spriteNames.forEach(spriteName => {
        const tile = document.createElement('canvas');
        tile.width = 32;
        tile.height = 32;
        tile.style.cursor = 'pointer';
        
        const tileCtx = tile.getContext('2d');
        spriteDatabase.drawSprite(tileCtx, spriteName, 0, 0, 32, 32);
        
        tile.title = spriteName;
        tile.onclick = () => {
          currentTile = spriteName;
          currentRot = 0;
          modeSelect.value = 'tile';
          highlightTile(tile);
          updateCurrentTileDisplay();
          updateRotationDisplay();
          
          enemyListDiv.querySelectorAll('canvas').forEach(c => c.classList.remove('selected'));
        };
        
        tilePicker.appendChild(tile);
      });
    }

    function highlightTile(selectedElement) {
      tilePicker.querySelectorAll('canvas').forEach(canvas => {
        canvas.style.outline = '';
      });
      if (selectedElement) {
        selectedElement.style.outline = '2px solid #fff';
      }
    }

    function updateCurrentTileDisplay() {
      const displayCtx = currentTileDisplay.getContext('2d');
      displayCtx.fillStyle = '#000';
      displayCtx.fillRect(0, 0, 64, 64);
      
      if (currentTile) {
        displayCtx.save();
        displayCtx.translate(32, 32);
        displayCtx.rotate(currentRot * Math.PI / 2);
        // Draw larger, clearer sprite
        spriteDatabase.drawSprite(displayCtx, currentTile, -28, -28, 56, 56);
        displayCtx.restore();
      }
    }

    function updateRotationDisplay() {
      rotDisplay.textContent = (currentRot * 90) + '¬∞';
    }

    function updateZoomDisplay() {
      zoomDisplay.textContent = Math.round(camera.zoom * 100) + '%';
    }

    function persistCamera(){
      localStorage.setItem('EDITOR_ZOOM_INDEX', String(zoomIndex));
    }

    function updateBrushSizeDisplay() {
      brushSizeDisplay.textContent = `${brushSize}x${brushSize}`;
    }

    // Keep current portal destination in sync with input
    if (portalDestInput) {
      portalDestInput.addEventListener('input', () => {
        currentPortalDest = portalDestInput.value.trim();
      });
    }

    function updateStatus(message) {
      statusBar.textContent = message;
      setTimeout(() => {
        statusBar.textContent = `Zoom: ${Math.round(camera.zoom * 100)}% | Layer: ${currentLayer} | Mode: ${modeSelect.value}`;
      }, 2000);
    }

    // ============= MAP OPERATIONS =============
    function newMap() {
      mapW = +document.getElementById('mapW').value || 32;
      mapH = +document.getElementById('mapH').value || 32;
      
      // Set canvas to actual pixel size for the map
      const pixelWidth = mapW * tileW;
      const pixelHeight = mapH * tileH;
      
      canvas.width = pixelWidth;
      canvas.height = pixelHeight;
      
      // Set CSS size based on zoom to avoid the scaling issue
      updateCanvasSize();
      
      // Initialize with default layers
      layers = [
        { name: 'ground', grid: createEmptyGrid(), visible: true },
        { name: 'objects', grid: createEmptyGrid(), visible: true },
        { name: 'decor', grid: createEmptyGrid(), visible: true }
      ];
      
      entities = [];
      currentLayer = 0;
      
      // Reset camera
      camera = { x: 0, y: 0, zoom: 1 };
      zoomIndex = 3;
      
      // Clear undo/redo
      undoStack = [];
      redoStack = [];
      
      buildLayerSelect();
      buildLayerVisibility();
      updateZoomDisplay();
      drawMap();
      updateStatus('New map created');
    }

    function updateCanvasSize() {
      const pixelWidth = mapW * tileW;
      const pixelHeight = mapH * tileH;
      
      canvas.style.width = (pixelWidth * camera.zoom) + 'px';
      canvas.style.height = (pixelHeight * camera.zoom) + 'px';
    }

    function createEmptyGrid() {
      return Array.from({ length: mapH }, () => Array(mapW).fill(null));
    }

    function addLayer() {
      const layerName = prompt('Layer name:', `layer_${layers.length}`);
      if (layerName) {
        saveState();
        layers.push({
          name: layerName,
          grid: createEmptyGrid(),
          visible: true
        });
        buildLayerSelect();
        buildLayerVisibility();
        currentLayer = layers.length - 1;
        layerSelect.value = currentLayer;
        updateStatus(`Added layer: ${layerName}`);
        scheduleAutoSave();
      }
    }

    function deleteLayer() {
      if (layers.length <= 1) {
        alert('Cannot delete the last layer');
        return;
      }
      
      const layerName = layers[currentLayer].name;
      if (confirm(`Delete layer "${layerName}"?`)) {
        saveState();
        layers.splice(currentLayer, 1);
        if (currentLayer >= layers.length) {
          currentLayer = layers.length - 1;
        }
        buildLayerSelect();
        buildLayerVisibility();
        drawMap();
        updateStatus(`Deleted layer: ${layerName}`);
        scheduleAutoSave();
      }
    }

    function clearCurrentLayer() {
      if (confirm(`Clear all tiles from layer "${layers[currentLayer].name}"?`)) {
        saveState();
        layers[currentLayer].grid = createEmptyGrid();
        drawMap();
        updateStatus('Layer cleared');
        scheduleAutoSave();
      }
    }

    function copyCurrentLayer() {
      const layerName = prompt('Name for copied layer:', `${layers[currentLayer].name}_copy`);
      if (layerName) {
        saveState();
        const copiedGrid = JSON.parse(JSON.stringify(layers[currentLayer].grid));
        layers.push({
          name: layerName,
          grid: copiedGrid,
          visible: true
        });
        buildLayerSelect();
        buildLayerVisibility();
        currentLayer = layers.length - 1;
        layerSelect.value = currentLayer;
        updateStatus(`Copied layer: ${layerName}`);
        scheduleAutoSave();
      }
    }

    async function refreshMapList() {
      const mapListSelect = document.getElementById('mapList');
      mapListSelect.innerHTML = '';
      const addedMaps = new Set();

      // Try server API first
      try {
        const response = await fetch('/api/map-editor/maps');
        if (!response.ok) throw new Error('API unavailable');
        const data = await response.json();
        data.maps.forEach(mapName => {
          if (!addedMaps.has(mapName)) {
            mapListSelect.appendChild(new Option(mapName, mapName));
            addedMaps.add(mapName);
          }
        });
      } catch (error) {
        console.warn('[MapEditor] Map list API unavailable, using fallback');
        // Fallback: try to load known maps directly
        const knownMaps = ['test.json', 'StartingArea.json', 'RiverBridge.json', 'SampleBossRoom.json', 'SampleNexus.json'];
        for (const mapName of knownMaps) {
          try {
            const res = await fetch(`/maps/${mapName}`);
            if (res.ok && !addedMaps.has(mapName)) {
              mapListSelect.appendChild(new Option(mapName, mapName));
              addedMaps.add(mapName);
            }
          } catch {}
        }
      }

      // Also add maps from localStorage
      try {
        const savedMaps = JSON.parse(localStorage.getItem('MAP_LIST') || '[]');
        savedMaps.forEach(mapName => {
          // Skip invalid entries (not strings or empty)
          if (typeof mapName !== 'string' || !mapName) return;
          if (!addedMaps.has(mapName)) {
            mapListSelect.appendChild(new Option(`${mapName} (local)`, `local:${mapName}`));
            addedMaps.add(mapName);
          }
        });
      } catch (e) {
        // Clear corrupted localStorage
        console.warn('[MapEditor] Clearing corrupted MAP_LIST');
        localStorage.removeItem('MAP_LIST');
      }

      if (mapListSelect.options.length === 0) {
        console.log('[MapEditor] No maps found, starting fresh');
      }
    }

    // ============= ZOOM & CAMERA =============
    function zoomIn() {
      if (zoomIndex < zoomLevels.length - 1) {
        zoomIndex++;
        camera.zoom = zoomLevels[zoomIndex];
        updateZoomDisplay();
        updateCanvasSize();
        drawMap();
        updateStatus(`Zoomed to ${Math.round(camera.zoom * 100)}%`);
      }
    }

    function zoomOut() {
      if (zoomIndex > 0) {
        zoomIndex--;
        camera.zoom = zoomLevels[zoomIndex];
        updateZoomDisplay();
        updateCanvasSize();
        drawMap();
        updateStatus(`Zoomed to ${Math.round(camera.zoom * 100)}%`);
      }
    }

    function resetView() {
      camera = { x: 0, y: 0, zoom: 1 };
      zoomIndex = 3;
      updateZoomDisplay();
      updateCanvasSize();
      drawMap();
      updateStatus('View reset');
    }

    // ============= CANVAS HELPERS =============
    function screenToWorld(screenX, screenY) {
      const rect = canvas.getBoundingClientRect();
      const canvasX = screenX - rect.left;
      const canvasY = screenY - rect.top;
      
      // Convert to world coordinates - much simpler now
      const worldX = canvasX / camera.zoom;
      const worldY = canvasY / camera.zoom;
      
      return { x: worldX, y: worldY };
    }

    function eventToTile(event) {
      const world = screenToWorld(event.clientX, event.clientY);
      const x = Math.floor(world.x / tileW);
      const y = Math.floor(world.y / tileH);
      return (x >= 0 && y >= 0 && x < mapW && y < mapH) ? { x, y } : null;
    }

    function paint(x, y, isErase = false) {
      const mode = modeSelect.value;
      
      // Paint brush area
      const halfBrush = Math.floor(brushSize / 2);
      for (let dy = -halfBrush; dy <= halfBrush; dy++) {
        for (let dx = -halfBrush; dx <= halfBrush; dx++) {
          const paintX = x + dx;
          const paintY = y + dy;
          
          if (paintX < 0 || paintY < 0 || paintX >= mapW || paintY >= mapH) continue;
          
          if (mode === 'tile') {
            if (currentLayer < layers.length && layers[currentLayer]) {
              // Ensure grid exists and has the right dimensions
              if (!layers[currentLayer].grid || layers[currentLayer].grid.length !== mapH) {
                layers[currentLayer].grid = createEmptyGrid();
              }
              if (!layers[currentLayer].grid[paintY]) {
                layers[currentLayer].grid[paintY] = Array(mapW).fill(null);
              }
              
              layers[currentLayer].grid[paintY][paintX] = isErase ? null : {
                sprite: currentTile,
                rot: currentRot
              };
            }
          } else if (mode === 'enemy') {
            // Remove any existing entity at this position
            entities = entities.filter(entity => !(entity.x === paintX && entity.y === paintY));
            
            // Add new entity if not erasing
            if (!isErase && currentTile) {
              entities.push({
                type: 'enemy',
                x: paintX,
                y: paintY,
                sprite: currentTile,
                id: currentEnemyId,
                rot: currentRot
              });
            }
          } else if (mode === 'portal') {
            // Remove any existing portal at this position
            entities = entities.filter(entity => !(entity.x === paintX && entity.y === paintY && entity.type === 'portal'));
            // Add portal if not erasing
            if (!isErase) {
              const dest = (portalDestInput?.value || currentPortalDest || '').trim();
              entities.push({
                type: 'portal',
                x: paintX,
                y: paintY,
                sprite: 'portal',
                rot: 0,
                destMap: dest
              });
              if (liveModeCheckbox?.checked && dest) {
                fetch('/api/portals/add', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json', 'x-admin-token': ADMIN_TOKEN },
                  body: JSON.stringify({ mapId: currentLoadedMapId || 'default', x: paintX, y: paintY, destMap: dest })
                }).catch(()=>{});
              }
            }
          } else if (mode === 'spawn') {
            // Ensure only one spawn exists; clear previous
            entities = entities.filter(entity => entity.type !== 'spawn');
            if (!isErase) {
              entities.push({
                type: 'spawn',
                x: paintX,
                y: paintY,
                sprite: 'spawn_point',
                rot: 0
              });
              if (liveModeCheckbox?.checked) {
                fetch('/api/maps/entrypoints/set', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json', 'x-admin-token': ADMIN_TOKEN },
                  body: JSON.stringify({ mapId: currentLoadedMapId || 'default', points: [{ x: paintX, y: paintY }] })
                }).catch(()=>{});
              }
            }
          }
        }
      }

      // Auto-save after paint operation
      scheduleAutoSave();
    }

    function paintRectangle(startX, startY, endX, endY, isErase = false) {
      const mode = modeSelect.value;
      
      const minX = Math.min(startX, endX);
      const maxX = Math.max(startX, endX);
      const minY = Math.min(startY, endY);
      const maxY = Math.max(startY, endY);
      
      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          if (x < 0 || y < 0 || x >= mapW || y >= mapH) continue;
          
          if (mode === 'tile') {
            if (currentLayer < layers.length && layers[currentLayer]) {
              if (!layers[currentLayer].grid || layers[currentLayer].grid.length !== mapH) {
                layers[currentLayer].grid = createEmptyGrid();
              }
              if (!layers[currentLayer].grid[y]) {
                layers[currentLayer].grid[y] = Array(mapW).fill(null);
              }
              
              layers[currentLayer].grid[y][x] = isErase ? null : {
                sprite: currentTile,
                rot: currentRot
              };
            }
          } else if (mode === 'enemy') {
            entities = entities.filter(entity => !(entity.x === x && entity.y === y));
            
            if (!isErase && currentTile) {
              entities.push({
                type: 'enemy',
                x: x,
                y: y,
                sprite: currentTile,
                id: currentEnemyId,
                rot: currentRot
              });
              if (liveModeCheckbox?.checked) {
                const payload = currentEnemyId != null ? { mapId: currentLoadedMapId || 'default', id: currentEnemyId, x, y } : { mapId: currentLoadedMapId || 'default', type: 0, x, y };
                fetch('/api/enemies/spawn', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json', 'x-admin-token': ADMIN_TOKEN },
                  body: JSON.stringify(payload)
                }).catch(()=>{});
              }
            }
          } else if (mode === 'portal') {
            entities = entities.filter(entity => !(entity.x === x && entity.y === y && entity.type === 'portal'));
            if (!isErase) {
              const dest = (portalDestInput?.value || currentPortalDest || '').trim();
              entities.push({
                type: 'portal',
                x: x,
                y: y,
                sprite: 'portal',
                rot: 0,
                destMap: dest
              });
              if (liveModeCheckbox?.checked && dest) {
                fetch('/api/portals/add', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json', 'x-admin-token': ADMIN_TOKEN },
                  body: JSON.stringify({ mapId: currentLoadedMapId || 'default', x, y, destMap: dest })
                }).catch(()=>{});
              }
            }
          } else if (mode === 'spawn') {
            // Rectangle paint for spawn acts like single set: pick top-left
            // Clear previous and set one at minX/minY done later; for simplicity, set at current x,y
            entities = entities.filter(entity => entity.type !== 'spawn');
            if (!isErase) {
              entities.push({ type:'spawn', x:x, y:y, sprite: 'spawn_point', rot:0 });
              if (liveModeCheckbox?.checked) {
                fetch('/api/maps/entrypoints/set', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json', 'x-admin-token': ADMIN_TOKEN },
                  body: JSON.stringify({ mapId: currentLoadedMapId || 'default', points: [{ x, y }] })
                }).catch(()=>{});
              }
            }
          }
        }
      }

      // Auto-save after rectangle paint operation
      scheduleAutoSave();
    }

    function eyedrop(x, y) {
      const mode = modeSelect.value;
      
      if (mode === 'tile') {
        if (currentLayer < layers.length && layers[currentLayer].grid[y] && layers[currentLayer].grid[y][x]) {
          const cell = layers[currentLayer].grid[y][x];
          if (cell) {
            currentTile = cell.sprite;
            currentRot = cell.rot || 0;
            updateCurrentTileDisplay();
            updateRotationDisplay();
            updateStatus(`Picked up: ${cell.sprite}`);
          }
        }
      } else if (mode === 'enemy') {
        const entity = entities.find(e => e.x === x && e.y === y);
        if (entity) {
          currentTile = entity.sprite;
          currentRot = entity.rot || 0;
          updateCurrentTileDisplay();
          updateRotationDisplay();
          updateStatus(`Picked up: ${entity.sprite}`);
        }
      } else if (mode === 'portal') {
        const entity = entities.find(e => e.type === 'portal' && e.x === x && e.y === y);
        if (entity) {
          currentPortalDest = entity.destMap || '';
          if (portalDestInput) portalDestInput.value = currentPortalDest;
          updateStatus(`Picked up portal ‚Üí ${currentPortalDest || '(unset)'}`);
        }
      }
    }

    function floodFill(startX, startY) {
      if (!currentTile || modeSelect.value !== 'tile') return;
      
      const targetCell = layers[currentLayer].grid[startY][startX];
      const targetSprite = targetCell ? targetCell.sprite : null;
      const newCell = { sprite: currentTile, rot: currentRot };
      
      if (targetSprite === currentTile) return; // Nothing to fill
      
      saveState();
      
      const stack = [{x: startX, y: startY}];
      const visited = new Set();
      
      while (stack.length > 0) {
        const {x, y} = stack.pop();
        const key = `${x},${y}`;
        
        if (visited.has(key) || x < 0 || y < 0 || x >= mapW || y >= mapH) continue;
        
        const currentCell = layers[currentLayer].grid[y][x];
        const currentSprite = currentCell ? currentCell.sprite : null;
        
        if (currentSprite !== targetSprite) continue;
        
        visited.add(key);
        layers[currentLayer].grid[y][x] = newCell;
        
        // Add neighbors
        stack.push({x: x+1, y}, {x: x-1, y}, {x, y: y+1}, {x, y: y-1});
      }
      
      drawMap();
      updateStatus('Flood fill completed');
    }

    // ============= CANVAS EVENTS =============
    function setupEventListeners() {
      // Canvas events
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseup', handleMouseUp);
      canvas.addEventListener('contextmenu', e => e.preventDefault());
      canvas.addEventListener('wheel', handleWheel, { passive: false });

      // UI events
      document.getElementById('newMapBtn').onclick = newMap;
      document.getElementById('saveMapBtn').onclick = saveMap;
      document.getElementById('loadMapBtn').onclick = loadMap;
      document.getElementById('saveActiveBtn').onclick = (e)=>{ e.preventDefault(); saveActive(); };
      
      layerSelect.onchange = e => {
        currentLayer = +e.target.value;
        localStorage.setItem('EDITOR_LAYER_INDEX', String(currentLayer));
        updateStatus(`Switched to layer ${currentLayer}`);
      };
      
      addLayerBtn.onclick = addLayer;
      delLayerBtn.onclick = deleteLayer;
      
      rotLeftBtn.onclick = () => {
        currentRot = (currentRot + 3) % 4;
        updateCurrentTileDisplay();
        updateRotationDisplay();
      };
      
      rotRightBtn.onclick = () => {
        currentRot = (currentRot + 1) % 4;
        updateCurrentTileDisplay();
        updateRotationDisplay();
      };

      // Zoom controls
      zoomInBtn.onclick = ()=>{ zoomIn(); persistCamera(); };
      zoomOutBtn.onclick = ()=>{ zoomOut(); persistCamera(); };
      resetViewBtn.onclick = ()=>{ resetView(); persistCamera(); };

      // Brush size
      brushSizeSlider.oninput = e => {
        brushSize = +e.target.value;
        updateBrushSizeDisplay();
        localStorage.setItem('EDITOR_BRUSH', String(brushSize));
      };

      // Quick tools
      document.getElementById('fillTool').onclick = () => {
        updateStatus('Flood fill mode - click a tile to fill');
        canvas.style.cursor = 'crosshair';
        canvas.addEventListener('click', handleFloodFill, { once: true });
      };
      
      document.getElementById('eyedropperTool').onclick = () => {
        isEyedropping = true;
        canvas.style.cursor = 'grab';
        updateStatus('Eyedropper mode - click to pick up a tile');
      };
      
      document.getElementById('clearLayer').onclick = clearCurrentLayer;
      document.getElementById('copyLayer').onclick = copyCurrentLayer;

      // Right-click remove live (enemy/portal)
      canvas.addEventListener('contextmenu', async (e) => {
        if (!liveModeCheckbox?.checked) return;
        const pos = eventToTile(e);
        if (!pos) return;
        if (modeSelect.value === 'enemy') {
          fetch('/api/enemies/remove-at', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'x-admin-token': ADMIN_TOKEN },
            body: JSON.stringify({ mapId: currentLoadedMapId || 'default', x: pos.x, y: pos.y })
          }).catch(()=>{});
        } else if (modeSelect.value === 'portal') {
          const dest = (portalDestInput?.value || currentPortalDest || '').trim();
          fetch('/api/portals/remove', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'x-admin-token': ADMIN_TOKEN },
            body: JSON.stringify({ mapId: currentLoadedMapId || 'default', x: pos.x, y: pos.y, destMap: dest || undefined })
          }).catch(()=>{});
        }
      });

      // Reload enemies from server database
      const reloadBtn = document.getElementById('reloadEnemiesBtn');
      if (reloadBtn) {
        reloadBtn.onclick = async () => {
          await entityDatabase.load();
          buildEnemyList();
          updateStatus('Reloaded enemy definitions');
        };
      }

      // Enemy panel controls
      enemyClose.onclick = () => {
        enemyPanel.classList.add('hidden');
      };

      // Global keyboard shortcuts
      document.addEventListener('keydown', handleKeyDown);
    }

    function handleMouseDown(event) {
      if (event.button === 1) { // Middle mouse button
        isPanning = true;
        canvas.style.cursor = 'grabbing';
        return;
      }
      
      // Start drag drawing on Shift+Click
      if (event.shiftKey && (event.button === 0 || event.button === 2)) {
        const pos = eventToTile(event);
        if (pos) {
          isDragDrawing = true;
          dragStart = pos;
          dragEnd = pos;
          saveState(); // Save state at start of drag
          updateStatus('Drag to draw rectangle...');
        }
        return;
      }
      
      isMouseDown = true;
      handlePaint(event);
    }

    function handleMouseMove(event) {
      if (isPanning && (event.buttons & 4)) { // Middle mouse held
        camera.x += event.movementX / camera.zoom;
        camera.y += event.movementY / camera.zoom;
        drawMap();
        return;
      }
      
      // Handle drag drawing
      if (isDragDrawing) {
        const pos = eventToTile(event);
        if (pos) {
          dragEnd = pos;
          drawMap(); // Redraw with preview
        }
        return;
      }
      
      if (isMouseDown) {
        handlePaint(event);
      }
      
      // Show tile coordinates in status
      const pos = eventToTile(event);
      if (pos) {
        statusBar.textContent = `Tile: ${pos.x}, ${pos.y} | Zoom: ${Math.round(camera.zoom * 100)}% | Layer: ${currentLayer}`;
      }
    }

    function handleMouseUp(event) {
      if (isPanning) {
        isPanning = false;
        canvas.style.cursor = 'crosshair';
      }
      
      // Finish drag drawing
      if (isDragDrawing && dragStart && dragEnd) {
        const isErase = event.button === 2;
        paintRectangle(dragStart.x, dragStart.y, dragEnd.x, dragEnd.y, isErase);
        isDragDrawing = false;
        dragStart = null;
        dragEnd = null;
        drawMap();
        updateStatus('Rectangle drawn!');
        return;
      }
      
      isMouseDown = false;
    }

    function handlePaint(event) {
      const pos = eventToTile(event);
      if (!pos) return;
      
      // Handle eyedropper
      if (isEyedropping) {
        eyedrop(pos.x, pos.y);
        isEyedropping = false;
        canvas.style.cursor = 'crosshair';
        return;
      }
      
      // Save state on first paint action
      if (!isMouseDown) {
        saveState();
      }
      
      const isErase = event.button === 2 || event.buttons === 2;
      paint(pos.x, pos.y, isErase);
      drawMap();
    }

    function handleFloodFill(event) {
      const pos = eventToTile(event);
      if (pos) {
        floodFill(pos.x, pos.y);
      }
      canvas.style.cursor = 'crosshair';
    }

    function handleWheel(event) {
      event.preventDefault();
      
      if (event.deltaY < 0) {
        zoomIn();
      } else {
        zoomOut();
      }
    }

    function handleKeyDown(event) {
      // Save shortcut
      if ((event.ctrlKey || event.metaKey) && event.key === 's') {
        event.preventDefault();
        saveMap();
      }
      
      // Undo/Redo
      if ((event.ctrlKey || event.metaKey) && event.key === 'z' && !event.shiftKey) {
        event.preventDefault();
        undo();
      }
      if ((event.ctrlKey || event.metaKey) && (event.key === 'y' || (event.key === 'z' && event.shiftKey))) {
        event.preventDefault();
        redo();
      }
      
      // Rotation shortcut
      if (event.key.toLowerCase() === 'r' && currentTile) {
        currentRot = (currentRot + 1) % 4;
        updateCurrentTileDisplay();
        updateRotationDisplay();
      }
      
      // Toggle enemy panel
      if (event.shiftKey && event.key.toLowerCase() === 'e') {
        enemyPanel.classList.toggle('hidden');
      }
      
      // Eyedropper
      if (event.code === 'Space' && !event.repeat) {
        event.preventDefault();
        isEyedropping = true;
        canvas.style.cursor = 'grab';
        updateStatus('Eyedropper mode - click to pick up a tile');
      }
      
      // Brush size shortcuts
      if (event.key >= '1' && event.key <= '5') {
        brushSize = +event.key;
        brushSizeSlider.value = brushSize;
        updateBrushSizeDisplay();
      }
      
      // Quick zoom shortcuts
      if (event.key === '=' || event.key === '+') { zoomIn(); persistCamera(); }
      if (event.key === '-') { zoomOut(); persistCamera(); }
      if (event.key === '0') { resetView(); persistCamera(); }
    }

    // ============= DRAWING =============
    function drawMap() {
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // No transform needed now - canvas is sized correctly
      
      // Draw layers (bottom to top)
      layers.forEach(layer => {
        if (layer.visible === false) return;
        
        const grid = layer.grid;
        if (!grid) return;
        
        for (let y = 0; y < mapH; y++) {
          if (!grid[y]) continue;
          for (let x = 0; x < mapW; x++) {
            const cell = grid[y][x];
            if (!cell) continue;
            
            ctx.save();
            ctx.translate(x * tileW + tileW / 2, y * tileH + tileH / 2);
            ctx.rotate((cell.rot || 0) * Math.PI / 2);
            spriteDatabase.drawSprite(ctx, cell.sprite, -tileW / 2, -tileH / 2, tileW, tileH);
            ctx.restore();
          }
        }
      });
      
      // Draw entities
      entities.forEach(entity => {
        ctx.save();
        ctx.translate(entity.x * tileW + tileW / 2, entity.y * tileH + tileH / 2);
        ctx.rotate((entity.rot || 0) * Math.PI / 2);
        if (entity.type === 'spawn') {
          // Draw a simple green diamond as spawn marker
          ctx.fillStyle = '#00ff88';
          ctx.beginPath();
          ctx.moveTo(0, -tileH/2 + 4);
          ctx.lineTo(tileW/2 - 4, 0);
          ctx.lineTo(0, tileH/2 - 4);
          ctx.lineTo(-tileW/2 + 4, 0);
          ctx.closePath();
          ctx.fill();
        } else {
          spriteDatabase.drawSprite(ctx, entity.sprite, -tileW / 2, -tileH / 2, tileW, tileH);
        }
        ctx.restore();
        
        // Hover label near mouse for entity name/type
        if (lastMousePos) {
          const mx = Math.floor(lastMousePos.x / tileW);
          const my = Math.floor(lastMousePos.y / tileH);
          if (mx === entity.x && my === entity.y) {
            ctx.save();
            const label = (entity.type === 'enemy') ? (entity.id || entity.sprite || 'Enemy')
                         : (entity.type === 'portal') ? 'Portal'
                         : (entity.type === 'spawn') ? 'Spawn'
                         : (entity.type || 'Entity');
            ctx.font = '12px Arial';
            const tw = ctx.measureText(label).width + 6;
            const bx = entity.x * tileW + 2;
            const by = entity.y * tileH - 6;
            ctx.fillStyle = 'rgba(0,0,0,0.75)';
            ctx.fillRect(bx, by-12, tw, 14);
            ctx.strokeStyle = 'rgba(255,255,255,0.85)';
            ctx.lineWidth = 1;
            ctx.strokeRect(bx, by-12, tw, 14);
            ctx.fillStyle = '#fff';
            ctx.fillText(label, bx+3, by);
            ctx.restore();
          }
        }
        
        // Draw outlines
        if (entity.type === 'enemy') {
          ctx.strokeStyle = 'red';
          ctx.lineWidth = 1;
          ctx.strokeRect(entity.x * tileW, entity.y * tileH, tileW, tileH);
        } else if (entity.type === 'portal') {
          ctx.strokeStyle = 'cyan';
          ctx.lineWidth = 2;
          ctx.strokeRect(entity.x * tileW + 2, entity.y * tileH + 2, tileW - 4, tileH - 4);
        } else if (entity.type === 'spawn') {
          ctx.strokeStyle = '#00ff88';
          ctx.lineWidth = 2;
          ctx.strokeRect(entity.x * tileW + 4, entity.y * tileH + 4, tileW - 8, tileH - 8);
        }
      });
      
      // Draw drag rectangle preview
      if (isDragDrawing && dragStart && dragEnd) {
        const minX = Math.min(dragStart.x, dragEnd.x);
        const maxX = Math.max(dragStart.x, dragEnd.x);
        const minY = Math.min(dragStart.y, dragEnd.y);
        const maxY = Math.max(dragStart.y, dragEnd.y);
        
        ctx.strokeStyle = 'yellow';
        ctx.lineWidth = 2;
        ctx.strokeRect(
          minX * tileW, 
          minY * tileH, 
          (maxX - minX + 1) * tileW, 
          (maxY - minY + 1) * tileH
        );
        
        // Show preview of what will be painted
        ctx.globalAlpha = 0.5;
        for (let y = minY; y <= maxY; y++) {
          for (let x = minX; x <= maxX; x++) {
            if (currentTile && modeSelect.value === 'tile') {
              ctx.save();
              ctx.translate(x * tileW + tileW / 2, y * tileH + tileH / 2);
              ctx.rotate(currentRot * Math.PI / 2);
              spriteDatabase.drawSprite(ctx, currentTile, -tileW / 2, -tileH / 2, tileW, tileH);
              ctx.restore();
            }
          }
        }
        ctx.globalAlpha = 1.0;
      }
      
      // Draw grid overlay (only when zoomed in enough)
      if (camera.zoom >= 0.5) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        for (let x = 0; x <= mapW; x++) {
          ctx.beginPath();
          ctx.moveTo(x * tileW, 0);
          ctx.lineTo(x * tileW, mapH * tileH);
          ctx.stroke();
        }
        for (let y = 0; y <= mapH; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * tileH);
          ctx.lineTo(mapW * tileW, y * tileH);
          ctx.stroke();
        }
      }
    }

    // ============= SAVE/LOAD =============
    async function saveMap() {
      const filename = prompt('Save map as:');
      if (!filename) return;

      const mapData = {
        width: mapW,
        height: mapH,
        tileW: tileW,
        tileH: tileH,
        layers: layers,
        entities: entities
      };

      try {
        const response = await fetch('/api/map-editor/save', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            mapName: filename,
            mapData: mapData
          })
        });

        if (!response.ok) throw new Error('API unavailable');

        const result = await response.json();
        if (result.success) {
          updateStatus(`Map saved to ${result.path}`);
          await refreshMapList();
        } else {
          alert(`Save failed: ${result.error}`);
        }
      } catch (error) {
        // Fallback: save to localStorage when server unavailable
        console.warn('[MapEditor] Server unavailable, saving to localStorage');
        const mapKey = `MAP_${filename.replace(/\.json$/i, '')}`;
        localStorage.setItem(mapKey, JSON.stringify(mapData));

        // Track saved maps in localStorage
        let savedMaps = JSON.parse(localStorage.getItem('MAP_LIST') || '[]');
        if (!savedMaps.includes(filename)) {
          savedMaps.push(filename);
          localStorage.setItem('MAP_LIST', JSON.stringify(savedMaps));
        }

        updateStatus(`Map saved to localStorage: ${filename}`);
        await refreshMapList();
      }
    }

    async function loadMap() {
      const rawFilename = document.getElementById('mapList').value;
      if (!rawFilename) return;

      let mapData;
      let filename = rawFilename;

      try {
        // Check if this is a localStorage map
        if (rawFilename.startsWith('local:')) {
          filename = rawFilename.replace('local:', '');
          const mapKey = `MAP_${filename.replace(/\.json$/i, '')}`;
          const stored = localStorage.getItem(mapKey);
          if (!stored) throw new Error('Map not found in localStorage');
          mapData = JSON.parse(stored);
        } else {
          const response = await fetch('/maps/' + filename);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          mapData = await response.json();
        }
        
        // Load basic properties
        mapW = mapData.width || 32;
        mapH = mapData.height || 32;
        tileW = mapData.tileW || 16;
        tileH = mapData.tileH || 16;
        
        canvas.width = mapW * tileW;
        canvas.height = mapH * tileH;
        
        // Update canvas size for zoom
        updateCanvasSize();
        
        // Load layers - with robust backwards compatibility
        if (mapData.layers && Array.isArray(mapData.layers)) {
          // New format - ensure all layers have proper structure
          layers = mapData.layers.map(layer => ({
            name: layer.name || 'unknown',
            grid: layer.grid || createEmptyGrid(),
            visible: layer.visible !== false
          }));
        } else {
          // Old format - convert legacy structure
          layers = [];
          
          // Convert old ground/objects/decor arrays
          if (mapData.ground) {
            layers.push({ 
              name: 'ground', 
              grid: ensureGridSize(mapData.ground),
              visible: true 
            });
          }
          if (mapData.objects) {
            layers.push({ 
              name: 'objects', 
              grid: ensureGridSize(mapData.objects),
              visible: true 
            });
          }
          if (mapData.decor) {
            layers.push({ 
              name: 'decor', 
              grid: ensureGridSize(mapData.decor),
              visible: true 
            });
          }
          
          // Ensure at least one layer exists
          if (layers.length === 0) {
            layers.push({ 
              name: 'ground', 
              grid: createEmptyGrid(),
              visible: true 
            });
          }
        }
        
        // Ensure all layers have the correct grid size
        layers.forEach(layer => {
          if (!layer.grid || layer.grid.length !== mapH) {
            layer.grid = createEmptyGrid();
          } else {
            // Ensure each row has the correct width
            for (let y = 0; y < mapH; y++) {
              if (!layer.grid[y] || layer.grid[y].length !== mapW) {
                layer.grid[y] = Array(mapW).fill(null);
              }
            }
          }
        });
        
        // Load entities - with backwards compatibility
        entities = mapData.entities || mapData.enemies || [];
        
        currentLayer = 0;
        camera = { x: 0, y: 0, zoom: 1 };
        zoomIndex = 3;
        
        // Clear undo/redo
        undoStack = [];
        redoStack = [];
        
        buildLayerSelect();
        buildLayerVisibility();
        updateZoomDisplay();
        drawMap();
        
        updateStatus(`Map "${filename}" loaded successfully`);
      } catch (error) {
        console.error('Load failed:', error);
        updateStatus(`Load failed: ${error.message}`);
        // Don't show alert, just log and show in status
      }
    }

    // Helper function to ensure grid matches current map dimensions
    function ensureGridSize(grid) {
      if (!grid || !Array.isArray(grid)) return createEmptyGrid();
      
      const newGrid = createEmptyGrid();
      for (let y = 0; y < Math.min(grid.length, mapH); y++) {
        if (grid[y] && Array.isArray(grid[y])) {
          for (let x = 0; x < Math.min(grid[y].length, mapW); x++) {
            newGrid[y][x] = grid[y][x];
          }
        }
      }
      return newGrid;
    }

    // ============= ENEMY PANEL DRAG =============
    function enableEnemyPanelDrag() {
      let isDragging = false;
      let dragOffsetX = 0;
      let dragOffsetY = 0;
      
      enemyHeader.addEventListener('mousedown', event => {
        if (event.target === enemyClose) return; // Don't drag when clicking close button
        
        isDragging = true;
        dragOffsetX = event.clientX - enemyPanel.offsetLeft;
        dragOffsetY = event.clientY - enemyPanel.offsetTop;
        enemyHeader.style.cursor = 'grabbing';
      });
      
      window.addEventListener('mousemove', event => {
        if (isDragging) {
          enemyPanel.style.left = (event.clientX - dragOffsetX) + 'px';
          enemyPanel.style.top = (event.clientY - dragOffsetY) + 'px';
        }
      });
      
      window.addEventListener('mouseup', () => {
        isDragging = false;
        enemyHeader.style.cursor = 'move';
      });
    }

    // ============= START =============
    init();
  </script>
</body>
</html>