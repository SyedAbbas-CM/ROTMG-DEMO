

// =========================================
// FILE: public/src/game/backup/clientBulletManager.js
// =========================================

/**
 * ClientBulletManager.js
 * Client-side manager for bullets with client prediction and reconciliation
 */
export class ClientBulletManager {
    /**
     * Creates a client-side bullet manager
     * @param {number} maxBullets - Maximum number of bullets to support
     */
    constructor(maxBullets = 10000) {
      this.maxBullets = maxBullets;
      this.bulletCount = 0;
      
      // Structure of Arrays for performance
      this.id = new Array(maxBullets);        // Unique bullet IDs
      this.x = new Float32Array(maxBullets);  // X position
      this.y = new Float32Array(maxBullets);  // Y position
      this.vx = new Float32Array(maxBullets); // X velocity
      this.vy = new Float32Array(maxBullets); // Y velocity
      this.life = new Float32Array(maxBullets); // Remaining life in seconds
      this.width = new Float32Array(maxBullets);  // Width for collision
      this.height = new Float32Array(maxBullets); // Height for collision
      this.ownerId = new Array(maxBullets);   // Who fired this bullet
      
      // Visual properties
      this.sprite = new Array(maxBullets);    // Sprite or null
      
      // Mapping from ID to index for fast lookups
      this.idToIndex = new Map();
      
      // Local prediction bullets (client-created, not yet confirmed by server)
      this.localBullets = new Set();
    }
    
    /**
     * Add a new bullet
     * @param {Object} bulletData - Bullet properties
     * @returns {string} Bullet ID
     */
    addBullet(bulletData) {
      if (this.bulletCount >= this.maxBullets) {
        console.warn('ClientBulletManager: Maximum bullet capacity reached');
        return null;
      }
      
      const index = this.bulletCount++;
      const bulletId = bulletData.id || `local_${Date.now()}_${index}`;
      
      // Store bullet properties
      this.id[index] = bulletId;
      this.x[index] = bulletData.x;
      this.y[index] = bulletData.y;
      this.vx[index] = bulletData.vx;
      this.vy[index] = bulletData.vy;
      this.life[index] = bulletData.lifetime || 3.0; // Default 3 seconds
      this.width[index] = bulletData.width || 5;
      this.height[index] = bulletData.height || 5;
      this.ownerId[index] = bulletData.ownerId || null;
      this.sprite[index] = bulletData.sprite || null;
      
      // Store index for lookup
      this.idToIndex.set(bulletId, index);
      
      // If this is a local prediction bullet (client-created)
      if (bulletId.startsWith('local_')) {
        this.localBullets.add(bulletId);
      }
      
      return bulletId;
    }
    
    /**
     * Update all bullets
     * @param {number} deltaTime - Time elapsed since last update in seconds
     */
    update(deltaTime) {
      let count = this.bulletCount;
      
      for (let i = 0; i < count; i++) {
        // Update position
        this.x[i] += this.vx[i] * deltaTime;
        this.y[i] += this.vy[i] * deltaTime;
        
        // Decrement lifetime
        this.life[i] -= deltaTime;
        
        // Remove expired bullets
        if (this.life[i] <= 0) {
          this.swapRemove(i);
          count--;
          i--;
        }
      }
      
      this.bulletCount = count;
    }
    
    /**
     * Remove a bullet using swap-and-pop technique
     * @param {number} index - Index of bullet to remove
     */
    swapRemove(index) {
      if (index < 0 || index >= this.bulletCount) return;
      
      // Remove from ID mapping and local bullets set
      const bulletId = this.id[index];
      this.idToIndex.delete(bulletId);
      this.localBullets.delete(bulletId);
      
      // Swap with the last bullet (if not already the last)
      const lastIndex = this.bulletCount - 1;
      if (index !== lastIndex) {
        // Copy properties from last bullet to this position
        this.id[index] = this.id[lastIndex];
        this.x[index] = this.x[lastIndex];
        this.y[index] = this.y[lastIndex];
        this.vx[index] = this.vx[lastIndex];
        this.vy[index] = this.vy[lastIndex];
        this.life[index] = this.life[lastIndex];
        this.width[index] = this.width[lastIndex];
        this.height[index] = this.height[lastIndex];
        this.ownerId[index] = this.ownerId[lastIndex];
        this.sprite[index] = this.sprite[lastIndex];
        
        // Update index in mapping
        this.idToIndex.set(this.id[index], index);
      }
      
      this.bulletCount--;
    }
    
    /**
     * Find bullet index by ID
     * @param {string} bulletId - ID of bullet to find
     * @returns {number} Index of bullet or -1 if not found
     */
    findIndexById(bulletId) {
      const index = this.idToIndex.get(bulletId);
      return index !== undefined ? index : -1;
    }
    
    /**
     * Remove a bullet by ID
     * @param {string} bulletId - ID of bullet to remove
     * @returns {boolean} True if bullet was found and removed
     */
    removeBulletById(bulletId) {
      const index = this.findIndexById(bulletId);
      if (index !== -1) {
        this.swapRemove(index);
        return true;
      }
      return false;
    }
    
    /**
     * Set initial bullets list from server
     * @param {Array} bullets - Array of bullet data from server
     */
    setBullets(bullets) {
      // Clear existing bullets except local predictions
      this.clearNonLocalBullets();
      
      // Add new bullets from server
      for (const bullet of bullets) {
        // Skip if we already have a local prediction for this ID
        if (this.findIndexById(bullet.id) !== -1) continue;
        
        this.addBullet(bullet);
      }
    }
    
    /**
     * Clear all non-local (server confirmed) bullets
     */
    clearNonLocalBullets() {
      // Remove bullets that aren't local predictions
      for (let i = 0; i < this.bulletCount; i++) {
        if (!this.localBullets.has(this.id[i])) {
          this.swapRemove(i);
          i--;
        }
      }
    }
    
    /**
     * Update bullets based on server data
     * @param {Array} bullets - Array of bullet data from server
     */
    updateBullets(bullets) {
      // Process server bullets
      for (const bullet of bullets) {
        const index = this.findIndexById(bullet.id);
        
        if (index !== -1) {
          // Update existing bullet
          this.x[index] = bullet.x;
          this.y[index] = bullet.y;
          this.vx[index] = bullet.vx;
          this.vy[index] = bullet.vy;
          this.life[index] = bullet.life;
        } else {
          // Add new bullet if we don't have it
          this.addBullet(bullet);
        }
      }
      
      // Remove bullets that aren't in the server update and aren't local predictions
      const serverBulletIds = new Set(bullets.map(b => b.id));
      
      for (let i = 0; i < this.bulletCount; i++) {
        const bulletId = this.id[i];
        
        // Keep local predictions and bullets from server update
        if (!this.localBullets.has(bulletId) && !serverBulletIds.has(bulletId)) {
          this.swapRemove(i);
          i--;
        }
      }
    }
    
    /**
     * Clean up resources
     */
    cleanup() {
      this.bulletCount = 0;
      this.idToIndex.clear();
      this.localBullets.clear();
    }
  }

// =========================================
// FILE: public/src/game/backup/clientEnemyManager.js
// =========================================

/**
 * ClientEnemyManager.js
 * Client-side manager for enemies with visual effects and interpolation
 */
export class ClientEnemyManager {
    /**
     * Creates a client-side enemy manager
     * @param {number} maxEnemies - Maximum number of enemies to support
     */
    constructor(maxEnemies = 1000) {
      this.maxEnemies = maxEnemies;
      this.enemyCount = 0;
      
      // Structure of Arrays for performance
      this.id = new Array(maxEnemies);         // Unique enemy IDs
      this.x = new Float32Array(maxEnemies);   // X position
      this.y = new Float32Array(maxEnemies);   // Y position
      this.width = new Float32Array(maxEnemies);  // Width for collision
      this.height = new Float32Array(maxEnemies); // Height for collision
      this.type = new Uint8Array(maxEnemies);  // Enemy type (0-4)
      this.health = new Float32Array(maxEnemies); // Current health
      this.maxHealth = new Float32Array(maxEnemies); // Maximum health
      
      // Visual and animation properties
      this.sprite = new Array(maxEnemies);     // Sprite reference
      this.spriteX = new Uint16Array(maxEnemies); // Sprite X position in sheet
      this.spriteY = new Uint16Array(maxEnemies); // Sprite Y position in sheet
      this.animFrame = new Uint8Array(maxEnemies); // Current animation frame
      this.animTime = new Float32Array(maxEnemies); // Animation timer
      
      // Visual effects
      this.flashTime = new Float32Array(maxEnemies); // Hit flash effect timer
      this.deathTime = new Float32Array(maxEnemies); // Death animation timer
      
      // Movement interpolation
      this.prevX = new Float32Array(maxEnemies); // Previous X position
      this.prevY = new Float32Array(maxEnemies); // Previous Y position
      this.targetX = new Float32Array(maxEnemies); // Target X position
      this.targetY = new Float32Array(maxEnemies); // Target Y position
      this.interpTime = new Float32Array(maxEnemies); // Interpolation timer
      
      // ID to index mapping
      this.idToIndex = new Map();
      
      // Enemy type to sprite mapping
      this.typeToSprite = [
        { x: 0, y: 0 },   // Type 0: Black Overlord
        { x: 8, y: 0 },   // Type 1: Red Berserker
        { x: 16, y: 0 },  // Type 2: Purple Illusionist
        { x: 24, y: 0 },  // Type 3: Emerald Regenerator
        { x: 32, y: 0 }   // Type 4: Navy Turtle
      ];
    }
    
    /**
     * Add a new enemy
     * @param {Object} enemyData - Enemy properties
     * @returns {string} Enemy ID
     */
    addEnemy(enemyData) {
      if (this.enemyCount >= this.maxEnemies) {
        console.warn('ClientEnemyManager: Maximum enemy capacity reached');
        return null;
      }
      
      const index = this.enemyCount++;
      const enemyId = enemyData.id || `enemy_${index}`;
      
      // Store enemy properties
      this.id[index] = enemyId;
      this.x[index] = enemyData.x;
      this.y[index] = enemyData.y;
      this.width[index] = enemyData.width || 20;
      this.height[index] = enemyData.height || 20;
      this.type[index] = enemyData.type || 0;
      this.health[index] = enemyData.health || 100;
      this.maxHealth[index] = enemyData.maxHealth || 100;
      
      // Initialize visual properties
      const spriteData = this.typeToSprite[this.type[index]] || this.typeToSprite[0];
      this.spriteX[index] = spriteData.x;
      this.spriteY[index] = spriteData.y;
      this.animFrame[index] = 0;
      this.animTime[index] = 0;
      this.flashTime[index] = 0;
      this.deathTime[index] = 0;
      
      // Initialize interpolation
      this.prevX[index] = this.x[index];
      this.prevY[index] = this.y[index];
      this.targetX[index] = this.x[index];
      this.targetY[index] = this.y[index];
      this.interpTime[index] = 0;
      
      // Store index for lookup
      this.idToIndex.set(enemyId, index);
      
      return enemyId;
    }
    
    /**
     * Update all enemies
     * @param {number} deltaTime - Time elapsed since last update in seconds
     */
    update(deltaTime) {
      for (let i = 0; i < this.enemyCount; i++) {
        // Update position interpolation
        this.updateInterpolation(i, deltaTime);
        
        // Update animations
        this.updateAnimation(i, deltaTime);
        
        // Update visual effects
        this.updateEffects(i, deltaTime);
      }
    }
    
    /**
     * Update position interpolation
     * @param {number} index - Enemy index
     * @param {number} deltaTime - Time elapsed since last update
     */
    updateInterpolation(index, deltaTime) {
      // Interpolation factor (0 to 1)
      const INTERP_SPEED = 5; // Adjust for smoother/faster interpolation
      this.interpTime[index] += deltaTime * INTERP_SPEED;
      
      if (this.interpTime[index] >= 1) {
        // Reached target, prepare for next interpolation
        this.prevX[index] = this.targetX[index];
        this.prevY[index] = this.targetY[index];
        this.x[index] = this.targetX[index];
        this.y[index] = this.targetY[index];
        this.interpTime[index] = 1;
      } else {
        // Interpolate between previous and target positions
        const t = this.interpTime[index];
        this.x[index] = this.prevX[index] + (this.targetX[index] - this.prevX[index]) * t;
        this.y[index] = this.prevY[index] + (this.targetY[index] - this.prevY[index]) * t;
      }
    }
    
    /**
     * Update animations
     * @param {number} index - Enemy index
     * @param {number} deltaTime - Time elapsed since last update
     */
    updateAnimation(index, deltaTime) {
      // Animation timing
      this.animTime[index] += deltaTime;
      
      // Change animation frame every 0.2 seconds (adjust as needed)
      if (this.animTime[index] >= 0.2) {
        this.animTime[index] = 0;
        this.animFrame[index] = (this.animFrame[index] + 1) % 4; // Assuming 4 frames
        
        // Update sprite sheet position for animation
        // This assumes your sprite sheet has animation frames horizontally
        const baseX = this.typeToSprite[this.type[index]].x;
        this.spriteX[index] = baseX + this.animFrame[index] * 8; // Assuming 8px width sprites
      }
    }
    
    /**
     * Update visual effects
     * @param {number} index - Enemy index
     * @param {number} deltaTime - Time elapsed since last update
     */
    updateEffects(index, deltaTime) {
      // Handle hit flash effect
      if (this.flashTime[index] > 0) {
        this.flashTime[index] -= deltaTime;
      }
      
      // Handle death animation
      if (this.deathTime[index] > 0) {
        this.deathTime[index] -= deltaTime;
        
        // Remove enemy when death animation completes
        if (this.deathTime[index] <= 0) {
          this.swapRemove(index);
        }
      }
    }
    
    /**
     * Apply hit effect to an enemy
     * @param {number} index - Enemy index
     */
    applyHitEffect(index) {
      if (index < 0 || index >= this.enemyCount) return;
      
      // Set flash timer (duration in seconds)
      this.flashTime[index] = 0.1;
    }
    
    /**
     * Start death animation for an enemy
     * @param {number} index - Enemy index
     */
    startDeathAnimation(index) {
      if (index < 0 || index >= this.enemyCount) return;
      
      // Set death animation timer (duration in seconds)
      this.deathTime[index] = 0.5;
    }
    
    /**
     * Set enemy health
     * @param {string} enemyId - Enemy ID
     * @param {number} health - New health value
     * @returns {boolean} True if enemy was found
     */
    setEnemyHealth(enemyId, health) {
      const index = this.findIndexById(enemyId);
      if (index === -1) return false;
      
      // Apply hit effect if health decreased
      if (health < this.health[index]) {
        this.applyHitEffect(index);
      }
      
      // Update health
      this.health[index] = health;
      
      // Start death animation if health is 0
      if (health <= 0 && this.deathTime[index] <= 0) {
        this.startDeathAnimation(index);
      }
      
      return true;
    }
    
    /**
     * Remove an enemy using swap-and-pop technique
     * @param {number} index - Index of enemy to remove
     */
    swapRemove(index) {
      if (index < 0 || index >= this.enemyCount) return;
      
      // Remove from ID mapping
      const enemyId = this.id[index];
      this.idToIndex.delete(enemyId);
      
      // Swap with the last enemy (if not already the last)
      const lastIndex = this.enemyCount - 1;
      if (index !== lastIndex) {
        // Copy all properties from last enemy to this position
        this.id[index] = this.id[lastIndex];
        this.x[index] = this.x[lastIndex];
        this.y[index] = this.y[lastIndex];
        this.width[index] = this.width[lastIndex];
        this.height[index] = this.height[lastIndex];
        this.type[index] = this.type[lastIndex];
        this.health[index] = this.health[lastIndex];
        this.maxHealth[index] = this.maxHealth[lastIndex];
        this.sprite[index] = this.sprite[lastIndex];
        this.spriteX[index] = this.spriteX[lastIndex];
        this.spriteY[index] = this.spriteY[lastIndex];
        this.animFrame[index] = this.animFrame[lastIndex];
        this.animTime[index] = this.animTime[lastIndex];
        this.flashTime[index] = this.flashTime[lastIndex];
        this.deathTime[index] = this.deathTime[lastIndex];
        this.prevX[index] = this.prevX[lastIndex];
        this.prevY[index] = this.prevY[lastIndex];
        this.targetX[index] = this.targetX[lastIndex];
        this.targetY[index] = this.targetY[lastIndex];
        this.interpTime[index] = this.interpTime[lastIndex];
        
        // Update index in mapping
        this.idToIndex.set(this.id[index], index);
      }
      
      this.enemyCount--;
    }
    
    /**
     * Find enemy index by ID
     * @param {string} enemyId - ID of enemy to find
     * @returns {number} Index of enemy or -1 if not found
     */
    findIndexById(enemyId) {
      const index = this.idToIndex.get(enemyId);
      return index !== undefined ? index : -1;
    }
    
    /**
     * Remove an enemy by ID
     * @param {string} enemyId - ID of enemy to remove
     * @returns {boolean} True if enemy was found and removed
     */
    removeEnemyById(enemyId) {
      const index = this.findIndexById(enemyId);
      if (index !== -1) {
        this.swapRemove(index);
        return true;
      }
      return false;
    }
    
    /**
     * Set initial enemies list from server
     * @param {Array} enemies - Array of enemy data from server
     */
    setEnemies(enemies) {
      // Clear existing enemies
      this.enemyCount = 0;
      this.idToIndex.clear();
      
      // Add new enemies from server
      for (const enemy of enemies) {
        this.addEnemy(enemy);
      }
    }
    
    /**
     * Update enemies based on server data
     * @param {Array} enemies - Array of enemy data from server
     */
    updateEnemies(enemies) {
      // Track which enemies we've seen in this update
      const seenEnemies = new Set();
      
      // Update existing enemies and add new ones
      for (const enemy of enemies) {
        const index = this.findIndexById(enemy.id);
        
        if (index !== -1) {
          // Update existing enemy
          // Store previous position for interpolation
          this.prevX[index] = this.x[index];
          this.prevY[index] = this.y[index];
          
          // Set target position (for interpolation)
          this.targetX[index] = enemy.x;
          this.targetY[index] = enemy.y;
          
          // Reset interpolation timer
          this.interpTime[index] = 0;
          
          // Update health and other properties
          if (this.health[index] !== enemy.health) {
            this.setEnemyHealth(enemy.id, enemy.health);
          }
          
          this.maxHealth[index] = enemy.maxHealth;
        } else {
          // Add new enemy
          this.addEnemy(enemy);
        }
        
        seenEnemies.add(enemy.id);
      }
      
      // Remove enemies that aren't in the server update (except those in death animation)
      for (let i = 0; i < this.enemyCount; i++) {
        if (!seenEnemies.has(this.id[i]) && this.deathTime[i] <= 0) {
          this.swapRemove(i);
          i--; // Adjust index after removal
        }
      }
    }
    
    /**
     * Get enemy data for rendering
     * @returns {Array} Array of enemy render data
     */
    getEnemiesForRender() {
      const enemies = [];
      
      for (let i = 0; i < this.enemyCount; i++) {
        // Skip enemies in death animation
        if (this.health[i] <= 0 && this.deathTime[i] <= 0) continue;
        
        enemies.push({
          id: this.id[i],
          x: this.x[i],
          y: this.y[i],
          spriteX: this.spriteX[i],
          spriteY: this.spriteY[i],
          width: this.width[i],
          height: this.height[i],
          health: this.health[i],
          maxHealth: this.maxHealth[i],
          isFlashing: this.flashTime[i] > 0,
          isDying: this.deathTime[i] > 0
        });
      }
      
      return enemies;
    }
    
    /**
     * Clean up resources
     */
    cleanup() {
      this.enemyCount = 0;
      this.idToIndex.clear();
    }
  }

// =========================================
// FILE: public/src/game/clientEnemyManager.js
// =========================================

/**
 * ClientEnemyManager.js
 * Client-side manager for enemies with visual effects and interpolation
 */
export class ClientEnemyManager {
    /**
     * Creates a client-side enemy manager
     * @param {number} maxEnemies - Maximum number of enemies to support
     */
    constructor(maxEnemies = 1000) {
      this.maxEnemies = maxEnemies;
      this.enemyCount = 0;
      
      // Structure of Arrays for performance
      this.id = new Array(maxEnemies);         // Unique enemy IDs
      this.x = new Float32Array(maxEnemies);   // X position
      this.y = new Float32Array(maxEnemies);   // Y position
      this.width = new Float32Array(maxEnemies);  // Width for collision
      this.height = new Float32Array(maxEnemies); // Height for collision
      this.type = new Uint8Array(maxEnemies);  // Enemy type (0-4)
      this.health = new Float32Array(maxEnemies); // Current health
      this.maxHealth = new Float32Array(maxEnemies); // Maximum health
      
      // Visual and animation properties
      this.sprite = new Array(maxEnemies);     // Sprite reference
      this.spriteX = new Uint16Array(maxEnemies); // Sprite X position in sheet
      this.spriteY = new Uint16Array(maxEnemies); // Sprite Y position in sheet
      this.animFrame = new Uint8Array(maxEnemies); // Current animation frame
      this.animTime = new Float32Array(maxEnemies); // Animation timer
      
      // Visual effects
      this.flashTime = new Float32Array(maxEnemies); // Hit flash effect timer
      this.deathTime = new Float32Array(maxEnemies); // Death animation timer
      
      // Movement interpolation
      this.prevX = new Float32Array(maxEnemies); // Previous X position
      this.prevY = new Float32Array(maxEnemies); // Previous Y position
      this.targetX = new Float32Array(maxEnemies); // Target X position
      this.targetY = new Float32Array(maxEnemies); // Target Y position
      this.interpTime = new Float32Array(maxEnemies); // Interpolation timer
      
      // ID to index mapping
      this.idToIndex = new Map();
      
      // Enemy type to sprite mapping
      this.typeToSprite = [
        { x: 0, y: 0 },   // Type 0: Black Overlord
        { x: 8, y: 0 },   // Type 1: Red Berserker
        { x: 16, y: 0 },  // Type 2: Purple Illusionist
        { x: 24, y: 0 },  // Type 3: Emerald Regenerator
        { x: 32, y: 0 }   // Type 4: Navy Turtle
      ];
    }
    
    /**
     * Add a new enemy
     * @param {Object} enemyData - Enemy properties
     * @returns {string} Enemy ID
     */
    addEnemy(enemyData) {
      if (this.enemyCount >= this.maxEnemies) {
        console.warn('ClientEnemyManager: Maximum enemy capacity reached');
        return null;
      }
      
      const index = this.enemyCount++;
      const enemyId = enemyData.id || `enemy_${index}`;
      
      // Store enemy properties
      this.id[index] = enemyId;
      this.x[index] = enemyData.x;
      this.y[index] = enemyData.y;
      this.width[index] = enemyData.width || 20;
      this.height[index] = enemyData.height || 20;
      this.type[index] = enemyData.type || 0;
      this.health[index] = enemyData.health || 100;
      this.maxHealth[index] = enemyData.maxHealth || 100;
      
      // Initialize visual properties
      const spriteData = this.typeToSprite[this.type[index]] || this.typeToSprite[0];
      this.spriteX[index] = spriteData.x;
      this.spriteY[index] = spriteData.y;
      this.animFrame[index] = 0;
      this.animTime[index] = 0;
      this.flashTime[index] = 0;
      this.deathTime[index] = 0;
      
      // Initialize interpolation
      this.prevX[index] = this.x[index];
      this.prevY[index] = this.y[index];
      this.targetX[index] = this.x[index];
      this.targetY[index] = this.y[index];
      this.interpTime[index] = 0;
      
      // Store index for lookup
      this.idToIndex.set(enemyId, index);
      
      return enemyId;
    }
    
    /**
     * Update all enemies
     * @param {number} deltaTime - Time elapsed since last update in seconds
     */
    update(deltaTime) {
      for (let i = 0; i < this.enemyCount; i++) {
        // Update position interpolation
        this.updateInterpolation(i, deltaTime);
        
        // Update animations
        this.updateAnimation(i, deltaTime);
        
        // Update visual effects
        this.updateEffects(i, deltaTime);
      }
    }
    
    /**
     * Update position interpolation
     * @param {number} index - Enemy index
     * @param {number} deltaTime - Time elapsed since last update
     */
    updateInterpolation(index, deltaTime) {
      // Interpolation factor (0 to 1)
      const INTERP_SPEED = 5; // Adjust for smoother/faster interpolation
      this.interpTime[index] += deltaTime * INTERP_SPEED;
      
      if (this.interpTime[index] >= 1) {
        // Reached target, prepare for next interpolation
        this.prevX[index] = this.targetX[index];
        this.prevY[index] = this.targetY[index];
        this.x[index] = this.targetX[index];
        this.y[index] = this.targetY[index];
        this.interpTime[index] = 1;
      } else {
        // Interpolate between previous and target positions
        const t = this.interpTime[index];
        this.x[index] = this.prevX[index] + (this.targetX[index] - this.prevX[index]) * t;
        this.y[index] = this.prevY[index] + (this.targetY[index] - this.prevY[index]) * t;
      }
    }
    
    /**
     * Update animations
     * @param {number} index - Enemy index
     * @param {number} deltaTime - Time elapsed since last update
     */
    updateAnimation(index, deltaTime) {
      // Animation timing
      this.animTime[index] += deltaTime;
      
      // Change animation frame every 0.2 seconds (adjust as needed)
      if (this.animTime[index] >= 0.2) {
        this.animTime[index] = 0;
        this.animFrame[index] = (this.animFrame[index] + 1) % 4; // Assuming 4 frames
        
        // Update sprite sheet position for animation
        // This assumes your sprite sheet has animation frames horizontally
        const baseX = this.typeToSprite[this.type[index]].x;
        this.spriteX[index] = baseX + this.animFrame[index] * 8; // Assuming 8px width sprites
      }
    }
    
    /**
     * Update visual effects
     * @param {number} index - Enemy index
     * @param {number} deltaTime - Time elapsed since last update
     */
    updateEffects(index, deltaTime) {
      // Handle hit flash effect
      if (this.flashTime[index] > 0) {
        this.flashTime[index] -= deltaTime;
      }
      
      // Handle death animation
      if (this.deathTime[index] > 0) {
        this.deathTime[index] -= deltaTime;
        
        // Remove enemy when death animation completes
        if (this.deathTime[index] <= 0) {
          this.swapRemove(index);
        }
      }
    }
    
    /**
     * Apply hit effect to an enemy
     * @param {number} index - Enemy index
     */
    applyHitEffect(index) {
      if (index < 0 || index >= this.enemyCount) return;
      
      // Set flash timer (duration in seconds)
      this.flashTime[index] = 0.1;
    }
    
    /**
     * Start death animation for an enemy
     * @param {number} index - Enemy index
     */
    startDeathAnimation(index) {
      if (index < 0 || index >= this.enemyCount) return;
      
      // Set death animation timer (duration in seconds)
      this.deathTime[index] = 0.5;
    }
    
    /**
     * Set enemy health
     * @param {string} enemyId - Enemy ID
     * @param {number} health - New health value
     * @returns {boolean} True if enemy was found
     */
    setEnemyHealth(enemyId, health) {
      const index = this.findIndexById(enemyId);
      if (index === -1) return false;
      
      // Apply hit effect if health decreased
      if (health < this.health[index]) {
        this.applyHitEffect(index);
      }
      
      // Update health
      this.health[index] = health;
      
      // Start death animation if health is 0
      if (health <= 0 && this.deathTime[index] <= 0) {
        this.startDeathAnimation(index);
      }
      
      return true;
    }
    
    /**
     * Remove an enemy using swap-and-pop technique
     * @param {number} index - Index of enemy to remove
     */
    swapRemove(index) {
      if (index < 0 || index >= this.enemyCount) return;
      
      // Remove from ID mapping
      const enemyId = this.id[index];
      this.idToIndex.delete(enemyId);
      
      // Swap with the last enemy (if not already the last)
      const lastIndex = this.enemyCount - 1;
      if (index !== lastIndex) {
        // Copy all properties from last enemy to this position
        this.id[index] = this.id[lastIndex];
        this.x[index] = this.x[lastIndex];
        this.y[index] = this.y[lastIndex];
        this.width[index] = this.width[lastIndex];
        this.height[index] = this.height[lastIndex];
        this.type[index] = this.type[lastIndex];
        this.health[index] = this.health[lastIndex];
        this.maxHealth[index] = this.maxHealth[lastIndex];
        this.sprite[index] = this.sprite[lastIndex];
        this.spriteX[index] = this.spriteX[lastIndex];
        this.spriteY[index] = this.spriteY[lastIndex];
        this.animFrame[index] = this.animFrame[lastIndex];
        this.animTime[index] = this.animTime[lastIndex];
        this.flashTime[index] = this.flashTime[lastIndex];
        this.deathTime[index] = this.deathTime[lastIndex];
        this.prevX[index] = this.prevX[lastIndex];
        this.prevY[index] = this.prevY[lastIndex];
        this.targetX[index] = this.targetX[lastIndex];
        this.targetY[index] = this.targetY[lastIndex];
        this.interpTime[index] = this.interpTime[lastIndex];
        
        // Update index in mapping
        this.idToIndex.set(this.id[index], index);
      }
      
      this.enemyCount--;
    }
    
    /**
     * Find enemy index by ID
     * @param {string} enemyId - ID of enemy to find
     * @returns {number} Index of enemy or -1 if not found
     */
    findIndexById(enemyId) {
      const index = this.idToIndex.get(enemyId);
      return index !== undefined ? index : -1;
    }
    
    /**
     * Remove an enemy by ID
     * @param {string} enemyId - ID of enemy to remove
     * @returns {boolean} True if enemy was found and removed
     */
    removeEnemyById(enemyId) {
      const index = this.findIndexById(enemyId);
      if (index !== -1) {
        this.swapRemove(index);
        return true;
      }
      return false;
    }
    
    /**
     * Set initial enemies list from server
     * @param {Array} enemies - Array of enemy data from server
     */
    setEnemies(enemies) {
      // Clear existing enemies
      this.enemyCount = 0;
      this.idToIndex.clear();
      
      // Add new enemies from server
      for (const enemy of enemies) {
        this.addEnemy(enemy);
      }
    }
    
    /**
     * Update enemies based on server data
     * @param {Array} enemies - Array of enemy data from server
     */
    updateEnemies(enemies) {
      // Track which enemies we've seen in this update
      const seenEnemies = new Set();
      
      // Update existing enemies and add new ones
      for (const enemy of enemies) {
        const index = this.findIndexById(enemy.id);
        
        if (index !== -1) {
          // Update existing enemy
          // Store previous position for interpolation
          this.prevX[index] = this.x[index];
          this.prevY[index] = this.y[index];
          
          // Set target position (for interpolation)
          this.targetX[index] = enemy.x;
          this.targetY[index] = enemy.y;
          
          // Reset interpolation timer
          this.interpTime[index] = 0;
          
          // Update health and other properties
          if (this.health[index] !== enemy.health) {
            this.setEnemyHealth(enemy.id, enemy.health);
          }
          
          this.maxHealth[index] = enemy.maxHealth;
        } else {
          // Add new enemy
          this.addEnemy(enemy);
        }
        
        seenEnemies.add(enemy.id);
      }
      
      // Remove enemies that aren't in the server update (except those in death animation)
      for (let i = 0; i < this.enemyCount; i++) {
        if (!seenEnemies.has(this.id[i]) && this.deathTime[i] <= 0) {
          this.swapRemove(i);
          i--; // Adjust index after removal
        }
      }
    }
    
    /**
     * Get enemy data for rendering
     * @returns {Array} Array of enemy render data
     */
    getEnemiesForRender() {
      const enemies = [];
      
      for (let i = 0; i < this.enemyCount; i++) {
        // Skip enemies in death animation
        if (this.health[i] <= 0 && this.deathTime[i] <= 0) continue;
        
        enemies.push({
          id: this.id[i],
          x: this.x[i],
          y: this.y[i],
          spriteX: this.spriteX[i],
          spriteY: this.spriteY[i],
          width: this.width[i],
          height: this.height[i],
          health: this.health[i],
          maxHealth: this.maxHealth[i],
          isFlashing: this.flashTime[i] > 0,
          isDying: this.deathTime[i] > 0
        });
      }
      
      return enemies;
    }
    
    /**
     * Clean up resources
     */
    cleanup() {
      this.enemyCount = 0;
      this.idToIndex.clear();
    }
  }

// =========================================
// FILE: public/src/game/game.js
// =========================================

// public/src/game/game.js
import { spriteManager } from '../assets/spriteManager.js'; 
import { gameState } from './gamestate.js';
import { initControls, getKeysPressed, getMoveSpeed } from './input.js';
import { addFirstPersonElements, updateFirstPerson } from '../render/renderFirstPerson.js';
import { updateCharacter } from './updateCharacter.js';
import { renderTopDownView } from '../render/renderTopDown.js';
import { renderStrategicView } from '../render/renderStrategic.js';
import { updatePlayers, playerManager, updatePlayerInterpolation } from '../entities/entities.js';
import { renderGame } from '../render/render.js';
import { 
  ClientMapManager, 
  ClientNetworkManager, 
  MessageType,
  ClientBulletManager,
  ClientEnemyManager,
  ClientCollisionManager,
  debugOverlay
} from '../managers.js';
import { Player } from '../entities/player.js';
import { TILE_SIZE, SCALE } from '../constants/constants.js';
import * as THREE from 'three';
import { Camera } from '../camera.js';
import { EntityAnimator } from '../entities/EntityAnimator.js';
import { PlayerManager } from '../entities/PlayerManager.js';
import { initCoordinateUtils } from '../utils/coordinateUtils.js';

let renderer, scene, camera;
let lastTime = 0;

// Game managers
let networkManager;
let mapManager;
let bulletManager;
let enemyManager;
let collisionManager;
let localPlayer;

// Server connection settings
const SERVER_URL = 'ws://localhost:3000'; // Change if your server is on a different port or host

export async function initGame() {
    try {
        console.log('Starting game initialization...');
        
        // Initialize sprite sheets
        console.log('Loading sprite sheets...');
        try {
            await spriteManager.loadSpriteSheet({ 
                name: 'character_sprites', 
                path: 'assets/images/Oryx/8-Bit_Remaster_Character.png',
                defaultSpriteWidth: 10,
                defaultSpriteHeight: 10
            });
        } catch (e) {
            console.error("Failed to load first character sprite path, trying fallback:", e);
            try {
                // Try lofi_char.png as a fallback
                await spriteManager.loadSpriteSheet({ 
                    name: 'character_sprites', 
                    path: 'assets/images/Oryx/lofi_char.png',
                    defaultSpriteWidth: 8,
                    defaultSpriteHeight: 8,
                    spritesPerRow: 16,
                    spritesPerColumn: 16
                });
                console.log("Successfully loaded fallback character sprite sheet");
            } catch (e2) {
                console.error("All character sprite loading attempts failed:", e2);
            }
        }
        
        // Verify character sprites loaded successfully 
        const charSheet = spriteManager.getSpriteSheet('character_sprites');
        if (!charSheet) {
            console.error('Failed to load character sprites! Players will not render correctly.');
            console.error('Verify the file exists at: assets/images/Oryx/8-Bit_Remaster_Character.png');
        } else {
            console.log('Character sprites loaded successfully:', charSheet.config);
        }
        
        await spriteManager.loadSpriteSheet({ 
            name: 'enemy_sprites', 
            path: 'assets/images/Oryx/lofi_char.png',
            defaultSpriteWidth: 8,
            defaultSpriteHeight: 8,
            spritesPerRow: 40,
            spritesPerColumn: 40
        });
        
        await spriteManager.loadSpriteSheet({ 
            name: 'tile_sprites', 
            path: 'assets/images/Oryx/8-Bit_Remaster_World.png',
            defaultSpriteWidth: 24,
            defaultSpriteHeight: 24,
            spritesPerRow: 10,
            spritesPerColumn: 10
        });
        
        // Load bullet sprites - Add this for bullet rendering
        await spriteManager.loadSpriteSheet({ 
            name: 'bullet_sprites', 
            path: 'assets/images/Oryx/lofi_obj.png', 
            defaultSpriteWidth: 8,
            defaultSpriteHeight: 8,
            spritesPerRow: 16,
            spritesPerColumn: 16
        });
        
        console.log('All sprite sheets loaded.');

        // Initialize coordinate utilities for world-to-screen transformations
        initCoordinateUtils();
        console.log('Coordinate utilities initialized.');

        // Initialize the game state
        initializeGameState();
        
        // The sprite editor container is already in the HTML, skip initialization
        console.log('Sprite editor container already exists in HTML');
        
        // Initialize Three.js Renderer
        renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('glCanvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        console.log('Three.js Renderer initialized.');

        // Create Three.js Scene
        scene = new THREE.Scene();
        console.log('Three.js Scene created.');

        // Create Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.5, 0); // Origin with eye height
        camera.rotation.order = 'YXZ'; // Rotate first around Y, then X
        console.log('Three.js Camera created and positioned.');

        // Initialize Controls
        initControls();
        console.log('Controls initialized.');

        // Add Ambient Light
        const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
        scene.add(hemisphereLight);
        console.log('Hemisphere Light added to the scene.');

        // Add Directional Light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1000, 1000, 1000); // Position the light source
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        console.log('Directional Light added to the scene.');

        // Add First-Person Elements to the Scene
        addFirstPersonElements(scene, () => {
            console.log('First-person elements added. Connecting to server...');
            
            // Connect to the server
            connectToServer().then(() => {
                console.log('Connected to server. Starting the game loop.');
                // Start the Game Loop after connection is established
                requestAnimationFrame(gameLoop);
                
                // Show debug overlay by default
                debugOverlay.show();
                debugOverlay.enabled = true;
            }).catch(error => {
                console.error('Failed to connect to server:', error);
                // Start game loop anyway for offline testing
                requestAnimationFrame(gameLoop);
                
                // Show debug overlay by default
                debugOverlay.show();
                debugOverlay.enabled = true;
            });
        });

        // Handle window resize
        window.addEventListener('resize', handleResize);
        console.log('Window resize event listener added.');

        // Add debug key for testing player rendering
        window.addEventListener('keydown', (e) => {
            if (e.key === 'p') {
                console.log('DEBUG: Creating test player');
                spawnTestPlayer();
            }
            
            // Debug dump of player info on 'i' key
            if (e.key === 'i') {
                debugDumpPlayerInfo();
            }
            
            // Request player list update from server on 'd' key
            if (e.key === 'd') {
                console.log('DEBUG: Requesting player list from server');
                requestPlayerList();
            }
            
            // Debug map information on 'm' key
            if (e.key === 'm') {
                console.log('DEBUG: Printing map information');
                if (mapManager) {
                    // Print basic info by default, hold shift for detailed info
                    mapManager.debugPrintMapInfo(e.shiftKey);
                } else {
                    console.log('No map manager available');
                }
            }
        });
    } catch (error) {
        console.error('Error initializing the game:', error);
    }
}

/**
 * Initialize game state and managers
 */
function initializeGameState() {
    // Create local player with complete properties
    localPlayer = new Player({
        name: 'Player',
        x: 50,
        y: 50,
        width: 10,
        height: 10,
        speed: 150,
        projectileSpeed: 300, // Critical for shooting
        damage: 10,
        shootCooldown: 0.3,
        sprite: 'character_sprites_sprite_1'
    });
    
    console.log("Created local player:", localPlayer);
    
    // Create managers
    bulletManager = new ClientBulletManager(10000);
    enemyManager = new ClientEnemyManager(1000);
    
    // Make bulletManager available in console for debugging
    window.bulletManager = bulletManager;
    
    // Create map manager first (before network manager)
    mapManager = new ClientMapManager({});
    
    // IMPORTANT: Disable procedural generation to use server's map
    mapManager.proceduralEnabled = false;
    
    // Create network manager with proper handlers
    networkManager = new ClientNetworkManager(SERVER_URL, {
        // Get client ID from server
        setClientId: (clientId) => {
            console.log(`[setClientId] Received client ID from server: ${clientId}`);
            
            // Set the ID for the local player
            localPlayer.id = clientId;
            
            // IMPORTANT: Store this ID in multiple places to ensure consistency
            // This is critical for proper player filtering
            playerManager.setLocalPlayerId(clientId);
            
            // If we have a character in gameState, also ensure its ID matches
            if (gameState.character) {
                gameState.character.id = clientId;
                console.log(`[setClientId] Updated gameState.character.id to ${clientId}`);
            }
            
            // Log confirmation of ID setting
            console.log(`[setClientId] Local player ID set to: ${clientId}`);
            
            // Debug check - print the player list to verify filtering will work
            console.log(`[setClientId] Current players in playerManager: ${Array.from(playerManager.players.keys()).join(', ')}`);
        },
        
        onConnect: () => {
            console.log("Connected to server");
            gameState.isConnected = true;
        },
        
        onDisconnect: () => {
            console.log("Disconnected from server");
            gameState.isConnected = false;
        },
        [MessageType.PLAYER_LIST]: (data) => {
            // Log raw data first
            console.log(`[PLAYER_LIST] Raw data received: ${JSON.stringify(data)}`);
            console.log(`[PLAYER_LIST] Player IDs in raw data: ${Object.keys(data).join(', ')}`);
            console.log(`[PLAYER_LIST] Local player ID: ${localPlayer.id}`);
            
            // Check if data is already the players object or if it contains a players property
            let playersData = data;
            
            // Make sure we're working with the correct format
            // The server might send { players: {...} } or just {...}
            if (data.players && typeof data.players === 'object') {
                playersData = data.players;
                console.log(`[PLAYER_LIST] Found nested players object with ${Object.keys(playersData).length} players`);
            }
            
            // Filter out the local player to avoid the ghost sprite issue
            if (playersData && typeof playersData === 'object' && localPlayer) {
                // Create a copy of the data without the local player
                const filteredData = { ...playersData };
                
                // Remove local player from the data if it exists
                if (filteredData[localPlayer.id]) {
                    delete filteredData[localPlayer.id];
                    console.log(`[PLAYER_LIST] Filtered out local player (${localPlayer.id}) from player list update`);
                }
                
                // Log remaining players after filtering
                console.log(`[PLAYER_LIST] Remaining players after filtering: ${Object.keys(filteredData).join(', ')}`);
                
                // Update players with the filtered data if there are any players left
                if (Object.keys(filteredData).length > 0) {
                    updatePlayers(filteredData);
                } else {
                    console.log(`[PLAYER_LIST] No other players to update after filtering out local player`);
                }
            } else {
                // If something's wrong with the data, use it as is
                console.log(`[PLAYER_LIST] Using raw data as fallback`);
                updatePlayers(data);
            }
        },
        // Initialize map
        initMap: (mapData) => {
            console.log("Received map data from server:", mapData);
            mapManager.initMap(mapData);
        },
        
        // Set all players
        setPlayers: (players) => {
            console.log('Players received:', players);
            
            // Filter out the local player to avoid the ghost sprite issue
            if (players && typeof players === 'object' && localPlayer) {
                // Create a copy of the data without the local player
                const filteredPlayers = { ...players };
                
                // Remove local player from the data if it exists
                if (filteredPlayers[localPlayer.id]) {
                    delete filteredPlayers[localPlayer.id];
                    console.log(`Filtered out local player (${localPlayer.id}) from setPlayers update`);
                }
                
                // Update players with the filtered data
                updatePlayers(filteredPlayers);
            } else {
                // If something's wrong with the data, use it as is
                updatePlayers(players);
            }
        },
        
        // Set initial enemies
        setEnemies: (enemies) => {
            console.log(`Received ${enemies.length} enemies from server`);
            enemyManager.setEnemies(enemies);
        },
        
        // Set initial bullets
        setBullets: (bullets) => {
            console.log(`Received ${bullets.length} bullets from server`);
            bulletManager.setBullets(bullets);
        },
        
        // Update world state
        updateWorld: (enemies, bullets, players) => {
            // Only log world updates occasionally to reduce console spam
            if (Math.random() < 0.05) {
                console.log(`World update: ${enemies?.length || 0} enemies, ${bullets?.length || 0} bullets, ${players ? Object.keys(players).length : 0} players`);
                
                // When logging, also show all player IDs
                if (players && typeof players === 'object') {
                    console.log(`[updateWorld] Player IDs in update: ${Object.keys(players).join(', ')}`);
                    console.log(`[updateWorld] Local player ID: ${localPlayer.id}`);
                }
            }
            
            // Update game entities
            if (enemies) enemyManager.updateEnemies(enemies);
            if (bullets) bulletManager.updateBullets(bullets);
            
            // Check if we actually got player data
            if (!players || typeof players !== 'object') {
                if (Math.random() < 0.05) {
                    console.log(`[updateWorld] No valid player data received`);
                }
                return;
            }
            
            // Check if players object is empty
            if (Object.keys(players).length === 0) {
                if (Math.random() < 0.05) {
                    console.log(`[updateWorld] Received empty players object`);
                }
                return;
            }
            
            // Filter out local player from world updates to avoid ghost sprites
            if (localPlayer) {
                // Create a copy of players without the local player
                const filteredPlayers = { ...players };
                
                // Convert to strings for comparison to avoid type issues
                const localPlayerId = String(localPlayer.id);
                
                // Remove local player from the data if it exists
                for (const id of Object.keys(filteredPlayers)) {
                    if (String(id) === localPlayerId) {
                        delete filteredPlayers[id];
                        
                        // Log filtering occasionally
                        if (Math.random() < 0.05) {
                            console.log(`[updateWorld] Filtered out local player (${id}) from update`);
                        }
                        break; // Only one local player should exist
                    }
                }
                
                // Log remaining players occasionally
                if (Math.random() < 0.05) {
                    console.log(`[updateWorld] Remaining players after filtering: ${Object.keys(filteredPlayers).join(', ')}`);
                }
                
                // Only update if we have players
                if (Object.keys(filteredPlayers).length > 0) {
                    updatePlayers(filteredPlayers);
                } else {
                    if (Math.random() < 0.05) {
                        console.log("[updateWorld] No other players to update after filtering");
                    }
                }
            } else {
                // No local player reference, can't filter properly
                console.warn("[updateWorld] No localPlayer reference, sending unfiltered data");
                updatePlayers(players);
            }
        },
        
        // Add a bullet
        addBullet: (bullet) => {
            console.log("Server created bullet:", bullet);
            bulletManager.addBullet(bullet);
        },
        
        // Apply collision
        applyCollision: (collision) => {
            console.log("Processing collision:", collision);
            // Handle collision result
            bulletManager.removeBulletById(collision.bulletId);
            
            if (collision.enemyId) {
                enemyManager.setEnemyHealth(collision.enemyId, collision.enemyHealth);
                
                if (collision.enemyKilled) {
                    console.log(`Enemy ${collision.enemyId} was killed`);
                }
            }
        },
        
        // Set chunk data
        setChunkData: (chunkX, chunkY, chunkData) => {
            console.log(`Received chunk data for (${chunkX}, ${chunkY})`, chunkData);
            mapManager.setChunkData(chunkX, chunkY, chunkData);
        }
    });
    
    // Now that network manager is created, set it in the map manager
    mapManager.networkManager = networkManager;
    
    // Create collision manager
    collisionManager = new ClientCollisionManager({
        bulletManager: bulletManager,
        enemyManager: enemyManager,
        mapManager: mapManager,
        networkManager: networkManager,
        localPlayerId: localPlayer.id
    });
    
    // Update gameState with references
    gameState.character = localPlayer;
    gameState.map = mapManager;
    gameState.networkManager = networkManager;
    gameState.bulletManager = bulletManager;
    gameState.enemyManager = enemyManager;
    gameState.collisionManager = collisionManager;
    gameState.playerManager = playerManager;
    
    // Set the local player ID in the player manager
    // IMPORTANT: This prevents the local player from being rendered twice
    playerManager.setLocalPlayerId(localPlayer.id);
    
    console.log("Game state initialized with all managers");
}

/**
 * Connect to the game server
 * @returns {Promise} Resolves when connected
 */
async function connectToServer() {
    try {
        console.log(`Attempting to connect to server at ${SERVER_URL}`);
        await networkManager.connect();
        if (window.updateConnectionStatus) {
            window.updateConnectionStatus('Connected');
        }
        console.log("Connection to server successful");
        return true;
    } catch (error) {
        console.error('Connection error:', error);
        if (window.updateConnectionStatus) {
            window.updateConnectionStatus('Disconnected');
        }
        throw error;
    }
}

/**
 * Handle window resize
 */
function handleResize() {
    const canvas2D = document.getElementById('gameCanvas');

    canvas2D.width = window.innerWidth;
    canvas2D.height = window.innerHeight;

    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    console.log('Renderer and camera updated on window resize.');
}

/**
 * Main game loop
 */
function gameLoop(time) {
    const delta = (time - lastTime) / 1000; // Convert to seconds
    lastTime = time;

    // Limit delta to avoid large jumps on tab switch or slowdown
    const cappedDelta = Math.min(delta, 0.1);
    
    update(cappedDelta);
    render();
    
    // Update debug overlay
    debugOverlay.update(gameState, time);

    requestAnimationFrame(gameLoop);
}

/**
 * Update game state
 * @param {number} delta - Time elapsed since last frame in seconds
 */
function update(delta) {
    // Update local player
    updateCharacter(delta);
    
    // Update other players position interpolation (for smooth movement)
    updatePlayerInterpolation(delta);
    
    // Update bullet positions
    gameState.bulletManager.update(delta);
    
    // Update game elements
    enemyManager.update(delta);
    
    // Update map visible chunks based on player position
    // Use different strategies based on view type to prevent flickering
    if (mapManager) {
        const viewType = gameState.camera.viewType;
        
        if (viewType === 'strategic') {
            // For strategic view, update chunks less frequently
            // This is now handled in renderStrategic.js directly
            // Do not update chunks here to prevent flickering
        } else if (viewType === 'top-down') {
            // For top-down view, update chunks at regular rate
            // This view shows fewer chunks so network requests are less problematic
            mapManager.updateVisibleChunks(gameState.character.x, gameState.character.y);
        } else {
            // First-person view
            mapManager.updateVisibleChunks(gameState.character.x, gameState.character.y);
        }
    }
    
    // Update collision detection
    if (collisionManager) {
        collisionManager.update(delta);
    }
    
    // Send player update to server
    if (networkManager && networkManager.isConnected()) {
        // Handle either rotation as an object with yaw or as a simple number
        const rotation = typeof gameState.character.rotation === 'object' ?
                         gameState.character.rotation.yaw || 0 :
                         gameState.character.rotation;
                         
        networkManager.sendPlayerUpdate({
            x: gameState.character.x,
            y: gameState.character.y,
            rotation: rotation,
            health: gameState.character.health
        });
    }

    // Update camera position based on character's position
    if (gameState.camera.viewType === 'first-person') {
        updateFirstPerson(camera);
    } else {
        gameState.camera.updatePosition({ x: gameState.character.x, y: gameState.character.y });
    }
}

/**
 * Render the game
 */
function render() {
    const viewType = gameState.camera.viewType;

    if (viewType === 'first-person') {
        renderer.render(scene, camera);
        document.getElementById('gameCanvas').style.display = 'none';
        document.getElementById('glCanvas').style.display = 'block';
    } else {
        // For top-down and strategic views
        document.getElementById('gameCanvas').style.display = 'block';
        document.getElementById('glCanvas').style.display = 'none';
        
        // Use the main render function from render.js
        // This handles clearing the canvas and rendering all entities
        renderGame();
    }
}

/**
 * Handle shooting
 * @param {number} x - X coordinate
 * @param {number} y - Y coordinate
 */
export function handleShoot(x, y) {
    if (!networkManager || !networkManager.isConnected()) {
        console.log("Cannot shoot: network manager not connected");
        return;
    }
    
    // Check if player can shoot
    if (typeof localPlayer.canShoot === 'function' && !localPlayer.canShoot()) {
        console.log("Cannot shoot: on cooldown");
        return; // On cooldown or other restriction
    }
    
    // Debug: Log target coordinates
    console.log(`[handleShoot] Shooting at target coordinates: (${x.toFixed(2)}, ${y.toFixed(2)})`);
    console.log(`[handleShoot] Player position: (${gameState.character.x.toFixed(2)}, ${gameState.character.y.toFixed(2)})`);
    
    // Calculate angle from player to target
    const dx = x - gameState.character.x;
    const dy = y - gameState.character.y;
    const angle = Math.atan2(dy, dx);
    
    // Debug: Log targeting details
    console.log(`[handleShoot] Delta: (${dx.toFixed(2)}, ${dy.toFixed(2)}), Angle: ${angle.toFixed(2)} rad (${(angle * 180 / Math.PI).toFixed(1)})`);
    
    // CRITICAL FIX: Get direction from angle BEFORE starting attack animation
    let attackDirection = 0; // default to down
    
    // Set the player's direction based on the shooting angle
    if (gameState.character.animator && typeof gameState.character.animator.setDirectionFromAngle === 'function') {
        // First, update the animator's direction without starting the animation
        gameState.character.animator.setDirectionFromAngle(angle);
        
        // Save the direction for the attack
        attackDirection = gameState.character.animator.direction;
        console.log(`[handleShoot] Attack direction set to: ${attackDirection} (${['down', 'left', 'up', 'right'][attackDirection]})`);
    } else {
        console.log(`[handleShoot] Warning: Cannot set direction, animator not available or method missing`);
    }
    
    // Update player's last shot time and trigger attack animation
    if (typeof localPlayer.setLastShotTime === 'function') {
        // Skip animation in setLastShotTime since we'll trigger it explicitly
        localPlayer.setLastShotTime(Date.now(), true);
        
        // Also explicitly start the attack animation if available
        if (localPlayer.animator && typeof localPlayer.animator.attack === 'function') {
            console.log(`[handleShoot] Explicitly triggering attack animation with direction: ${attackDirection}`);
            localPlayer.animator.attack(attackDirection);
        }
    }
    
    // Create a local bullet prediction
    const bulletData = {
        x: gameState.character.x,
        y: gameState.character.y,
        vx: Math.cos(angle) * (gameState.character.projectileSpeed * 0.3), // Slower speed (changed from 0.5 to 0.3)
        vy: Math.sin(angle) * (gameState.character.projectileSpeed * 0.3), // Slower speed (changed from 0.5 to 0.3)
        ownerId: gameState.character.id,
        damage: gameState.character.damage || 10,
        lifetime: 6.0, // Double the lifetime for better visibility (was 3.0)
        width: 12, // Larger size for better visibility
        height: 12, // Larger size for better visibility
        // Add sprite info
        spriteSheet: 'bullet_sprites',
        spriteX: 8 * 10, // X position in sprite sheet (col * width)
        spriteY: 8 * 11, // Y position in sprite sheet (row * height)
        spriteWidth: 8,
        spriteHeight: 8
    };
    
    console.log("Creating bullet with data:", bulletData);
    const bulletId = bulletManager.addBullet(bulletData);
    
    // Send to server
    networkManager.sendShoot({
        x: gameState.character.x,
        y: gameState.character.y,
        angle,
        speed: gameState.character.projectileSpeed * 0.3, // Match the slower speed (changed from 0.5 to 0.3)
        damage: gameState.character.damage || 10
    });
    
    console.log(`Created bullet ${bulletId} with angle ${angle.toFixed(2)}`);
}

/**
 * Report a collision to the server
 * @param {string} bulletId - Bullet ID
 * @param {string} enemyId - Enemy ID
 */
export function reportCollision(bulletId, enemyId) {
    if (!networkManager || !networkManager.isConnected()) {
        console.log("Cannot report collision: network manager not connected");
        return;
    }
    
    console.log(`Reporting collision between bullet ${bulletId} and enemy ${enemyId}`);
    
    networkManager.sendCollision({
        bulletId: bulletId,
        enemyId: enemyId,
        timestamp: Date.now()
    });
}

// Debug function to spawn a test player
function spawnTestPlayer() {
    if (!playerManager) {
        console.error("Cannot spawn test player: playerManager not available");
        return;
    }
    
    // Generate a random ID that won't conflict with real player IDs
    const testId = 'test-' + Math.floor(Math.random() * 9999);
    
    // Create test player data at a position offset from the local player
    const testPlayerData = {
        id: testId,
        x: gameState.character.x + (Math.random() * 10) - 5,
        y: gameState.character.y + (Math.random() * 10) - 5,
        health: 100,
        maxHealth: 100,
        name: "Test Player",
        // Match local player dimensions
        width: 10,
        height: 10,
        // Use the same sprite as the local player
        spriteX: 0,
        spriteY: 0,
        rotation: 0,
        lastUpdate: Date.now()
    };
    
    // Add to playerManager
    playerManager.players.set(testId, testPlayerData);
    console.log(`Created test player ${testId} at (${testPlayerData.x.toFixed(1)}, ${testPlayerData.y.toFixed(1)})`);
    console.log(`Player manager now has ${playerManager.players.size} other players`);
}

/**
 * Debug function to dump player information
 */
function debugDumpPlayerInfo() {
    console.log('===== PLAYER DEBUG INFO =====');
    console.log(`Local player: ID=${localPlayer?.id}, position=(${localPlayer?.x?.toFixed(1)}, ${localPlayer?.y?.toFixed(1)})`);
    console.log(`Character ID in gameState: ${gameState.character?.id}`);
    console.log(`PlayerManager local ID: ${playerManager.localPlayerId}`);
    console.log(`Number of other players: ${playerManager.players.size}`);
    
    if (playerManager.players.size > 0) {
        console.log('Other players:');
        playerManager.players.forEach((player, id) => {
            console.log(`  - ID=${id}, position=(${player.x?.toFixed(1)}, ${player.y?.toFixed(1)}), last update: ${new Date(player.lastUpdate).toISOString()}`);
        });
    } else {
        console.log('No other players currently tracked');
        
        // Try to manually create a test player to help diagnose rendering issues
        console.log('Creating test player for diagnostic purposes...');
        spawnTestPlayer();
        console.log('After adding test player, player count is now: ' + playerManager.players.size);
    }
    
    // Add test for string vs number ID comparison
    if (localPlayer && localPlayer.id && playerManager.players.size > 0) {
        console.log('ID type diagnostics:');
        console.log(`Local player ID type: ${typeof localPlayer.id}`);
        
        const firstPlayerId = Array.from(playerManager.players.keys())[0];
        console.log(`First other player ID type: ${typeof firstPlayerId}`);
        
        const stringCompareMatch = String(localPlayer.id) === String(firstPlayerId);
        const directCompareMatch = localPlayer.id === firstPlayerId;
        
        console.log(`Direct comparison: ${directCompareMatch}, String comparison: ${stringCompareMatch}`);
    }
    
    // Add rendering test
    console.log("RENDERING TEST: Forcing render of all players...");
    console.log(`Players to render: ${playerManager.getPlayersForRender().length}`);
    
    // Enable visual debugging to make other players more obvious
    playerManager.visualDebug = true;
    console.log("Visual debugging enabled - other players will have magenta borders");
    
    console.log('=============================');
    
    // Return true to indicate diagnostic ran successfully
    return true;
}

// Add this function to request player list from server
function requestPlayerList() {
    if (!networkManager || !networkManager.isConnected()) {
        console.log("Cannot request player list: network manager not connected");
        return;
    }
    
    console.log("Requesting current player list from server...");
    
    // Check if networkManager has a direct method to request player list
    if (networkManager.requestPlayerList) {
        networkManager.requestPlayerList();
    } else {
        // Otherwise, try to get the player list indirectly
        console.log("No direct method to request player list. Trying ping to trigger server response...");
        if (networkManager.sendPing) {
            networkManager.sendPing();
        }
    }
    
    // Show current player info
    debugDumpPlayerInfo();
}

// =========================================
// FILE: public/src/game/gameManager.js
// =========================================

// public/src/game/GameManager.js

import { 
  ClientBulletManager,
  ClientEnemyManager,
  ClientNetworkManager as NetworkManager,
  ClientCollisionManager
} from '../managers.js';
import { SimpleCollisionSystem } from '../collision/SimpleCollisionSystem.js';
import { map } from '../map/map.js';
import { gameState } from './gamestate.js';

/**
 * GameManager - Coordinates game state, networking, and system integration
 */
export class GameManager {
  /**
   * Create a new game manager
   * @param {Object} options - Configuration options
   */
  constructor(options = {}) {
    // Initialize component managers
    this.bulletManager = new ClientBulletManager(options.maxBullets || 1000);
    this.enemyManager = new ClientEnemyManager(options.maxEnemies || 100);
    
    // Store references in gameState for global access
    gameState.bulletManager = this.bulletManager;
    gameState.enemyManager = this.enemyManager;
    
    // Initialize collision system
    this.collisionSystem = new SimpleCollisionSystem({
      bulletManager: this.bulletManager,
      enemyManager: this.enemyManager,
      mapManager: map
    });
    
    // Set up network manager if server URL provided
    this.serverUrl = options.serverUrl || 'ws://localhost:3000';
    this.networkManager = new NetworkManager(this.serverUrl, this);
    
    // Game state tracking
    this.clientId = null;
    this.players = {};
    this.isConnected = false;
    this.lastUpdateTime = 0;
    
    console.log('GameManager initialized');
  }
  
  /**
   * Connect to the game server
   * @returns {Promise} Resolves when connected
   */
  async connect() {
    try {
      await this.networkManager.connect();
      this.isConnected = true;
      console.log('Connected to game server');
      return true;
    } catch (error) {
      console.error('Failed to connect to game server:', error);
      return false;
    }
  }
  
  /**
   * Start the game
   */
  start() {
    // Connect to server if not already connected
    if (!this.isConnected) {
      this.connect().catch(error => {
        console.error('Error connecting to server:', error);
        // Continue in offline mode
        console.log('Running in offline mode');
      });
    }
    
    // Start the game loop
    this.lastUpdateTime = performance.now();
    requestAnimationFrame(this.update.bind(this));
    
    console.log('Game started');
  }
  
  /**
   * Main update loop
   * @param {number} timestamp - Current timestamp
   */
  update(timestamp) {
    // Calculate delta time in seconds
    const deltaTime = (timestamp - this.lastUpdateTime) / 1000;
    this.lastUpdateTime = timestamp;
    
    // Cap delta time to prevent large jumps
    const cappedDeltaTime = Math.min(deltaTime, 0.1);
    
    // Update local game state
    this.updateLocalState(cappedDeltaTime);
    
    // Send player update to server if connected
    if (this.isConnected) {
      this.sendPlayerUpdate();
    }
    
    // Continue the game loop
    requestAnimationFrame(this.update.bind(this));
  }
  
  /**
   * Update local game state
   * @param {number} deltaTime - Time elapsed since last update in seconds
   */
  updateLocalState(deltaTime) {
    // Update bullets
    this.bulletManager.update(deltaTime);
    
    // Update enemies
    this.enemyManager.update(deltaTime);
    
    // Update collision detection
    this.collisionSystem.update(deltaTime);
  }
  
  /**
   * Send player update to server
   */
  sendPlayerUpdate() {
    if (!this.networkManager.isConnected()) return;
    
    // Get player data from gameState
    const playerData = {
      x: gameState.character.x,
      y: gameState.character.y,
      rotation: gameState.character.rotation.yaw,
      health: gameState.character.health
    };
    
    // Send update
    this.networkManager.sendPlayerUpdate(playerData);
  }
  
  /**
   * Fire a bullet from the player
   * @param {number} angle - Firing angle in radians
   */
  firePlayerBullet(angle) {
    const character = gameState.character;
    
    // Create bullet data
    const bulletData = {
      x: character.x,
      y: character.y,
      vx: Math.cos(angle) * 300, // Speed of 300 units per second
      vy: Math.sin(angle) * 300,
      damage: 10,
      lifetime: 2.0,
      ownerId: this.clientId || 'local_player'
    };
    
    // Add bullet locally
    const bulletId = this.bulletManager.addBullet(bulletData);
    
    // Send to server if connected
    if (this.networkManager.isConnected()) {
      this.networkManager.sendShoot({
        x: bulletData.x,
        y: bulletData.y,
        angle: angle,
        speed: 300,
        damage: 10
      });
    }
    
    return bulletId;
  }
  
  /**
   * Set the client ID (called by NetworkManager)
   * @param {string} clientId - Client ID from server
   */
  setClientId(clientId) {
    this.clientId = clientId;
    console.log(`Set client ID: ${clientId}`);
  }
  
  /**
   * Initialize the game map
   * @param {Object} mapData - Map data from server
   */
  initMap(mapData) {
    // Store map metadata
    gameState.mapMetadata = mapData;
    
    console.log('Map initialized with data from server');
  }
  
  /**
   * Set initial players list
   * @param {Object} players - Players data from server
   */
  setPlayers(players) {
    this.players = players;
    console.log(`Received ${Object.keys(players).length} players from server`);
  }
  
  /**
   * Set initial enemies list
   * @param {Array} enemies - Enemies data from server
   */
  setEnemies(enemies) {
    this.enemyManager.setEnemies(enemies);
    console.log(`Set ${enemies.length} enemies from server`);
  }
  
  /**
   * Set initial bullets list
   * @param {Array} bullets - Bullets data from server
   */
  setBullets(bullets) {
    this.bulletManager.setBullets(bullets);
    console.log(`Set ${bullets.length} bullets from server`);
  }
  
  /**
   * Update world state from server data
   * @param {Array} enemies - Updated enemies data
   * @param {Array} bullets - Updated bullets data
   * @param {Object} players - Updated players data
   */
  updateWorld(enemies, bullets, players) {
    // Update enemies
    if (enemies && enemies.length > 0) {
      this.enemyManager.updateEnemies(enemies);
    }
    
    // Update bullets
    if (bullets && bullets.length > 0) {
      this.bulletManager.updateBullets(bullets);
    }
    
    // Update other players
    if (players) {
      this.players = players;
    }
  }
  
  /**
   * Add a new player
   * @param {Object} player - Player data
   */
  addPlayer(player) {
    this.players[player.id] = player;
    console.log(`Player added: ${player.id}`);
  }
  
  /**
   * Remove a player
   * @param {string} playerId - Player ID to remove
   */
  removePlayer(playerId) {
    delete this.players[playerId];
    console.log(`Player removed: ${playerId}`);
  }
  
  /**
   * Add a bullet
   * @param {Object} bulletData - Bullet data
   */
  addBullet(bulletData) {
    this.bulletManager.addBullet(bulletData);
  }
  
  /**
   * Apply collision result from server
   * @param {Object} data - Collision data
   */
  applyCollision(data) {
    const { bulletId, enemyId, damage, enemyHealth } = data;
    
    // Remove bullet
    this.bulletManager.removeBulletById(bulletId);
    
    // Update enemy health
    this.enemyManager.setEnemyHealth(enemyId, enemyHealth);
  }
  
  /**
   * Handle enemy killed event
   * @param {string} enemyId - ID of killed enemy
   */
  handleEnemyKilled(enemyId) {
    console.log(`Enemy killed: ${enemyId}`);
    // Potential place for score updates, effects, etc.
  }
  
  /**
   * Set chunk data for the map
   * @param {number} chunkX - Chunk X coordinate
   * @param {number} chunkY - Chunk Y coordinate
   * @param {Object} data - Chunk data
   */
  setChunkData(chunkX, chunkY, data) {
    // If map has a method to set chunk data, use it
    if (map.setChunkData) {
      map.setChunkData(chunkX, chunkY, data);
    }
  }
  
  /**
   * Generate a fallback chunk
   * @param {number} chunkX - Chunk X coordinate
   * @param {number} chunkY - Chunk Y coordinate
   */
  generateFallbackChunk(chunkX, chunkY) {
    console.log(`Generating fallback chunk for (${chunkX}, ${chunkY})`);
    // If map has a method to generate a fallback chunk, use it
    if (map.generateFallbackChunk) {
      map.generateFallbackChunk(chunkX, chunkY);
    }
  }
  
  /**
   * Handle disconnection from server
   */
  handleDisconnect() {
    this.isConnected = false;
    console.log('Disconnected from server, running in offline mode');
  }
}

export default GameManager;

// =========================================
// FILE: public/src/game/gamestate.js
// =========================================

// public/src/game/gamestate.js

import { Camera } from '../camera.js';
import { character } from '../entities/character.js';

/**
 * Game state object - holds references to all game components
 */
export const gameState = {
    // Core components
    character: character,
    camera: new Camera('top-down', { x: character.x, y: character.y }, 1),
    
    // Game managers - initialized in game.js
    networkManager: null,
    bulletManager: null, 
    enemyManager: null,
    map: null,
    collisionManager: null,
    playerManager: null,
    
    // Tracking info
    lastUpdateX: character.x,
    lastUpdateY: character.y,
    
    // Game status
    isConnected: false,
    isPaused: false,
    
    // Settings
    settings: {
        soundEnabled: true,
        musicEnabled: true,
        showFPS: false
    }
};

// =========================================
// FILE: public/src/game/input.js
// =========================================

// public/src/game/input.js

import { gameState } from './gamestate.js';
import { openSpriteEditor } from '../screens/spriteEditor.js';
import { handleShoot } from './game.js';
import { TILE_SIZE, SCALE } from '../constants/constants.js';
import { Camera } from '../camera.js';

// Track currently pressed keys
export const keysPressed = {};

// Mouse position
let mouseX = 0;
let mouseY = 0;

// Sensitivity and speed settings
const MOUSE_SENSITIVITY = 0.002;
const MOVE_SPEED = 100.0; // Increased movement speed for better responsiveness

/**
 * Initialize game controls
 */
export function initControls() {
    // Clear any existing key states
    Object.keys(keysPressed).forEach(key => delete keysPressed[key]);
    
    // Keyboard input
    window.addEventListener('keydown', (e) => {
        keysPressed[e.code] = true;
        // Remove excessive logging
        // console.log(`Key pressed: ${e.code}`); // Debug log

        // Handle view switching with 'V' key
        if (e.code === 'KeyV') {
            switchView();
            e.preventDefault();
        }
        
        // Sprite editor with 'E' key
        if (e.code === 'KeyE') {
            e.preventDefault();
            openSpriteEditor();
        }
        
        // Add spacebar to also trigger shooting
        if (e.code === 'Space') {
            // Shoot in the direction the player is facing
            const rotation = typeof gameState.character.rotation === 'object' ?
                   gameState.character.rotation.yaw || 0 :
                   gameState.character.rotation;
                   
            const distance = 100; // Distance ahead of the player to aim
            const targetX = gameState.character.x + Math.cos(rotation) * distance;
            const targetY = gameState.character.y + Math.sin(rotation) * distance;
            
            handleShoot(targetX, targetY);
        }

        // Add F3 key to toggle debug mode
        if (e.code === 'F3') {
          if (gameState.camera) {
            const debugEnabled = gameState.camera.toggleDebugMode();
            console.log(`Debug mode ${debugEnabled ? 'enabled' : 'disabled'}`);
            
            // Also toggle debug overlay if it exists
            if (window.debugOverlay && typeof window.debugOverlay.toggle === 'function') {
              window.debugOverlay.toggle();
            }
          }
        }
    });

    window.addEventListener('keyup', (e) => {
        keysPressed[e.code] = false;
    });

    // Mouse movement for camera rotation in first-person view
    window.addEventListener('click', (e) => {
        if (gameState.camera.viewType === 'first-person') {
            const canvas = document.getElementById('glCanvas');
            if (document.pointerLockElement !== canvas) {
                canvas.requestPointerLock();
            }
        } else {
            // Handle shooting in top-down view
            handleMouseClick(e);
        }
    });

    // Track mouse position
    window.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
        
        // Only update rotation when in first-person view
        if (gameState.camera.viewType === 'first-person') {
            // This will be handled by the onMouseMove function
        }
        // Removed automatic rotation for top-down view
    });

    // Handle pointer lock for first-person mode
    document.addEventListener('pointerlockchange', () => {
        const canvas = document.getElementById('glCanvas');
        if (document.pointerLockElement === canvas) {
            document.addEventListener('mousemove', onMouseMove, false);
        } else {
            document.removeEventListener('mousemove', onMouseMove, false);
        }
    });

    // Add mouse click event for shooting
    window.addEventListener('click', (e) => {
        // Only handle clicks on canvas
        const targetId = e.target.id;
        if (targetId !== 'gameCanvas' && targetId !== 'glCanvas') {
            return;
        }
        
        console.log("Mouse click detected");
        
        // Get click position in game world
        const rect = e.target.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;
        
        // Convert to world coordinates based on view type
        let worldX, worldY;
        
        if (gameState.camera.viewType === 'first-person') {
            // In first-person view, shoot forward
            const cameraDir = gameState.camera.getDirection();
            worldX = gameState.character.x + cameraDir.x * 100;
            worldY = gameState.character.y + cameraDir.y * 100;
        } else {
            // In other views, convert screen coordinates to world coordinates
            worldX = clickX + gameState.camera.x;
            worldY = clickY + gameState.camera.y;
        }
        
        // Handle shooting
        handleShoot(worldX, worldY);
    });

    // Add touch event listener for trackpad support
    window.addEventListener('touchstart', (e) => {
        // Prevent default to avoid scrolling
        e.preventDefault();
        
        // Get touch position
        const touch = e.touches[0];
        const targetId = e.target.id;
        if (targetId !== 'gameCanvas' && targetId !== 'glCanvas') {
            return;
        }
        
        // Get click position in game world
        const rect = e.target.getBoundingClientRect();
        const touchX = touch.clientX - rect.left;
        const touchY = touch.clientY - rect.top;
        
        // Convert to world coordinates 
        let worldX, worldY;
        
        if (gameState.camera.viewType === 'first-person') {
            // In first-person, shoot forward
            const cameraDir = gameState.camera.getDirection();
            worldX = gameState.character.x + cameraDir.x * 100;
            worldY = gameState.character.y + cameraDir.y * 100;
        } else {
            // In other views, convert screen coordinates to world coordinates
            worldX = touchX + gameState.camera.x;
            worldY = touchY + gameState.camera.y;
        }
        
        // Handle shooting
        handleShoot(worldX, worldY);
    }, { passive: false });
}

/**
 * Handle mouse movement for first-person camera
 * @param {MouseEvent} event - Mouse event
 */
function onMouseMove(event) {
    const sensitivity = MOUSE_SENSITIVITY;
    gameState.character.rotation.yaw -= event.movementX * sensitivity;
    gameState.character.rotation.pitch -= event.movementY * sensitivity;

    // Clamp the pitch to prevent flipping
    gameState.character.rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, gameState.character.rotation.pitch));
}

/**
 * Update player rotation to face mouse cursor in top-down view
 * @param {MouseEvent} event - Mouse event
 */

/**
 * Handle mouse click
 * @param {MouseEvent} event - Mouse event
 */
function handleMouseClick(event) {
    // Only allow shooting if not in first-person view
    if (gameState.camera.viewType === 'first-person') return;
    
    // Check if player can shoot
    if (gameState.character.canShoot && !gameState.character.canShoot()) {
        return;
    }
    
    // Convert screen position to world position
    const canvas = document.getElementById('gameCanvas');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    // Calculate target position using camera position and mouse offset
    const targetX = gameState.character.x + (event.clientX - centerX) / (TILE_SIZE * SCALE);
    const targetY = gameState.character.y + (event.clientY - centerY) / (TILE_SIZE * SCALE);
    
    // Call shoot handler
    handleShoot(targetX, targetY);
}

/**
 * Switch between view modes (top-down, first-person, strategic)
 */
function switchView() {
    // Call the enhanced debugging function we defined
    toggleViewMode();
    
    // Toggle the canvas visibility
    toggleViews();
    
    // Log available render functions for debugging
    console.log(`[switchView] Render functions available:
    - Top-down: ${typeof window.renderTopDownView === 'function'}
    - Strategic: ${typeof window.renderStrategicView === 'function'}
    Current view: ${gameState.camera.viewType}`);
}

/**
 * Toggle between 2D and 3D canvases
 */
function toggleViews() {
    const canvas2D = document.getElementById('gameCanvas');
    const canvas3D = document.getElementById('glCanvas');

    if (gameState.camera.viewType === 'first-person') {
        canvas2D.style.display = 'none';
        canvas3D.style.display = 'block';
    } else {
        canvas2D.style.display = 'block';
        canvas3D.style.display = 'none';
    }
}

/**
 * Get currently pressed keys
 * @returns {Object} Keys pressed state
 */
export function getKeysPressed() {
    return keysPressed;
}

/**
 * Get movement speed
 * @returns {number} Movement speed
 */
export function getMoveSpeed() {
    return MOVE_SPEED;
}

/**
 * Get current mouse position
 * @returns {Object} Mouse position {x, y}
 */
export function getMousePosition() {
    return { x: mouseX, y: mouseY };
}

/**
 * Handle view mode switching
 * Most likely toggles between first-person, top-down, and strategic views
 * Add debug logging to help diagnose view switching issues
 */
function toggleViewMode() {
  if (!gameState.camera) {
    console.error("Cannot toggle view: gameState.camera is not defined");
    return;
  }
  
  const currentView = gameState.camera.viewType;
  console.log(`[input] Toggling view from: ${currentView}`);
  
  // Cycle through view types
  if (gameState.camera.viewType === 'first-person') {
    gameState.camera.viewType = 'top-down';
    
    console.log(`[input] Switched to top-down view. render function available: ${typeof window.renderTopDownView === 'function'}`);
  } else if (gameState.camera.viewType === 'top-down') {
    gameState.camera.viewType = 'strategic';
    console.log(`[input] Switched to strategic view. render function available: ${typeof window.renderStrategicView === 'function'}`);
  } else {
    gameState.camera.viewType = 'first-person';
    console.log(`[input] Switched to first-person view`);
  }
  
  console.log(`[input] New view type: ${gameState.camera.viewType}`);
}

// =========================================
// FILE: public/src/game/updateCharacter.js
// =========================================

// src/game/updateCharacter.js

import { getKeysPressed, getMoveSpeed } from './input.js';
import { gameState } from './gamestate.js';
import { TILE_SIZE, TILE_IDS } from '../constants/constants.js';

/**
 * Updates the character's position based on input and handles collision.
 * @param {number} delta - Time elapsed since the last frame (in seconds).
 */
export function updateCharacter(delta) {
  const character = gameState.character;
  const speed = getMoveSpeed(); // Get speed from input settings
  const keysPressed = getKeysPressed();

  // Calculate movement direction
  let moveX = 0;
  let moveY = 0;

  // Process WASD or arrow keys
  if (keysPressed['KeyW'] || keysPressed['ArrowUp']) {
    moveY -= 1;
  }
  if (keysPressed['KeyS'] || keysPressed['ArrowDown']) {
    moveY += 1;
  }
  if (keysPressed['KeyA'] || keysPressed['ArrowLeft']) {
    moveX -= 1;
  }
  if (keysPressed['KeyD'] || keysPressed['ArrowRight']) {
    moveX += 1;
  }

  // Normalize diagonal movement
  if (moveX !== 0 && moveY !== 0) {
    const length = Math.sqrt(moveX * moveX + moveY * moveY);
    moveX /= length;
    moveY /= length;
  }

  // CRITICAL FIX: Force a clean state change when stopping movement
  const isMoving = (moveX !== 0 || moveY !== 0);
  const wasMoving = character.isMoving;
  
  // Update character's movement state
  character.isMoving = isMoving;
  
  // When stopping movement, zero out the movement direction
  if (!isMoving) {
    character.moveDirection = { x: 0, y: 0 };
    
    // CRITICAL FIX: Force the animator to reset to idle directly
    if (wasMoving && character.animator && character.animator.resetToIdle) {
      character.animator.resetToIdle();
    }
  } else {
    // Update move direction when actually moving
    character.moveDirection = { x: moveX, y: moveY };
    
    // CRITICAL FIX: Force animation state to WALK when starting to move
    if (!wasMoving && character.animator && character.animator.states && character.animator.setCurrentState) {
      character.animator.setCurrentState(character.animator.states.WALK);
    }
  }

  // Call the character's update method to handle cooldowns and animation
  if (character.update && typeof character.update === 'function') {
    character.update(delta);
  }

  // Original position before movement
  const originalX = character.x;
  const originalY = character.y;

  // Apply movement with delta time
  if (isMoving) {
    const distance = speed * delta;
    
    // First try moving along X axis
    const newX = character.x + moveX * distance;
    
    if (!isCollision(newX, character.y)) {
      character.x = newX;
    } else {
      // Try with smaller increments to handle edge cases
      const smallStep = Math.sign(moveX) * Math.min(Math.abs(moveX * distance), 0.1);
      const stepX = character.x + smallStep;
      if (!isCollision(stepX, character.y)) {
        character.x = stepX;
      }
    }
    
    // Now try moving along Y axis
    const newY = character.y + moveY * distance;
    if (!isCollision(character.x, newY)) {
      character.y = newY;
    } else {
      // Try with smaller increments
      const smallStep = Math.sign(moveY) * Math.min(Math.abs(moveY * distance), 0.1);
      const stepY = character.y + smallStep;
      if (!isCollision(character.x, stepY)) {
        character.y = stepY;
      }
    }
    
    // If we moved, log the new position
    if (Math.abs(character.x - originalX) > 0.001 || Math.abs(character.y - originalY) > 0.001) {
      // Only log position every 10 units to avoid spam
      if (Math.floor(character.x) % 10 === 0 && Math.floor(character.y) % 10 === 0) {
        console.log(`Position: (${character.x.toFixed(2)}, ${character.y.toFixed(2)})`);
      }
    }
  }
}

/**
 * Checks if the position collides with a wall or is out of bounds
 * @param {number} x - New X position
 * @param {number} y - New Y position
 * @returns {boolean} - True if collision occurs, else false
 */
function isCollision(x, y) {
  // Skip collision if map manager isn't available
  if (!gameState.map) {
    return false;
  }
  
  // Character dimensions (use properties if available, otherwise use defaults)
  const width = gameState.character.width || 20;
  const height = gameState.character.height || 20;
  
  // Check multiple points on the character's body for collisions
  // Center
  if (isPointColliding(x, y)) return true;
  
  // Check corners (adjusted to be slightly inset from the edges)
  const inset = 2; // Inset from edges to avoid getting stuck
  const halfWidth = width / 2 - inset;
  const halfHeight = height / 2 - inset;
  
  // Top-left corner
  if (isPointColliding(x - halfWidth, y - halfHeight)) return true;
  
  // Top-right corner
  if (isPointColliding(x + halfWidth, y - halfHeight)) return true;
  
  // Bottom-left corner
  if (isPointColliding(x - halfWidth, y + halfHeight)) return true;
  
  // Bottom-right corner
  if (isPointColliding(x + halfWidth, y + halfHeight)) return true;
  
  // No collision detected
  return false;
}

/**
 * Checks if a specific point collides with a wall
 * @param {number} x - X position to check
 * @param {number} y - Y position to check
 * @returns {boolean} True if point collides with a wall
 */
function isPointColliding(x, y) {
  // Convert to tile coordinates
  const tileX = Math.floor(x / TILE_SIZE);
  const tileY = Math.floor(y / TILE_SIZE);
  
  try {
    // Check if position is a wall or obstacle
    if (gameState.map.isWallOrObstacle) {
      return gameState.map.isWallOrObstacle(x, y);
    }
    
    // Fallback to checking tile directly
    const tile = gameState.map.getTile(tileX, tileY);
    if (!tile) {
      // No tile found (out of bounds)
      return true;
    }
    
    // Check if it's a wall, obstacle, or mountain
    return (
      tile.type === TILE_IDS.WALL || 
      tile.type === TILE_IDS.OBSTACLE || 
      tile.type === TILE_IDS.MOUNTAIN ||
      tile.type === TILE_IDS.WATER
    );
  } catch (error) {
    console.error("Error in collision detection:", error);
    // On error, default to no collision
    return false;
  }
}

// =========================================
// FILE: public/src/managers.js
// =========================================

/**
 * Centralized manager exports
 * This file re-exports all manager classes to avoid case sensitivity issues
 */

// Re-export all managers with consistent naming
export { ClientMapManager } from './map/ClientMapManager.js';
export { ClientNetworkManager, MessageType } from './network/ClientNetworkManager.js';
export { ClientBulletManager } from './game/ClientBulletManager.js';
export { ClientEnemyManager } from './game/ClientEnemyManager.js';
export { ClientCollisionManager } from './collision/ClientCollisionManager.js';

// Other important exports
export { debugOverlay } from './ui/DebugOverlay.js'; 

// =========================================
// FILE: public/src/map/PerlinNoise.js
// =========================================

// src/map/perlinNoise.js

export class PerlinNoise {
  constructor(seed = Math.random()) {
    this.seed = seed;
    this.gradients = {};
    this.memory = {};
  }

  // Generate a random gradient vector
  randomGradient(ix, iy) {
    const random = 2920 * Math.sin(ix * 21942 + iy * 171324 + this.seed * 8912) *
                  Math.cos(ix * 23157 * iy * 217832 + this.seed * 9758);
    return { x: Math.cos(random), y: Math.sin(random) };
  }

  // Dot product of the distance and gradient vectors
  dotGridGradient(ix, iy, x, y) {
    const gradient = this.gradients[[ix, iy]] || (this.gradients[[ix, iy]] = this.randomGradient(ix, iy));

    const dx = x - ix;
    const dy = y - iy;

    return dx * gradient.x + dy * gradient.y;
  }

  // Interpolation function
  lerp(a0, a1, w) {
    return (1 - w) * a0 + w * a1;
  }

  // Compute Perlin noise at coordinates x, y
  get(x, y) {
    const x0 = Math.floor(x);
    const x1 = x0 + 1;
    const y0 = Math.floor(y);
    const y1 = y0 + 1;

    // Interpolation weights
    const sx = x - x0;
    const sy = y - y0;

    // Interpolate between grid point gradients
    const n0 = this.dotGridGradient(x0, y0, x, y);
    const n1 = this.dotGridGradient(x1, y0, x, y);
    const ix0 = this.lerp(n0, n1, sx);

    const n2 = this.dotGridGradient(x0, y1, x, y);
    const n3 = this.dotGridGradient(x1, y1, x, y);
    const ix1 = this.lerp(n2, n3, sx);

    const value = this.lerp(ix0, ix1, sy);
    return value;
  }
}

export const perlin = new PerlinNoise(); // Instantiate with a random seed


// =========================================
// FILE: public/src/map/clientMapManager.js
// =========================================

// public/src/map/ClientMapManager.js

import { Tile } from './tile.js';
import { TILE_IDS, CHUNK_SIZE } from '../constants/constants.js';
import { gameState } from '../game/gamestate.js';

/**
 * ClientMapManager - Handles loading, caching, and rendering map data from server
 */
export class ClientMapManager {
    /**
     * Create a new client map manager
     * @param {Object} options - Manager options
     * @param {NetworkManager} options.networkManager - Network manager for map data requests
     */
    constructor(options = {}) {
        this.networkManager = options.networkManager;
        this.activeMapId = null;
        this.mapMetadata = null;
        this.chunks = new Map(); // Chunk cache: "x,y" -> chunk data
        this.tileSize = 12; // Default tile size
        this.chunkSize = 16; // Default chunk size
        this.width = 0;
        this.height = 0;
        this.visibleChunks = []; // Currently visible chunks
        this.pendingChunks = new Set(); // Chunks we're currently requesting
        this.maxCachedChunks = 100; // Maximum chunks to keep in memory
        this.chunkLoadDistance = 2; // How many chunks to load around player
        
        // CRITICAL: Default to false to use server's map data
        this.proceduralEnabled = false;
        
        this.fallbackTileTypes = {
            [TILE_IDS.FLOOR]: 'floor',
            [TILE_IDS.WALL]: 'wall',
            [TILE_IDS.OBSTACLE]: 'obstacle',
            [TILE_IDS.WATER]: 'water',
            [TILE_IDS.MOUNTAIN]: 'mountain'
        };
        
        // LRU (Least Recently Used) tracking for chunk cache
        this.chunkLastAccessed = new Map(); // "x,y" -> timestamp
        
        // Event listeners
        this.eventListeners = {};
        
        console.log("ClientMapManager initialized, procedural generation disabled");
    }
    
    /**
     * Initialize the map with metadata from server
     * @param {Object} data - Map metadata
     */
    initMap(data) {
        this.activeMapId = data.mapId;
        this.mapMetadata = data;
        this.tileSize = data.tileSize || this.tileSize;
        this.chunkSize = data.chunkSize || this.chunkSize;
        this.width = data.width || 0;
        this.height = data.height || 0;
        
        console.log(`Map initialized: ${this.activeMapId} (${this.width}x${this.height})`);
        console.log(`Map properties: tileSize=${this.tileSize}, chunkSize=${this.chunkSize}`);
        
        // Clear existing chunks
        this.chunks.clear();
        this.chunkLastAccessed.clear();
        this.pendingChunks.clear();
        
        // CRITICAL: Always disable procedural generation
        this.proceduralEnabled = false;
        
        // Immediately request chunks around player position
        if (gameState && gameState.character) {
            this.updateVisibleChunks(gameState.character.x, gameState.character.y);
        }
        
        // Dispatch event
        this.dispatchEvent('mapinitialized', { mapId: this.activeMapId });
    }
    
    /**
     * Set chunk data received from server
     * @param {number} chunkX - Chunk X coordinate
     * @param {number} chunkY - Chunk Y coordinate
     * @param {Object} chunkData - Chunk data from server
     */
    setChunkData(chunkX, chunkY, chunkData) {
        const key = `${chunkX},${chunkY}`;
        
        // Track time for performance measurement
        const startTime = performance.now();
        
        // Process chunk data to match our format
        const processedChunk = this.processChunkData(chunkData);
        
        // Store chunk
        this.chunks.set(key, processedChunk);
        this.chunkLastAccessed.set(key, Date.now());
        
        // Remove from pending
        this.pendingChunks.delete(key);
        
        // Calculate processing time
        const processingTime = (performance.now() - startTime).toFixed(2);
        
        // Log more detailed chunk info but keep it infrequent to avoid spam
        if (Math.random() < 0.2) { // Only log 20% of chunks
            console.log(`[MapManager] Received chunk at (${chunkX}, ${chunkY}): ${processedChunk.length} rows x ${processedChunk[0]?.length || 0} cols (processed in ${processingTime}ms)`);
            
            // Count tile types for debugging
            const tileCounts = {};
            if (processedChunk && Array.isArray(processedChunk)) {
                for (const row of processedChunk) {
                    for (const tile of row) {
                        const type = tile?.type || 'unknown';
                        tileCounts[type] = (tileCounts[type] || 0) + 1;
                    }
                }
                // Log tile distribution
                console.log(`[MapManager] Chunk ${key} tile distribution:`, tileCounts);
            }
        }
        
        // Trim cache if needed
        this.trimChunkCache();
        
        // Dispatch event
        this.dispatchEvent('chunkloaded', { chunkX, chunkY });
    }
    
    /**
     * Process chunk data from server into our format
     * @param {Object} chunkData - Chunk data from server
     * @returns {Array} Processed chunk data
     */
    processChunkData(chunkData) {
        // If the chunk data is already in the right format, return it
        if (Array.isArray(chunkData)) {
            return chunkData;
        }
        
        // Convert from server format to client format
        const processedData = [];
        
        // Process tiles array if it exists
        if (chunkData.tiles && Array.isArray(chunkData.tiles)) {
            for (let y = 0; y < chunkData.tiles.length; y++) {
                const row = [];
                for (let x = 0; x < chunkData.tiles[y].length; x++) {
                    const tileData = chunkData.tiles[y][x];
                    let tileType, tileHeight;
                    
                    // Handle different possible formats
                    if (typeof tileData === 'number') {
                        tileType = tileData;
                        tileHeight = 0;
                    } else if (tileData && typeof tileData === 'object') {
                        tileType = tileData.type;
                        tileHeight = tileData.height || 0;
                    } else {
                        tileType = TILE_IDS.FLOOR; // Default
                        tileHeight = 0;
                    }
                    
                    // Create tile instance
                    row.push(new Tile(tileType, tileHeight));
                }
                processedData.push(row);
            }
        } else {
            // Create default chunk data
            for (let y = 0; y < this.chunkSize; y++) {
                const row = [];
                for (let x = 0; x < this.chunkSize; x++) {
                    row.push(new Tile(TILE_IDS.FLOOR, 0));
                }
                processedData.push(row);
            }
        }
        
        return processedData;
    }
    
    /**
     * Update visible chunks based on player position
     * @param {number} playerX - Player X position in world coordinates
     * @param {number} playerY - Player Y position in world coordinates
     */
    updateVisibleChunks(playerX, playerY) {
        if (!this.networkManager) {
            console.warn("Cannot update visible chunks: network manager not available");
            return;
        }
        
        // Log request for debugging
        //console.log(`[MapManager] Updating visible chunks around (${playerX.toFixed(1)}, ${playerY.toFixed(1)})`);
        
        // Convert player position to chunk coordinates (integers)
        const centerChunkX = Math.floor(playerX / (this.tileSize * this.chunkSize));
        const centerChunkY = Math.floor(playerY / (this.tileSize * this.chunkSize));
        
        //console.log(`[MapManager] Center chunk: (${centerChunkX}, ${centerChunkY})`);
        
        // Get chunks in view distance
        const newVisibleChunks = [];
        const chunksRequested = []; // Track new chunk requests for logging
        
        for (let dy = -this.chunkLoadDistance; dy <= this.chunkLoadDistance; dy++) {
            for (let dx = -this.chunkLoadDistance; dx <= this.chunkLoadDistance; dx++) {
                const chunkX = centerChunkX + dx;
                const chunkY = centerChunkY + dy;
                
                // Skip if out of map bounds
                if (this.mapMetadata && this.width > 0 && this.height > 0) {
                    const chunkStartX = chunkX * this.chunkSize;
                    const chunkStartY = chunkY * this.chunkSize;
                    
                    if (chunkStartX < 0 || chunkStartY < 0 || 
                        chunkStartX >= this.width || 
                        chunkStartY >= this.height) {
                        continue;
                    }
                }
                
                const key = `${chunkX},${chunkY}`;
                newVisibleChunks.push({ x: chunkX, y: chunkY, key });
                
                // Update last accessed time
                if (this.chunks.has(key)) {
                    this.chunkLastAccessed.set(key, Date.now());
                }
                // Request chunk if not already loaded or pending
                else if (!this.pendingChunks.has(key)) {
                    this.pendingChunks.add(key);
                    try {
                        this.networkManager.requestChunk(chunkX, chunkY);
                        chunksRequested.push(`(${chunkX},${chunkY})`);
                    } catch (error) {
                        console.error(`Error requesting chunk (${chunkX}, ${chunkY}):`, error);
                        this.pendingChunks.delete(key);
                    }
                }
            }
        }
        
        // Log chunk requests in a single message to reduce console spam
        if (chunksRequested.length > 0) {
            console.log(`[MapManager] Requested ${chunksRequested.length} new chunks: ${chunksRequested.join(', ')}`);
        }
        
        this.visibleChunks = newVisibleChunks;
    }
    
    /**
     * Update visible chunks without making network requests
     * Use this to prevent flickering in strategic view
     * @param {number} playerX - Player X position
     * @param {number} playerY - Player Y position
     * @param {number} [customChunkDistance] - Optional chunk load distance
     */
    updateVisibleChunksLocally(playerX, playerY, customChunkDistance) {
        // Log local update
        console.log(`[MapManager] Updating visible chunks LOCALLY around (${playerX.toFixed(1)}, ${playerY.toFixed(1)})`);
        
        // Convert player position to chunk coordinates
        const centerChunkX = Math.floor(playerX / (this.tileSize * this.chunkSize));
        const centerChunkY = Math.floor(playerY / (this.tileSize * this.chunkSize));
        
        // Use custom distance if provided, otherwise use default
        const effectiveChunkLoadDistance = customChunkDistance !== undefined ? 
            customChunkDistance : this.chunkLoadDistance;
        
        console.log(`[MapManager] Local update center chunk: (${centerChunkX}, ${centerChunkY}), distance: ${effectiveChunkLoadDistance}`);
        
        // Update visible chunks list without requesting any new chunks
        const newVisibleChunks = [];
        const missingChunks = []; // Track chunks that would be loaded if we were making network requests
        
        // Build list of currently visible chunks
        for (let dy = -effectiveChunkLoadDistance; dy <= effectiveChunkLoadDistance; dy++) {
            for (let dx = -effectiveChunkLoadDistance; dx <= effectiveChunkLoadDistance; dx++) {
                const chunkX = centerChunkX + dx;
                const chunkY = centerChunkY + dy;
                
                // Skip if out of map bounds
                if (this.mapMetadata && this.width > 0 && this.height > 0) {
                    const chunkStartX = chunkX * this.chunkSize;
                    const chunkStartY = chunkY * this.chunkSize;
                    
                    if (chunkStartX < 0 || chunkStartY < 0 || 
                        chunkStartX >= this.width || 
                        chunkStartY >= this.height) {
                        continue;
                    }
                }
                
                const key = `${chunkX},${chunkY}`;
                
                // Add to visible chunks list
                newVisibleChunks.push({ x: chunkX, y: chunkY, key });
                
                // Update last accessed time for existing chunks
                if (this.chunks.has(key)) {
                    this.chunkLastAccessed.set(key, Date.now());
                } else {
                    // Track missing chunks (only done for debugging)
                    missingChunks.push(`(${chunkX},${chunkY})`);
                }
                // No network requests here, unlike updateVisibleChunks
            }
        }
        
        // Log missing chunks for debugging
        if (missingChunks.length > 0) {
            console.log(`[MapManager] ${missingChunks.length} chunks in view distance not loaded: ${missingChunks.join(', ')}`);
        }
        
        // Update the visible chunks list
        this.visibleChunks = newVisibleChunks;
        
        // No trimming of the cache here to avoid any visual jitter
        
        // Update last position for next call
        this._lastPlayerPosition = { x: centerChunkX, y: centerChunkY };
        
        return {
            center: { x: centerChunkX, y: centerChunkY },
            loadedChunks: this.visibleChunks.length - missingChunks.length,
            missingChunks: missingChunks.length
        };
    }
    
    /**
     * Trim the chunk cache to stay under the maximum limit
     */
    trimChunkCache() {
        if (this.chunks.size <= this.maxCachedChunks) {
            return;
        }
        
        // Get chunks sorted by last accessed time (oldest first)
        const sortedChunks = Array.from(this.chunkLastAccessed.entries())
            .sort((a, b) => a[1] - b[1]);
        
        // Calculate how many to remove
        const removeCount = this.chunks.size - this.maxCachedChunks;
        
        // Remove oldest chunks
        for (let i = 0; i < removeCount; i++) {
            const [key] = sortedChunks[i];
            this.chunks.delete(key);
            this.chunkLastAccessed.delete(key);
        }
        
            console.log(`Trimmed ${removeCount} chunks from cache`);
    }
    
    /**
     * Get a specific chunk
     * @param {number} chunkX - Chunk X coordinate
     * @param {number} chunkY - Chunk Y coordinate
     * @returns {Array|null} Chunk data or null if not loaded
     */
    getChunk(chunkX, chunkY) {
        const key = `${chunkX},${chunkY}`;
        
        // Update last accessed time
        if (this.chunks.has(key)) {
            this.chunkLastAccessed.set(key, Date.now());
            return this.chunks.get(key);
        }
        
        // Request chunk if not already pending
        if (this.networkManager && !this.pendingChunks.has(key)) {
            this.pendingChunks.add(key);
            try {
                this.networkManager.requestChunk(chunkX, chunkY);
                console.log(`Requested chunk (${chunkX}, ${chunkY}) on-demand`);
            } catch (error) {
                console.error(`Error requesting chunk (${chunkX}, ${chunkY}):`, error);
                this.pendingChunks.delete(key);
            }
        }
        
        return null;
    }
    
    /**
     * Get a specific tile by world coordinates
     * @param {number} x - Tile X coordinate
     * @param {number} y - Tile Y coordinate
     * @returns {Tile|null} Tile object or null if chunk not loaded
     */
    getTile(x, y) {
        // Calculate chunk coordinates
        const chunkX = Math.floor(x / this.chunkSize);
        const chunkY = Math.floor(y / this.chunkSize);
        
        // Get chunk
        const chunk = this.getChunk(chunkX, chunkY);
        if (!chunk) {
            // Return a fallback tile if chunk isn't loaded
            return this.generateFallbackTile(x, y);
        }
        
        // Calculate local coordinates within the chunk
        const localX = ((x % this.chunkSize) + this.chunkSize) % this.chunkSize;
        const localY = ((y % this.chunkSize) + this.chunkSize) % this.chunkSize;
        
        // Make sure we're within the bounds of the chunk data
        if (chunk.length <= localY || !chunk[localY] || chunk[localY].length <= localX) {
            console.warn(`Invalid local coordinates (${localX}, ${localY}) for chunk (${chunkX}, ${chunkY})`);
            return this.generateFallbackTile(x, y);
        }
        
        // Return tile if it exists
        if (chunk[localY] && chunk[localY][localX]) {
            return chunk[localY][localX];
        }
        
        // Return fallback if tile not found
        return this.generateFallbackTile(x, y);
    }
    
    /**
     * Get tiles in a range (for rendering)
     * @param {number} startX - Start X coordinate
     * @param {number} startY - Start Y coordinate
     * @param {number} endX - End X coordinate
     * @param {number} endY - End Y coordinate
     * @returns {Array} Array of tile objects
     */
    getTilesInRange(startX, startY, endX, endY) {
        const tiles = [];
        
        for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
                const tile = this.getTile(x, y);
                if (tile) {
                    tiles.push({ x, y, tile });
                }
            }
        }
        
        return tiles;
    }
    
    /**
     * Check if a position is a wall or obstacle
     * @param {number} x - World X coordinate
     * @param {number} y - World Y coordinate
     * @returns {boolean} True if wall, false if not (or chunk not loaded)
     */
    isWallOrObstacle(x, y) {
        // Convert to tile coordinates
        const tileX = Math.floor(x / this.tileSize);
        const tileY = Math.floor(y / this.tileSize);
        
        // Get tile
        const tile = this.getTile(tileX, tileY);
        
        // If tile not found, assume passable
        if (!tile) {
            return false;
        }
        
        // Check if wall, obstacle, mountain, or water
        return tile.type === TILE_IDS.WALL || 
               tile.type === TILE_IDS.OBSTACLE || 
               tile.type === TILE_IDS.MOUNTAIN ||
               tile.type === TILE_IDS.WATER;
    }
    
    /**
     * Generate a fallback tile when chunk not loaded
     * @param {number} x - Tile X coordinate
     * @param {number} y - Tile Y coordinate
     * @returns {Tile} Fallback tile
     */
    generateFallbackTile(x, y) {
        // Use a simple pattern for fallback tiles
        // Make map edges walls, interior floor
        if (x < 0 || y < 0 || (this.width > 0 && x >= this.width) || (this.height > 0 && y >= this.height)) {
            return new Tile(TILE_IDS.WALL, 0);
        }
        
        // Checkerboard pattern
        const isEven = (x + y) % 2 === 0;
        const tileType = isEven ? TILE_IDS.FLOOR : TILE_IDS.FLOOR;
        
        return new Tile(tileType, 0);
    }
    
    /**
     * Add event listener
     * @param {string} event - Event name
     * @param {Function} callback - Event callback
     */
    addEventListener(event, callback) {
        if (!this.eventListeners[event]) {
            this.eventListeners[event] = [];
        }
        this.eventListeners[event].push(callback);
    }
    
    /**
     * Remove event listener
     * @param {string} event - Event name
     * @param {Function} callback - Event callback
     */
    removeEventListener(event, callback) {
        if (!this.eventListeners[event]) return;
        const index = this.eventListeners[event].indexOf(callback);
        if (index !== -1) {
            this.eventListeners[event].splice(index, 1);
        }
    }
    
    /**
     * Dispatch an event
     * @param {string} event - Event name
     * @param {Object} data - Event data
     */
    dispatchEvent(event, data) {
        if (!this.eventListeners[event]) return;
        for (const callback of this.eventListeners[event]) {
            callback(data);
        }
    }
    
    /**
     * Print debug information about the current map state
     * @param {boolean} [showFullChunks=false] - Whether to print full chunk data
     */
    debugPrintMapInfo(showFullChunks = false) {
        console.log('=== MAP MANAGER DEBUG INFO ===');
        console.log(`Map ID: ${this.activeMapId || 'None'}`);
        console.log(`Map Size: ${this.width}x${this.height}`);
        console.log(`Tile Size: ${this.tileSize}, Chunk Size: ${this.chunkSize}`);
        console.log(`Procedural Generation: ${this.proceduralEnabled ? 'Enabled' : 'Disabled'}`);
        console.log(`Loaded Chunks: ${this.chunks.size}`);
        console.log(`Pending Chunks: ${this.pendingChunks.size}`);
        console.log(`Visible Chunks: ${this.visibleChunks.length}`);
        
        // Print chunk locations
        const chunkLocations = Array.from(this.chunks.keys()).map(key => {
            const [x, y] = key.split(',').map(Number);
            return `(${x},${y})`;
        });
        console.log(`Chunk Locations: ${chunkLocations.join(', ')}`);
        
        // Print chunk data if requested
        if (showFullChunks) {
            console.log('=== CHUNK DATA ===');
            this.chunks.forEach((chunk, key) => {
                console.log(`Chunk ${key}:`);
                this.printChunkVisually(key, chunk);
            });
        }
        
        console.log('=============================');
    }
    
    /**
     * Print a visual representation of a chunk to the console
     * @param {string} chunkKey - The chunk key (e.g. "0,0")
     * @param {Array} chunk - The chunk data
     */
    printChunkVisually(chunkKey, chunk) {
        if (!chunk || !Array.isArray(chunk)) {
            console.log(`Chunk ${chunkKey} has invalid data format`);
            return;
        }
        
        // Define tile type symbols for visual representation
        const symbols = {
            [TILE_IDS.FLOOR]: '.',
            [TILE_IDS.WALL]: '#',
            [TILE_IDS.OBSTACLE]: 'O',
            [TILE_IDS.WATER]: '~',
            [TILE_IDS.MOUNTAIN]: '^',
            'default': '?'
        };
        
        console.log(`Chunk ${chunkKey} - ${chunk.length}x${chunk[0]?.length || 0}:`);
        
        // Build visual representation
        const visual = [];
        for (let y = 0; y < chunk.length; y++) {
            let row = '';
            for (let x = 0; x < chunk[y].length; x++) {
                const tile = chunk[y][x];
                const tileType = tile?.type || 'default';
                row += symbols[tileType] || symbols['default'];
            }
            visual.push(row);
        }
        
        // Print the visual representation
        visual.forEach(row => console.log(row));
    }
    
    /**
     * Visualize the loaded map in the browser console with color
     * @param {number} centerX - Center tile X coordinate
     * @param {number} centerY - Center tile Y coordinate
     * @param {number} width - Width in tiles to visualize
     * @param {number} height - Height in tiles to visualize
     */
    visualizeMap(centerX = null, centerY = null, width = 40, height = 20) {
        console.log('=== MAP VISUALIZATION ===');
        
        // If no center specified, use player position
        if (centerX === null || centerY === null) {
            if (gameState && gameState.character) {
                centerX = Math.floor(gameState.character.x);
                centerY = Math.floor(gameState.character.y);
            } else {
                centerX = 0;
                centerY = 0;
            }
        }
        
        console.log(`Map centered at (${centerX}, ${centerY}), showing ${width}x${height} tiles`);
        
        // Calculate boundaries
        const startX = Math.floor(centerX - width / 2);
        const startY = Math.floor(centerY - height / 2);
        const endX = startX + width;
        const endY = startY + height;
        
        // Define colors for different tile types
        const colors = {
            [TILE_IDS.FLOOR]: 'color: #8a8a8a', // Gray
            [TILE_IDS.WALL]: 'color: #d43f3f', // Red
            [TILE_IDS.OBSTACLE]: 'color: #d49f3f', // Orange
            [TILE_IDS.WATER]: 'color: #3f8ad4', // Blue
            [TILE_IDS.MOUNTAIN]: 'color: #6f6f6f', // Dark gray
            'current': 'color: #ffffff; background-color: #ff0000', // White on red for player position
            'default': 'color: #ffffff' // White
        };
        
        // Define symbols for tile types
        const symbols = {
            [TILE_IDS.FLOOR]: '',
            [TILE_IDS.WALL]: '',
            [TILE_IDS.OBSTACLE]: '',
            [TILE_IDS.WATER]: '',
            [TILE_IDS.MOUNTAIN]: '',
            'current': '',
            'default': '?'
        };
        
        // Track which chunks are loaded or missing
        const loadedChunks = new Set();
        const missingChunks = new Set();
        
        // Build the visualization row by row
        for (let y = startY; y < endY; y++) {
            let row = '%c';
            let formats = [];
            
            for (let x = startX; x < endX; x++) {
                // Check if this is the player position
                const isPlayerPos = (x === centerX && y === centerY);
                
                if (isPlayerPos) {
                    row += symbols['current'];
                    formats.push(colors['current']);
                    continue;
                }
                
                // Get tile type
                const tile = this.getTile(x, y);
                
                // Track chunk status
                const chunkX = Math.floor(x / this.chunkSize);
                const chunkY = Math.floor(y / this.chunkSize);
                const chunkKey = `${chunkX},${chunkY}`;
                
                if (this.chunks.has(chunkKey)) {
                    loadedChunks.add(chunkKey);
                } else {
                    missingChunks.add(chunkKey);
                }
                
                // Add appropriate symbol with color
                if (tile) {
                    const tileType = tile.type;
                    row += '%c' + (symbols[tileType] || symbols['default']);
                    formats.push(colors[tileType] || colors['default']);
                    } else {
                    row += '%c' + '.';
                    formats.push('color: #333333'); // Dark gray for unknown/missing
                }
            }
            
            // Print the row with formats
            console.log(row, ...formats);
        }
        
        // Print chunk information
        console.log('Loaded chunks: ' + Array.from(loadedChunks).join(', '));
        console.log('Missing chunks: ' + Array.from(missingChunks).join(', '));
        console.log('===========================');
        
        // Return summary
        return {
            center: { x: centerX, y: centerY },
            loadedChunks: loadedChunks.size,
            missingChunks: missingChunks.size,
            tilesShown: width * height
        };
    }
    
    /**
     * Save current map data to a file
     * @returns {Object} Map data object
     */
    saveMapData() {
        // Get map dimensions
        const width = this.width || 64;
        const height = this.height || 64;
        
        console.log(`Saving map with dimensions ${width}x${height}`);
        
        // Initialize with 0 (floor) as default
        const tileMap = Array(height).fill().map(() => Array(width).fill(0));
        
        // Keep track of chunks and tiles processed
        const loadedChunks = new Set();
        const tilesFound = 0;
        
        // Process all loaded chunks
        for (const [key, chunk] of this.chunks.entries()) {
            const [chunkX, chunkY] = key.split(',').map(Number);
            const startX = chunkX * this.chunkSize;
            const startY = chunkY * this.chunkSize;
            
            loadedChunks.add(key);
            
            // Process each tile in the chunk
            if (chunk && Array.isArray(chunk)) {
                for (let y = 0; y < chunk.length; y++) {
                    if (!chunk[y]) continue;
                    
                    for (let x = 0; x < chunk[y].length; x++) {
                        if (!chunk[y][x]) continue;
                        
                        const globalX = startX + x;
                        const globalY = startY + y;
                        
                        // Make sure we're within the map bounds
                        if (globalX >= 0 && globalX < width && globalY >= 0 && globalY < height) {
                            if (chunk[y][x].type !== undefined) {
                                tileMap[globalY][globalX] = chunk[y][x].type;
                            }
                        }
                    }
                }
            }
        }
        
        // Format JSON with one row per line for readability
        const formattedJson = "[\n" + 
            tileMap.map(row => "  " + JSON.stringify(row)).join(",\n") + 
            "\n]";
        
        // Save the map using the browser's download capability
        try {
            const blob = new Blob([formattedJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `client_map_direct_${this.activeMapId || 'unknown'}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log(`Map data saved to ${a.download} (${loadedChunks.size} chunks)`);
            
            // Make the save map function available globally for debugging
            window.clientMapData = tileMap;
            console.log("Map data also available at window.clientMapData");
            
            return { 
                tileMap, 
                loadedChunks: loadedChunks.size,
                width,
                height
            };
        } catch (error) {
            console.error("Error saving map data:", error);
            return null;
        }
    }
}

// =========================================
// FILE: public/src/map/map.js
// =========================================

// src/map/map.js

import { TILE_IDS, CHUNK_SIZE } from '../constants/constants.js';
import { perlin } from './perlinNoise.js';
import { Tile } from './tile.js';
import { MapLoader } from './mapLoader.js'; // Import MapLoader

class GameMap {
  constructor() {
    this.chunks = new Map();
    this.isFixedMap = false;
    this.proceduralEnabled = true;
  }

  /**
   * Disables procedural generation.
   */
  disableProceduralGeneration() {
    this.proceduralEnabled = false;
  }

  /**
   * Enables procedural generation.
   */
  enableProceduralGeneration() {
    this.proceduralEnabled = true;
    this.isFixedMap = false;
  }

  /**
   * Loads a fixed map from a JSON file.
   * @param {string} url - The URL of the map JSON file.
   * @returns {Promise<void>}
   */
  async loadFixedMap(url) {
    try {
      const mapData = await MapLoader.loadMapFromFile(url);
      this.setMapData(mapData);
      this.isFixedMap = true;
      console.log('Fixed map loaded successfully.');
    } catch (error) {
      console.error('Failed to load fixed map:', error);
    }
  }

  /**
   * Sets the map data from a loaded map.
   * @param {Object} mapData - The map data object.
   */
  setMapData(mapData) {
    this.chunks.clear(); // Clear any existing procedural data

    const { width, height, tiles } = mapData;

    for (let y = 0; y < height; y += CHUNK_SIZE) {
      for (let x = 0; x < width; x += CHUNK_SIZE) {
        const chunkRow = Math.floor(y / CHUNK_SIZE);
        const chunkCol = Math.floor(x / CHUNK_SIZE);
        const chunkData = [];

        for (let dy = 0; dy < CHUNK_SIZE; dy++) {
          const rowData = [];
          for (let dx = 0; dx < CHUNK_SIZE; dx++) {
            const tileX = x + dx;
            const tileY = y + dy;

            if (tileY >= height || tileX >= width) {
              // Out-of-bounds: default to a valid tile (e.g., FLOOR)
              rowData.push(new Tile(TILE_IDS.FLOOR));
              continue;
            }

            const tileType = tiles[tileY][tileX];
            rowData.push(new Tile(tileType));
          }
          chunkData.push(rowData);
        }

        this.chunks.set(`${chunkRow},${chunkCol}`, chunkData);
      }
    }
  }

  /**
   * Procedural generation function
   */
  generateChunkData(chunkRow, chunkCol) {
    if (this.isFixedMap || !this.proceduralEnabled) {
      return [];
    }

    const chunkData = [];
    for (let y = 0; y < CHUNK_SIZE; y++) {
      const rowData = [];
      for (let x = 0; x < CHUNK_SIZE; x++) {
        const globalX = chunkCol * CHUNK_SIZE + x;
        const globalY = chunkRow * CHUNK_SIZE + y;
        const heightValue = perlin.get(globalX / 50, globalY / 50); // Adjust scaling as needed
        const tileType = this.determineTileType(heightValue);
        rowData.push(new Tile(tileType, heightValue));
      }
      chunkData.push(rowData);
    }
    return chunkData;
  }

  /**
   * Function to determine tile type based on height
   */
  determineTileType(heightValue) {
    if (heightValue < -0.2) return TILE_IDS.WATER;
    if (heightValue < 0.2) return TILE_IDS.FLOOR;
    return TILE_IDS.MOUNTAIN;
  }

  /**
   * Function to load a chunk
   */
  loadChunk(chunkRow, chunkCol) {
    const key = `${chunkRow},${chunkCol}`;
    if (this.chunks.has(key)) return this.chunks.get(key);

    if (this.isFixedMap || !this.proceduralEnabled) {
      return null;
    }

    // Generate chunk data procedurally
    const chunkData = this.generateChunkData(chunkRow, chunkCol);
    this.chunks.set(key, chunkData);
    return chunkData;
  }

  /**
   * Function to get tile at world coordinates
   */
  getTile(x, y) {
    const chunkRow = Math.floor(y / CHUNK_SIZE);
    const chunkCol = Math.floor(x / CHUNK_SIZE);
    const chunk = this.loadChunk(chunkRow, chunkCol);
    if (!chunk) return null;

    const localX = x % CHUNK_SIZE;
    const localY = y % CHUNK_SIZE;
    if (localY < 0 || localY >= CHUNK_SIZE || localX < 0 || localX >= CHUNK_SIZE) return null;
    return chunk[localY][localX];
  }

  /**
   * Function to get all tiles in a specific range (for rendering)
   */
  getTilesInRange(xStart, yStart, xEnd, yEnd) {
    const tiles = [];
    for (let y = yStart; y <= yEnd; y++) {
      for (let x = xStart; x <= xEnd; x++) {
        const tile = this.getTile(x, y);
        if (tile) {
          tiles.push({ x, y, tile });
        }
      }
    }
    return tiles;
  }
}

// Export a singleton GameMap instance
export const map = new GameMap();


// =========================================
// FILE: public/src/map/mapLoader.js
// =========================================

// src/map/mapLoader.js

/**
 * MapLoader class to handle loading of fixed maps from JSON files.
 */
export class MapLoader {
    /**
     * Loads a map from a given URL.
     * @param {string} url - The URL of the map JSON file.
     * @returns {Promise<Object>} - A promise that resolves to the map data.
     */
    static async loadMapFromFile(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Failed to load map from ${url}: ${response.statusText}`);
        }
        const mapData = await response.json();
        return mapData;
      } catch (error) {
        console.error('Error loading map:', error);
        throw error;
      }
    }
  }
  

// =========================================
// FILE: public/src/map/tile.js
// =========================================

// src/map/tile.js

export class Tile {
    constructor(type, height = 0, properties = {}) {
      this.type = type; // e.g., TILE_IDS.FLOOR, TILE_IDS.WALL, etc.
      this.height = height; // Height value for 3D rendering
      this.properties = properties; // Additional properties like textures
    }
  }
  

// =========================================
// FILE: public/src/network/ClientNetworkManager.js
// =========================================

// public/src/network/ClientNetworkManager.js

/**
 * Utility for throttling log messages to reduce console spam
 */
const logThrottles = {};
function throttledLog(key, message, data, interval = 1000) {
    const now = Date.now();
    if (!logThrottles[key] || now - logThrottles[key] >= interval) {
        logThrottles[key] = now;
        if (data !== undefined) {
            console.log(message, data);
        } else {
            console.log(message);
        }
        return true;
    }
    return false;
}

// Simple utility to save map data to a file
window.saveMapData = function() {
    try {
        // First check if we have direct access to the clientMapManager
        if (window.gameState && window.gameState.map) {
            console.log("Saving map data from ClientMapManager...");
            console.log("Map object:", window.gameState.map);
            console.log("Loaded chunks:", window.gameState.map.chunks ? window.gameState.map.chunks.size : 0);
            
            // Get map dimensions
            const map = window.gameState.map;
            const width = map.width || 64;
            const height = map.height || 64;
            const mapId = map.activeMapId || 'unknown';
            
            console.log(`Creating map with dimensions ${width}x${height}`);
            
            // Initialize with 0 (floor) as default
            const tileMap = Array(height).fill().map(() => Array(width).fill(0));
            
            // Process all loaded chunks
            let tilesFound = 0;
            const loadedChunks = new Set();
            
            // Check if chunks are loaded
            if (map.chunks && map.chunks.size > 0) {
                console.log(`Found ${map.chunks.size} loaded chunks in map manager`);
                
                // First method: get data from loaded chunks
                for (const [key, chunk] of map.chunks.entries()) {
                    const [chunkX, chunkY] = key.split(',').map(Number);
                    const startX = chunkX * map.chunkSize;
                    const startY = chunkY * map.chunkSize;
                    
                    loadedChunks.add(key);
                    
                    // Process each tile in the chunk
                    if (chunk && Array.isArray(chunk)) {
                        for (let y = 0; y < chunk.length; y++) {
                            if (!chunk[y]) continue;
                            
                            for (let x = 0; x < chunk[y].length; x++) {
                                if (!chunk[y][x]) continue;
                                
                                const globalX = startX + x;
                                const globalY = startY + y;
                                
                                // Make sure we're within the map bounds
                                if (globalX >= 0 && globalX < width && globalY >= 0 && globalY < height) {
                                    if (chunk[y][x].type !== undefined) {
                                        tileMap[globalY][globalX] = chunk[y][x].type;
                                        tilesFound++;
                                    }
                                }
                            }
                        }
                    }
                }
                
                console.log(`Found ${tilesFound} tiles with defined types from chunks`);
            } else {
                console.log("No loaded chunks found in map manager. Will try direct tile lookup.");
            }
            
            // Second method: If few tiles found, try direct lookup for entire map
            if (tilesFound < width * height * 0.1) { // Less than 10% filled
                console.log("Few tiles found, using direct getTile() lookup for each position...");
                
                // Force load chunks around player if possible
                if (gameState.character && typeof map.updateVisibleChunks === 'function') {
                    console.log("Forcing chunk update around player position...");
                    map.updateVisibleChunks(gameState.character.x, gameState.character.y);
                    
                    // Give some time for chunks to load
                    console.log("Waiting for chunks to load...");
                    setTimeout(() => {
                        console.log(`After forced update: ${map.chunks ? map.chunks.size : 0} chunks loaded`);
                    }, 500);
                }
                
                // Use direct tile lookup with getTile()
                let directTilesFound = 0;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        // Get tile directly from the map manager
                        const tile = map.getTile(x, y);
                        if (tile && tile.type !== undefined && tile.type !== 0) {
                            tileMap[y][x] = tile.type;
                            directTilesFound++;
                        }
                    }
                }
                
                console.log(`Found ${directTilesFound} additional tiles with defined types using direct lookup`);
                tilesFound += directTilesFound;
            }
            
            // Third method: If we have access to mapDebug, use that data
            if (tilesFound < width * height * 0.1 && window.mapDebug && window.mapDebug.chunks) {
                console.log("Still few tiles found, trying with mapDebug data...");
                
                let debugTilesFound = 0;
                
                // Process mapDebug chunks
                for (const key in window.mapDebug.chunks) {
                    const [chunkX, chunkY] = key.split(',').map(Number);
                    const chunk = window.mapDebug.chunks[key];
                    const startX = chunkX * map.chunkSize;
                    const startY = chunkY * map.chunkSize;
                    
                    // Process the chunk
                    if (chunk && Array.isArray(chunk)) {
                        for (let y = 0; y < chunk.length; y++) {
                            if (!chunk[y]) continue;
                            
                            for (let x = 0; x < chunk[y].length; x++) {
                                if (!chunk[y][x]) continue;
                                
                                const globalX = startX + x;
                                const globalY = startY + y;
                                
                                // Make sure we're within the map bounds
                                if (globalX >= 0 && globalX < width && globalY >= 0 && globalY < height) {
                                    if (chunk[y][x].type !== undefined) {
                                        tileMap[globalY][globalX] = chunk[y][x].type;
                                        debugTilesFound++;
                                    }
                                }
                            }
                        }
                    }
                }
                
                console.log(`Found ${debugTilesFound} additional tiles with defined types from mapDebug`);
                tilesFound += debugTilesFound;
            }
            
            // Fourth method: If all else fails, try map's direct saving method
            if (tilesFound < width * height * 0.1 && typeof map.saveMapData === 'function') {
                console.log("Using map's direct saveMapData method as last resort...");
                // This will open its own download
                const mapData = map.saveMapData();
                if (mapData && mapData.tileMap) {
                    console.log("Map's direct saveMapData method returned data");
                    // Replace our tile map with the one from the map manager
                    for (let y = 0; y < Math.min(height, mapData.tileMap.length); y++) {
                        for (let x = 0; x < Math.min(width, mapData.tileMap[y].length); x++) {
                            tileMap[y][x] = mapData.tileMap[y][x];
                        }
                    }
                    tilesFound = "unknown (using direct map data)";
                }
            }
            
            console.log(`Total tiles found: ${tilesFound} out of ${width*height} total tiles`);
            
            // Finally, check if we have all zeros and add some variety if so
            let allZeros = true;
            for (let y = 0; y < height && allZeros; y++) {
                for (let x = 0; x < width && allZeros; x++) {
                    if (tileMap[y][x] !== 0) {
                        allZeros = false;
                        break;
                    }
                }
            }
            
            if (allZeros) {
                console.warn("WARNING: All tiles are 0, adding some variety for testing purposes");
                
                // Add some walls and obstacles in a pattern
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        // Create a border
                        if (x === 0 || y === 0 || x === width - 1 || y === height - 1) {
                            tileMap[y][x] = 1; // Wall
                        } 
                        // Add some obstacles in a pattern
                        else if ((x % 10 === 0 && y % 10 === 0) || (x % 10 === 5 && y % 10 === 5)) {
                            tileMap[y][x] = 2; // Obstacle
                        }
                        // Add some water
                        else if ((x > width/2 - 5 && x < width/2 + 5) && (y > height/2 - 5 && y < height/2 + 5)) {
                            tileMap[y][x] = 3; // Water
                        }
                    }
                }
                
                console.log("Added variety to the all-zero map for testing");
            }
            
            // Format JSON with one row per line for readability like simple_map_map_1.json
            const formattedJson = "[\n" + 
                tileMap.map(row => "  " + JSON.stringify(row)).join(",\n") + 
                "\n]";
            
            // Save the simple map
            const blob = new Blob([formattedJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `client_simple_map_${mapId}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log(`Map saved to ${a.download} (${loadedChunks.size} chunks)`);
            return true;
        } else if (window.mapDebug && window.mapDebug.chunks) {
            // Fallback to using mapDebug if available
            console.log("Using mapDebug data as fallback...");
            const mapId = window.mapDebug.mapId || 'unknown';
            const chunks = window.mapDebug.chunks;
            
            // Find the bounds of the map from chunks
            let minChunkX = Infinity, minChunkY = Infinity;
            let maxChunkX = -Infinity, maxChunkY = -Infinity;
            
            for (const key in chunks) {
                const [chunkX, chunkY] = key.split(',').map(Number);
                minChunkX = Math.min(minChunkX, chunkX);
                minChunkY = Math.min(minChunkY, chunkY);
                maxChunkX = Math.max(maxChunkX, chunkX);
                maxChunkY = Math.max(maxChunkY, chunkY);
            }
            
            const chunkSize = 16; // Default chunk size
            const width = (maxChunkX - minChunkX + 1) * chunkSize;
            const height = (maxChunkY - minChunkY + 1) * chunkSize;
            
            console.log(`Creating map with dimensions ${width}x${height} from mapDebug`);
            
            // Initialize with 0 (floor) as default
            const tileMap = Array(height).fill().map(() => Array(width).fill(0));
            
            // Fill the map with known tile types from chunks
            for (const key in chunks) {
                const [chunkX, chunkY] = key.split(',').map(Number);
                const chunk = chunks[key];
                
                if (!chunk || !Array.isArray(chunk)) continue;
                
                const startX = (chunkX - minChunkX) * chunkSize;
                const startY = (chunkY - minChunkY) * chunkSize;
                
                for (let y = 0; y < chunk.length; y++) {
                    if (!chunk[y]) continue;
                    
                    for (let x = 0; x < chunk[y].length; x++) {
                        if (!chunk[y][x]) continue;
                        
                        const globalX = startX + x;
                        const globalY = startY + y;
                        
                        if (globalX >= 0 && globalX < width && globalY >= 0 && globalY < height) {
                            if (chunk[y][x].type !== undefined) {
                                tileMap[globalY][globalX] = chunk[y][x].type;
                            }
                        }
                    }
                }
            }
            
            // Format JSON with one row per line for readability
            const formattedJson = "[\n" + 
                tileMap.map(row => "  " + JSON.stringify(row)).join(",\n") + 
                "\n]";
            
            // Save the simple map
            const blob = new Blob([formattedJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `client_simple_map_${mapId}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log(`Map saved to ${a.download} using mapDebug data`);
            return true;
        } else {
            console.warn("No map data available. Please wait for the map to load or explore more of the map first.");
            return false;
        }
    } catch (error) {
        console.error("Error saving map data:", error);
        return false;
    }
};

// Save a simple 2D array of just tile types
function saveTileTypeArray() {
    try {
        // Check if we have access to the map manager directly
        if (!window.gameState || !window.gameState.map) {
            console.error("No map manager available in gameState");
            return false;
        }
        
        const map = window.gameState.map;
        const mapId = window.mapDebug?.mapId || 'unknown';
        const chunkSize = map.chunkSize || 16;
        const width = map.width || 64;
        const height = map.height || 64;
        
        console.log(`Creating client map with dimensions ${width}x${height} from clientMapManager`);
        
        // Initialize with 0 (floor) as default instead of -1
        const tileMap = Array(height).fill().map(() => Array(width).fill(0));
        
        // Use direct tile lookup for each position in the map
        let tilesFound = 0;
        
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                // Get tile directly from the map manager
                const tile = map.getTile(x, y);
                if (tile && tile.type !== undefined) {
                    tileMap[y][x] = tile.type;
                    tilesFound++;
                }
            }
        }
        
        console.log(`Found ${tilesFound} tiles with defined types out of ${width*height} total tiles`);
        
        // If we found very few tiles, try another approach
        if (tilesFound < width * height * 0.1) { // Less than 10% of tiles have values
            console.log("Very few tiles found, trying with chunk data from mapDebug");
            
            // Find the bounds of the map from chunks
            let minChunkX = Infinity, minChunkY = Infinity;
            let maxChunkX = -Infinity, maxChunkY = -Infinity;
            
            // Find the bounds of all chunks
            for (const key in window.mapDebug?.chunks || {}) {
                const [chunkX, chunkY] = key.split(',').map(Number);
                minChunkX = Math.min(minChunkX, chunkX);
                minChunkY = Math.min(minChunkY, chunkY);
                maxChunkX = Math.max(maxChunkX, chunkX);
                maxChunkY = Math.max(maxChunkY, chunkY);
            }
            
            console.log(`Chunk bounds: (${minChunkX},${minChunkY}) to (${maxChunkX},${maxChunkY})`);
            
            // Fill the map with known tile types from chunks
            for (const key in window.mapDebug?.chunks || {}) {
                const [chunkX, chunkY] = key.split(',').map(Number);
                const chunk = window.mapDebug.chunks[key];
                
                // Check if the chunk has tiles
                if (!chunk || !Array.isArray(chunk)) {
                    console.log(`Chunk ${key} has invalid format:`, chunk);
                    continue;
                }
                
                // Process each tile in the chunk
                for (let relY = 0; relY < chunkSize; relY++) {
                    if (!chunk[relY]) continue;
                    
                    for (let relX = 0; relX < chunkSize; relX++) {
                        if (!chunk[relY][relX]) continue;
                        
                        const globalX = chunkX * chunkSize + relX;
                        const globalY = chunkY * chunkSize + relY;
                        
                        // Make sure we're within the map bounds
                        if (globalX >= 0 && globalX < width && globalY >= 0 && globalY < height) {
                            if (chunk[relY][relX].type !== undefined) {
                                tileMap[globalY][globalX] = chunk[relY][relX].type;
                                tilesFound++;
                            }
                        }
                    }
                }
            }
            
            console.log(`After using chunk data: Found ${tilesFound} tiles with defined types`);
        }
        
        // Check if we have the map's debug print method
        if (tilesFound < width * height * 0.1 && typeof map.printMapDebug === 'function') {
            console.log("Still very few tiles found, trying to extract data from debug visualization");
            
            // Get the debug representation which contains all the tile information
            const debugInfo = map.printMapDebug(width, height, true);
            
            // If the debug info returned tile counts, we have success
            if (debugInfo && debugInfo.loadedChunks > 0) {
                console.log(`Successfully extracted map data from debug visualization: ${debugInfo.loadedChunks} chunks loaded`);
            }
        }
        
        // Format JSON with one row per line for readability
        const formattedJson = "[\n" + 
            tileMap.map(row => "  " + JSON.stringify(row)).join(",\n") + 
            "\n]";
        
        // Save the simple map
        const blob = new Blob([formattedJson], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `client_simple_map_${mapId}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        console.log(`Simple tile map saved to ${a.download}`);
        return true;
    } catch (error) {
        console.error("Error saving simple tile map:", error);
        return false;
    }
}

console.log("Map save function available. Use window.saveMapData() in the console to download map data.");

/**
 * ClientNetworkManager
 * Handles WebSocket communication with the game server using binary packet format
 */
export class ClientNetworkManager {
    /**
     * Creates the client networking manager
     * @param {string} serverUrl - WebSocket server URL
     * @param {Object} game - Reference to the main game object
     */
    constructor(serverUrl, game) {
        this.serverUrl = serverUrl;
        this.game = game;
        this.socket = null;
        this.connected = false;
        this.connecting = false;
        this.clientId = null;
        this.lastServerTime = 0;
        this.serverTimeOffset = 0;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 2000; // ms
        this.lastPingTime = Date.now(); // For debugging
        
        // Message queue for messages that should be sent once connected
        this.messageQueue = [];
        
        // Register message handlers for different message types
        this.handlers = {};
        Object.values(MessageType).forEach(type => {
            this.handlers[type] = () => {};
        });
        
        // Set up specific handlers
        this.setupMessageHandlers();
        
        console.log("ClientNetworkManager initialized with server URL:", serverUrl);
    }
    
    /**
     * Set up message type handlers
     */
    setupMessageHandlers() {
        this.handlers[MessageType.HANDSHAKE_ACK] = (data) => {
            this.clientId = data.clientId;
            console.log(`Received client ID: ${this.clientId}`);
            if (this.game.setClientId) {
                this.game.setClientId(this.clientId);
            }
        };
        
        this.handlers[MessageType.MAP_INFO] = (data) => {
            console.log('Received map info:', data);
            // Store map ID in localStorage for persistence
            if (data.mapId) {
                console.log(`Storing map ID in localStorage: ${data.mapId}`);
                localStorage.setItem('currentMapId', data.mapId);
            }
            if (this.game.initMap) {
                this.game.initMap(data);
            }
        };
        
        this.handlers[MessageType.PLAYER_LIST] = (data) => {
            // Check if data is directly the players object or has a nested 'players' property
            // This handles both formats from the server
            let playersData = data;
            
            // If the data has a 'players' property and it's an object, use that
            if (data.players && typeof data.players === 'object') {
                playersData = data.players;
                throttledLog('player-list-format', '[NETWORK] Found nested players property in PLAYER_LIST message');
            }
            
            // Validate that we have an object with players
            if (!playersData || typeof playersData !== 'object') {
                console.error('Invalid player list data format:', data);
                return;
            }
            
            const playerCount = Object.keys(playersData).length;
            
            // Throttle these logs to once per second
            throttledLog('player-list', `[NETWORK] Received player list: ${playerCount} players (IDs: ${Object.keys(playersData).join(', ')})`);
            
            if (playerCount > 0 && throttledLog('player-sample', 'Player sample:', null, 5000)) {
                // Log a sample player for data validation (only once every 5 seconds)
                const samplePlayerId = Object.keys(playersData)[0];
                const samplePlayer = playersData[samplePlayerId];
                console.log(`Sample player data for ${samplePlayerId}:`, samplePlayer);
            }
            
            // Call game's setPlayers handler with the correct players data
            if (this.game.setPlayers) {
                this.game.setPlayers(playersData);
            } else {
                console.error("PLAYER_LIST handler called but this.game.setPlayers not defined!");
            }
        };
        
        this.handlers[MessageType.ENEMY_LIST] = (data) => {
            throttledLog('enemy-list', `Received enemies list: ${data.enemies ? data.enemies.length : 0} enemies`, null, 2000);
            if (this.game.setEnemies && data.enemies) {
                this.game.setEnemies(data.enemies);
            }
        };
        
        this.handlers[MessageType.BULLET_LIST] = (data) => {
            throttledLog('bullet-list', `Received bullets list: ${data.bullets ? data.bullets.length : 0} bullets`, null, 2000);
            if (this.game.setBullets && data.bullets) {
                this.game.setBullets(data.bullets);
            }
        };
        
        this.handlers[MessageType.WORLD_UPDATE] = (data) => {
            // Only log occasionally to reduce spam
            throttledLog('world-update', `World update received`, null, 3000);
            
            if (this.game.updateWorld) {
                // Check if players is nested inside a 'players' property (from server inconsistency)
                const players = data.players?.players || data.players;
                this.game.updateWorld(data.enemies, data.bullets, players);
            }
        };
        
        this.handlers[MessageType.PLAYER_JOIN] = (data) => {
            console.log(`Player joined: ${data.player ? data.player.id : 'unknown'}`);
            if (this.game.addPlayer && data.player) {
                this.game.addPlayer(data.player);
            }
        };
        
        this.handlers[MessageType.PLAYER_LEAVE] = (data) => {
            console.log(`Player left: ${data.clientId}`);
            if (this.game.removePlayer) {
                this.game.removePlayer(data.clientId);
            }
        };
        
        this.handlers[MessageType.BULLET_CREATE] = (data) => {
            if (this.game.addBullet) {
                const bulletData = {
                    id: data.id,
                    x: data.x,
                    y: data.y,
                    vx: Math.cos(data.angle) * data.speed,
                    vy: Math.sin(data.angle) * data.speed,
                    ownerId: data.ownerId,
                    damage: data.damage || 10,
                    lifetime: data.lifetime || 3.0,
                    width: data.width || 5,
                    height: data.height || 5
                };
                this.game.addBullet(bulletData);
            }
        };
        
        this.handlers[MessageType.COLLISION_RESULT] = (data) => {
            if (data.valid && this.game.applyCollision) {
                this.game.applyCollision(data);
            }
        };
        
        this.handlers[MessageType.CHUNK_DATA] = (data) => {
            console.log(`Received chunk data for (${data.chunkX}, ${data.chunkY})`);
            
            // Create a simple global object to store map data for debugging
            if (!window.mapDebug) {
                window.mapDebug = {
                    mapId: localStorage.getItem('currentMapId') || 'unknown',
                    chunks: {}
                };
                console.log("Map debug object created. Access it via window.mapDebug in the console");
            }
            
            // Store chunk data in the global object
            const chunkKey = `${data.chunkX},${data.chunkY}`;
            window.mapDebug.chunks[chunkKey] = data.chunk;
            
            if (this.game.setChunkData) {
                this.game.setChunkData(data.chunkX, data.chunkY, data.chunk);
            }
        };
        
        this.handlers[MessageType.CHUNK_NOT_FOUND] = (data) => {
            console.warn(`Chunk not found: (${data.chunkX}, ${data.chunkY})`);
            if (this.game.generateFallbackChunk) {
                this.game.generateFallbackChunk(data.chunkX, data.chunkY);
            }
        };
        
        // Handle pong messages for latency calculation
        this.handlers[MessageType.PONG] = (data) => {
            const latency = Date.now() - this.lastPingTime;
            console.log(`Server ping: ${latency}ms`);
        };
    }
    
    /**
     * Connect to the WebSocket server
     * @returns {Promise} Resolves when connected
     */
    connect() {
        return new Promise((resolve, reject) => {
            if (this.connected) {
                resolve();
                return;
            }
            
            if (this.connecting) {
                this.messageQueue.push({ resolve, reject });
                return;
            }
            
            this.connecting = true;
            
            try {
                // Get stored map ID for reconnection
                const storedMapId = localStorage.getItem('currentMapId');
                let serverUrl = this.serverUrl;
                
                // Include map ID in URL if available
                if (storedMapId) {
                    console.log(`Found stored map ID: ${storedMapId}`);
                    const separator = this.serverUrl.includes('?') ? '&' : '?';
                    serverUrl = `${this.serverUrl}${separator}mapId=${storedMapId}`;
                    console.log(`Connecting with map ID: ${serverUrl}`);
                }
                
                console.log(`Connecting to server: ${serverUrl}`);
                this.socket = new WebSocket(serverUrl);
                
                // Set binary type for ArrayBuffer data
                this.socket.binaryType = 'arraybuffer';
                
                this.socket.onopen = () => {
                    console.log('Connected to server');
                    this.connected = true;
                    this.connecting = false;
                    this.reconnectAttempts = 0;
                    
                    // Send handshake
                    this.sendHandshake();
                    
                    // Start ping
                    this.startPing();
                    
                    // Drain message queue
                    this.drainMessageQueue();
                    
                    resolve();
                };
                
                this.socket.onmessage = (event) => {
                    this.handleMessage(event.data);
                };
                
                this.socket.onclose = (event) => {
                    console.log(`Disconnected from server: ${event.code} - ${event.reason}`);
                    this.connected = false;
                    this.connecting = false;
                    this.stopPing();
                    this.attemptReconnect();
                    reject(new Error(`Disconnected from server: ${event.code} - ${event.reason}`));
                };
                
                this.socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.connecting = false;
                    reject(error);
                };
            } catch (error) {
                console.error('Failed to connect to server:', error);
                this.connecting = false;
                reject(error);
            }
        });
    }
    
    /**
     * Attempt to reconnect to the server
     */
    attemptReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.log('Maximum reconnect attempts reached');
            if (this.game.handleDisconnect) {
                this.game.handleDisconnect();
            }
            return;
        }
        
        this.reconnectAttempts++;
        
        console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);
        
        setTimeout(() => {
            this.connect().catch((error) => {
                console.error("Reconnect attempt failed:", error.message);
            });
        }, this.reconnectDelay * this.reconnectAttempts);
    }
    
    /**
     * Start the ping interval
     * @private
     */
    startPing() {
        this.stopPing();
        this.pingInterval = setInterval(() => {
            this.sendPing();
        }, 30000); // Every 30 seconds
    }
    
    /**
     * Stop the ping interval
     * @private
     */
    stopPing() {
        if (this.pingInterval) {
            clearInterval(this.pingInterval);
            this.pingInterval = null;
        }
    }
    
    /**
     * Send a ping message
     * @private
     */
    sendPing() {
        this.lastPingTime = Date.now();
        this.send(MessageType.PING, { time: this.lastPingTime });
    }
    
    /**
     * Send handshake message
     * @private
     */
    sendHandshake() {
        this.send(MessageType.HANDSHAKE, {
            clientTime: Date.now(),
            screenWidth: window.innerWidth,
            screenHeight: window.innerHeight
        });
    }
    
    /**
     * Send queued messages after connection is established
     */
    drainMessageQueue() {
        while (this.messageQueue.length > 0) {
            const message = this.messageQueue.shift();
            if (message.resolve) {
                message.resolve();
            } else {
                this.send(message.type, message.data);
            }
        }
    }
    
    /**
     * Handle an incoming WebSocket message
     * @param {ArrayBuffer} data - Binary message data
     */
    handleMessage(data) {
        try {
            // Decode binary packet
            const packet = BinaryPacket.decode(data);
            const { type, data: messageData } = packet;
            
            // Diagnostic: Always log PLAYER_LIST messages raw format for debugging
            // This will help understand exactly what the server is sending
            if (type === MessageType.PLAYER_LIST) {
                console.log('=== RAW PLAYER_LIST MESSAGE ===');
                console.log('Raw message data:', messageData);
                console.log('Type of data:', typeof messageData);
                console.log('Keys:', Object.keys(messageData));
                console.log('Has players property:', messageData.hasOwnProperty('players'));
                console.log('================================');
                
                // Store the last player list message for diagnostics
                this.lastPlayerListMessage = messageData;
            }
            
            // Update server time offset
            if (messageData.timestamp) {
                this.lastServerTime = messageData.timestamp;
                this.serverTimeOffset = Date.now() - messageData.timestamp;
            }
            
            // Enhanced logging for important message types
            switch (type) {
                case MessageType.WORLD_UPDATE:
                    if (messageData.enemies && messageData.enemies.length > 0) {
                        console.log(`World update: ${messageData.enemies.length} enemies, ${messageData.bullets ? messageData.bullets.length : 0} bullets, ${Object.keys(messageData.players || {}).length} players`);
                    }
                    break;
                case MessageType.BULLET_LIST:
                    console.log(`Received bullets list: ${messageData.bullets ? messageData.bullets.length : 0} bullets`);
                    break;
                case MessageType.ENEMY_LIST:
                    console.log(`Received enemies list: ${messageData.enemies ? messageData.enemies.length : 0} enemies`);
                    if (messageData.enemies && messageData.enemies.length > 0) {
                        console.log(`Enemy sample: ID=${messageData.enemies[0].id}, Pos=(${messageData.enemies[0].x.toFixed(2)}, ${messageData.enemies[0].y.toFixed(2)}), Health=${messageData.enemies[0].health}`);
                    }
                    break;
                case MessageType.COLLISION_RESULT:
                    console.log(`Collision result: valid=${messageData.valid}, targetId=${messageData.targetId}, damage=${messageData.damage}, killed=${messageData.killed}`);
                    break;
            }
            
            // Call the handler for this message type
            if (this.handlers[type]) {
                this.handlers[type](messageData);
            } else {
                console.warn(`No handler for message type: ${type}`);
            }
        } catch (error) {
            console.error('Error handling message:', error);
        }
    }
    
    /**
     * Send a message to the server
     * @param {number} type - Message type
     * @param {Object} data - Message data
     */
    send(type, data) {
        if (!this.connected) {
            this.messageQueue.push({ type, data });
            console.log(`Queued message type ${type} for later sending`);
            return false;
        }
        
        try {
            // Encode binary packet
            const packet = BinaryPacket.encode(type, data);
            
            // Send packet
            this.socket.send(packet);
            return true;
        } catch (error) {
            console.error('Error sending message:', error);
            return false;
        }
    }
    
    /**
     * Send player update to server
     * @param {Object} playerData - Player state data
     */
    sendPlayerUpdate(playerData) {
        if (playerData) {
            //console.log(`Sending player update: pos=(${playerData.x ? playerData.x.toFixed(2) : 'undefined'}, ${playerData.y ? playerData.y.toFixed(2) : 'undefined'}), angle=${playerData.angle ? playerData.angle.toFixed(2) : 'undefined'}`);
        }
        return this.send(MessageType.PLAYER_UPDATE, playerData);
    }
    
    /**
     * Send shoot event to server
     * @param {Object} bulletData - Bullet data
     */
    sendShoot(bulletData) {
        console.log(`Sending shoot event: pos=(${bulletData.x.toFixed(2)}, ${bulletData.y.toFixed(2)}), angle=${bulletData.angle.toFixed(2)}, speed=${bulletData.speed}`);
        return this.send(MessageType.BULLET_CREATE, bulletData);
    }
    
    /**
     * Send collision to server
     * @param {Object} collisionData - Collision data
     */
    sendCollision(collisionData) {
        return this.send(MessageType.COLLISION, collisionData);
    }
    
    /**
     * Request a map chunk from the server
     * @param {number} chunkX - Chunk X coordinate
     * @param {number} chunkY - Chunk Y coordinate
     */
    requestChunk(chunkX, chunkY) {
        return this.send(MessageType.CHUNK_REQUEST, { chunkX, chunkY });
    }
    
    /**
     * Register a message handler
     * @param {number} type - Message type
     * @param {Function} handler - Message handler
     */
    on(type, handler) {
        if (typeof handler === 'function') {
            this.handlers[type] = handler;
        }
    }
    
    /**
     * Get the estimated server time
     * @returns {number} Server time in milliseconds
     */
    getServerTime() {
        return Date.now() - this.serverTimeOffset;
    }
    
    /**
     * Check if connected to server
     * @returns {boolean} True if connected
     */
    isConnected() {
        return this.connected;
    }
    
    /**
     * Get the client ID
     * @returns {string} Client ID
     */
    getClientId() {
        return this.clientId;
    }
    
    /**
     * Disconnect from the server
     */
    disconnect() {
        this.stopPing();
        
        if (this.socket) {
            this.socket.close();
            this.socket = null;
        }
        
        this.connected = false;
        this.connecting = false;
    }
    
    /**
     * Request a specific map by ID
     * @param {string} mapId - Map ID to request
     */
    requestMap(mapId) {
        if (!this.isConnected()) {
            console.warn("Cannot request map: not connected to server");
            return;
        }
        
        console.log(`Requesting map: ${mapId}`);
        this.send(MessageType.MAP_REQUEST, {
            mapId
        });
    }
    
    /**
     * Request the current player list from the server
     * This is useful for diagnostics
     */
    requestPlayerList() {
        console.log("Sending player list request to server");
        return this.send(MessageType.PLAYER_LIST_REQUEST, {
            clientId: this.clientId,
            timestamp: Date.now()
        });
    }
}

/**
* BinaryPacket - Utility for efficient binary packet encoding/decoding
*/
export class BinaryPacket {
    /**
     * Create a binary packet with a specific message type
     * @param {number} type - Message type ID
     * @param {Object} data - Message data
     * @returns {ArrayBuffer} Binary packet
     */
    static encode(type, data) {
        // Convert data to JSON string for flexibility
        const jsonStr = JSON.stringify(data);
        const jsonBytes = new TextEncoder().encode(jsonStr);
        
        // Create packet: [1 byte type][4 byte length][jsonBytes]
        const packet = new ArrayBuffer(5 + jsonBytes.byteLength);
        const view = new DataView(packet);
        
        // Write type and length
        view.setUint8(0, type);
        view.setUint32(1, jsonBytes.byteLength, true); // Little-endian
        
        // Write JSON data
        new Uint8Array(packet, 5).set(jsonBytes);
        
        return packet;
    }
    
    /**
     * Decode a binary packet
     * @param {ArrayBuffer} packet - Binary packet
     * @returns {Object} Decoded packet {type, data}
     */
    static decode(packet) {
        const view = new DataView(packet);
        
        // Read type and length
        const type = view.getUint8(0);
        const length = view.getUint32(1, true); // Little-endian
        
        // Read JSON data
        const jsonBytes = new Uint8Array(packet, 5, length);
        const jsonStr = new TextDecoder().decode(jsonBytes);
        
        // Parse JSON data
        try {
            const data = JSON.parse(jsonStr);
            return { type, data };
        } catch (error) {
            console.error('Error parsing packet JSON:', error);
            return { type, data: {} };
        }
    }
}

/**
* Message type constants
*/
export const MessageType = {
    // System messages
    HEARTBEAT: 0,
    
    // Connection messages
    HANDSHAKE: 1,
    HANDSHAKE_ACK: 2,
    PING: 3,
    PONG: 4,
    
    // Game state messages
    PLAYER_JOIN: 10,
    PLAYER_LEAVE: 11,
    PLAYER_UPDATE: 12,
    PLAYER_LIST: 13,
    
    // Entity messages
    ENEMY_LIST: 20,
    ENEMY_UPDATE: 21,
    ENEMY_DEATH: 22,
    
    // Bullet messages
    BULLET_CREATE: 30,
    BULLET_LIST: 31,
    BULLET_REMOVE: 32,
    
    // Collision messages
    COLLISION: 40,
    COLLISION_RESULT: 41,
    
    // Map messages
    MAP_INFO: 50,
    CHUNK_REQUEST: 51,
    CHUNK_DATA: 52,
    CHUNK_NOT_FOUND: 53,
    
    // World update
    WORLD_UPDATE: 60,
    
    // Map request
    MAP_REQUEST: 70,
    
    // Player list request
    PLAYER_LIST_REQUEST: 80
};

// =========================================
// FILE: public/src/networking.js
// =========================================

// networking.js

import { map, setMap, setTexMap } from './src/map/map.js';
import { initializePlayers, updatePlayers, bullets } from './src/entities/entities.js';
import { player } from './src/game/gamestate.js';

// === NETWORKING SETUP ===
export const socket = new WebSocket('ws://127.0.0.1:3000');

socket.addEventListener('open', () => {
  console.log('[WebSocket] Connected to the server');
});

socket.addEventListener('error', error => {
  console.error('[WebSocket] Error occurred:', error);
});

socket.addEventListener('close', (event) => {
  console.log('[WebSocket] Disconnected from the server', event);
  if (event.wasClean) {
    console.log(`[WebSocket] Connection closed cleanly, code=${event.code}, reason=${event.reason}`);
  } else {
    console.warn('[WebSocket] Connection died unexpectedly');
  }
});

socket.addEventListener('message', event => {
  try {
    const data = JSON.parse(event.data);
    console.log(`[WebSocket] Received message: ${data.type}`, data);

    switch (data.type) {
      case 'MAP_UPDATE':
        handleMapUpdate(data);
        break;
      case 'TEXTURE_MAP':
        handleTextureMap(data);
        break;
      case 'NEW_TEXTURE_MAP':
        handleNewTextureMap(data);
        break;
      case 'MAP':
        handleFullMap(data);
        break;
      case 'INIT':
        handleInit(data);
        break;
      case 'UPDATE_PLAYER':
        handleUpdatePlayer(data);
        break;
      case 'YOUR_ID':
        handleYourId(data);
        break;
      case 'NEW_BULLET':
        handleNewBullet(data);
        break;
      case 'UPDATE_BULLETS':
        handleUpdateBullets(data);
        break;
      default:
        console.warn('[WebSocket] Unhandled message type:', data.type);
    }
  } catch (err) {
    console.error('[WebSocket] Error parsing message:', err, event.data);
  }
});

// === MESSAGE HANDLING FUNCTIONS ===

// Handle 'MAP_UPDATE' messages
function handleMapUpdate(data) {
  const { location, block } = data;
  if (typeof location === 'number' && typeof block !== 'undefined') {
    map[location] = block;
    console.log('[MAP_UPDATE] Map updated at location:', location, 'with block:', block);
  } else {
    console.warn('[MAP_UPDATE] Invalid data:', data);
  }
}

// Handle 'TEXTURE_MAP' messages
function handleTextureMap(data) {
  const { texMap: receivedTexMap } = data;
  if (receivedTexMap && typeof receivedTexMap === 'object') {
    const updatedTexMap = new Map(Object.entries(receivedTexMap).map(([key, value]) => [Number(key), value]));
    setTexMap(updatedTexMap);
    console.log('[TEXTURE_MAP] Texture map updated');
  } else {
    console.warn('[TEXTURE_MAP] Invalid data:', data);
  }
}

// Handle 'NEW_TEXTURE_MAP' messages
function handleNewTextureMap(data) {
  console.log('[NEW_TEXTURE_MAP] Received new texture map:', data);
  // Update texMap or perform other actions here
}

// Handle 'MAP' messages
function handleFullMap(data) {
  const { map: receivedMap } = data;
  if (Array.isArray(receivedMap)) {
    setMap(new Uint8Array(receivedMap));
    console.log('[MAP] Full map received and set');
  } else {
    console.warn('[MAP] Invalid data:', data);
  }
}

// Handle 'INIT' messages
function handleInit(data) {
  const { players, playerId } = data;
  if (players && typeof players === 'object') {
    initializePlayers(players);
    handleYourId({ playerId });
    console.log('[INIT] Initialization complete with players data');
  } else {
    console.warn('[INIT] Invalid data:', data);
  }
}

// Handle 'UPDATE_PLAYER' messages
function handleUpdatePlayer(data) {
  const { players } = data;
  if (players && typeof players === 'object') {
    updatePlayers(players);
    console.log('[UPDATE_PLAYER] Players updated:', players);
  } else {
    console.warn('[UPDATE_PLAYER] Invalid data:', data);
  }
}

// Handle 'YOUR_ID' messages
let myId; // Export this if other modules need to access the player's ID
function handleYourId(data) {
  const { playerId } = data;
  if (typeof playerId === 'number') {
    myId = playerId;
    player.id = myId;
    player.tx = ((myId % 10) * 8) % 56;
    console.log('[YOUR_ID] Assigned player ID:', myId);
  } else {
    console.warn('[YOUR_ID] Invalid data:', data);
  }
}

// Handle 'NEW_BULLET' messages
function handleNewBullet(data) {
  const { bullet } = data;
  if (bullet && typeof bullet === 'object') {
    bullets.push(bullet);
    console.log('[NEW_BULLET] New bullet added:', bullet);
  } else {
    console.warn('[NEW_BULLET] Invalid data:', data);
  }
}

// Handle 'UPDATE_BULLETS' messages
function handleUpdateBullets(data) {
  const { bullets: receivedBullets } = data;
  if (Array.isArray(receivedBullets)) {
    bullets.length = 0; // Clear existing bullets
    receivedBullets.forEach(bullet => bullets.push(bullet));
    console.log('[UPDATE_BULLETS] Bullets array updated');
  } else {
    console.warn('[UPDATE_BULLETS] Invalid data:', data);
  }
}

// === PLAYER MANAGEMENT ===

// Function to send player data to the server
export function sendPlayerData(playerData) {
  if (socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({ type: 'UPDATE_PLAYER', playerData }));
    console.log('[WebSocket] Sent player data:', playerData);
  } else {
    console.warn('[WebSocket] Cannot send data. ReadyState:', socket.readyState);
  }
}

// === PLAYER DATA SYNC ===

setTimeout(() => {
  setInterval(() => {
    const playerData = {
      name: player.name,
      x: player.x,
      y: player.y,
      r: player.r,
      // Add other relevant player data here
    };
    sendPlayerData(playerData);
  }, 1000 / 60); // Sends data at ~60 times per second
}, 1000); // Initial delay of 1 second

// === EXPORTS ===
export { myId };


// =========================================
// FILE: public/src/render/render.js
// =========================================

// src/render/render.js

import { gameState } from '../game/gamestate.js';
import { TILE_SIZE, SCALE } from '../constants/constants.js';
import { spriteManager } from '../assets/spriteManager.js';
// Import view renderers - comment these out if they cause circular references
// They should be available on the window object anyway
// import { renderTopDownView } from './renderTopDown.js';
// import { renderStrategicView } from './renderStrategic.js';

// Get 2D Canvas Context
const canvas2D = document.getElementById('gameCanvas');
const ctx = canvas2D.getContext('2d');

// Rendering parameters
const scaleFactor = SCALE;

/**
 * Render the character
 */
export function renderCharacter() {
  const character = gameState.character;
  if (!character) {
    console.error("Cannot render character: character not defined in gameState");
    return;
  }

  // Debug: Log the current view type to verify it's being detected correctly
  //console.log(`[renderCharacter] Current view type: ${gameState.camera?.viewType}`);

  // Determine scale factor based on view type
  let isStrategicView = gameState.camera?.viewType === 'strategic';
  let viewScaleFactor = isStrategicView ? 0.5 : 1.0; // FIXED back to 0.5 for strategic view (was 0.25)
  let effectiveScale = SCALE * viewScaleFactor; 

  // Debug: Log the scale factor being used
  //console.log(`[renderCharacter] Using scale factor: ${viewScaleFactor}, effectiveScale: ${effectiveScale}`);

  // Use the player's draw method if it exists
  if (character.draw && typeof character.draw === 'function') {
    // Directly set a flag on the character to ensure proper scaling
    character._isStrategicView = isStrategicView;
    character._viewScaleFactor = viewScaleFactor;
    
    // We'll still use the default draw method, but with view scaling info attached
    character.draw(ctx, gameState.camera.position);
    return;
  }

  // Fallback to old rendering method if draw method doesn't exist
  const charSheetObj = spriteManager.getSpriteSheet('character_sprites');
  if (!charSheetObj) {
    console.warn("Character sprite sheet not loaded");
    
    // Draw a placeholder rectangle if sprite sheet not available
    ctx.fillStyle = 'red';
    
    // Get screen dimensions
    const screenWidth = canvas2D.width;
    const screenHeight = canvas2D.height;
    
    // Calculate screen position (center of screen)
    const screenX = screenWidth / 2;
    const screenY = screenHeight / 2;
    
    // Draw rectangle with view-dependent scaling
    ctx.fillRect(
      screenX - (character.width * effectiveScale) / 2,
      screenY - (character.height * effectiveScale) / 2,
      character.width * effectiveScale,
      character.height * effectiveScale
    );
    return;
  }

  // Older sprite-based rendering
  const characterSpriteSheet = charSheetObj.image;
  
  // Get screen dimensions
  const screenWidth = canvas2D.width;
  const screenHeight = canvas2D.height;
  
  // Calculate screen position (center of screen)
  const screenX = screenWidth / 2;
  const screenY = screenHeight / 2;
  
  // Save the canvas state
  ctx.save();
  
  // If character has a rotation, rotate around character center
  if (typeof character.rotation === 'number') {
    ctx.translate(screenX, screenY);
    ctx.rotate(character.rotation);
    
    // Get sprite coordinates
    const spriteX = character.spriteX !== undefined ? character.spriteX : 0;
    const spriteY = character.spriteY !== undefined ? character.spriteY : 0;
    
    // Draw character centered at (0,0) after translation with view-dependent scaling
    ctx.drawImage(
      characterSpriteSheet,
      spriteX, spriteY,
      TILE_SIZE, TILE_SIZE,
      -character.width * effectiveScale / 2, -character.height * effectiveScale / 2,
      character.width * effectiveScale, character.height * effectiveScale
    );
  } else {
    // Get sprite coordinates
    const spriteX = character.spriteX !== undefined ? character.spriteX : 0;
    const spriteY = character.spriteY !== undefined ? character.spriteY : 0;
    
    // Draw character without rotation with view-dependent scaling
    ctx.drawImage(
      characterSpriteSheet,
      spriteX, spriteY,
      TILE_SIZE, TILE_SIZE,
      screenX - character.width * effectiveScale / 2,
      screenY - character.height * effectiveScale / 2,
      character.width * effectiveScale,
      character.height * effectiveScale
    );
  }
  
  // Restore canvas state
  ctx.restore();
}

/**
 * Render all enemies
 */
export function renderEnemies() {
  // Get enemies from enemyManager
  if (!gameState.enemyManager) {
    console.warn("Cannot render enemies: enemyManager not available");
    return;
  }
  
  // Get rendered enemies from the manager
  const enemies = gameState.enemyManager.getEnemiesForRender ? 
                  gameState.enemyManager.getEnemiesForRender() : [];
  
  // If no enemies, nothing to render
  if (!enemies || !Array.isArray(enemies) || enemies.length === 0) {
    return;
  }
  
  // Get enemy sprite sheet
  const enemySheetObj = spriteManager.getSpriteSheet('enemy_sprites');
  if (!enemySheetObj) {
    console.warn("Enemy sprite sheet not loaded");
    return;
  }
  const enemySpriteSheet = enemySheetObj.image;
  
  // Get view scaling factor - FIXING back to 0.5 for strategic view
  const viewType = gameState.camera?.viewType || 'top-down';
  const viewScaleFactor = viewType === 'strategic' ? 0.5 : 1.0;
  
  // Get screen dimensions
  const screenWidth = canvas2D.width;
  const screenHeight = canvas2D.height;
  
  // Use camera's worldToScreen method if available for consistent coordinate transformation
  const useCamera = gameState.camera && typeof gameState.camera.worldToScreen === 'function';
  
  // Render each enemy
  enemies.forEach(enemy => {
    try {
      // Scale dimensions based on view type
      const width = enemy.width * SCALE * viewScaleFactor;
      const height = enemy.height * SCALE * viewScaleFactor;
      
      // FIXED: Use camera's worldToScreen method for consistent coordinate transformation
      let screenX, screenY;
      
      if (useCamera) {
        // Use camera's consistent transformation method
        const screenPos = gameState.camera.worldToScreen(
          enemy.x, 
          enemy.y, 
          screenWidth, 
          screenHeight, 
          TILE_SIZE
        );
        screenX = screenPos.x;
        screenY = screenPos.y;
      } else {
        // Fallback to direct calculation
        screenX = (enemy.x - gameState.camera.position.x) * TILE_SIZE * viewScaleFactor + screenWidth / 2;
        screenY = (enemy.y - gameState.camera.position.y) * TILE_SIZE * viewScaleFactor + screenHeight / 2;
      }
      
      // Skip if off screen (with buffer)
      const buffer = width;
      if (screenX < -buffer || screenX > screenWidth + buffer || 
          screenY < -buffer || screenY > screenHeight + buffer) {
        return;
      }

      // Save context for rotation
      ctx.save();
      
      // Apply enemy flashing effect if it's been hit
      if (enemy.isFlashing) {
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = 'red';
        ctx.fillRect(screenX - width/2, screenY - height/2, width, height);
        ctx.globalAlpha = 1.0;
      }
      
      // If enemy has a rotation, use it
      if (typeof enemy.rotation === 'number') {
        ctx.translate(screenX, screenY);
        ctx.rotate(enemy.rotation);
        ctx.drawImage(
          enemySpriteSheet,
          enemy.spriteX || 0, enemy.spriteY || 0, 
          enemy.width || 24, enemy.height || 24,
          -width/2, -height/2, width, height
        );
      } else {
        // Draw without rotation - center at the calculated screen position
        ctx.drawImage(
          enemySpriteSheet,
          enemy.spriteX || 0, enemy.spriteY || 0, 
          enemy.width || 24, enemy.height || 24,
          screenX - width/2, screenY - height/2, width, height
        );
      }
      
      // Draw health bar
      if (enemy.health !== undefined && enemy.maxHealth !== undefined) {
        const healthPercent = enemy.health / enemy.maxHealth;
        const barWidth = width;
        const barHeight = 4;
        
        // Draw background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(
          screenX - barWidth/2,
          screenY - height/2 - barHeight - 2,
          barWidth,
          barHeight
        );
        
        // Draw health - color based on percentage
        ctx.fillStyle = healthPercent > 0.6 ? 'green' : healthPercent > 0.3 ? 'yellow' : 'red';
        ctx.fillRect(
          screenX - barWidth/2,
          screenY - height/2 - barHeight - 2,
          barWidth * healthPercent,
          barHeight
        );
      }
      
      // Restore context
      ctx.restore();
    } catch (error) {
      console.error("Error rendering enemy:", error);
    }
  });
}

/**
 * Render all bullets
 */
export function renderBullets() {
  // Get camera position
  if (!gameState.camera || !gameState.projectileManager) {
    return;
  }
  
  // Get bullet data from ProjectileManager
  const bullets = gameState.projectileManager.getBulletsForRender();
  if (!bullets || bullets.length === 0) {
    return;
  }
  
  // Get view scaling factor
  const viewType = gameState.camera?.viewType || 'top-down';
  const viewScaleFactor = viewType === 'strategic' ? 0.5 : 1.0;
  
  // Get screen dimensions
  const screenWidth = canvas2D.width;
  const screenHeight = canvas2D.height;
  
  // Use camera's worldToScreen method if available for consistent coordinate transformation
  const useCamera = gameState.camera && typeof gameState.camera.worldToScreen === 'function';
  
  // Render each bullet
  bullets.forEach(bullet => {
    // Scale bullet dimensions based on view
    const size = bullet.size * SCALE * viewScaleFactor;
    
    // FIXED: Use camera's worldToScreen method for consistent coordinate transformation
    let screenX, screenY;
    
    if (useCamera) {
      // Use camera's consistent transformation method
      const screenPos = gameState.camera.worldToScreen(
        bullet.x, 
        bullet.y, 
        screenWidth, 
        screenHeight, 
        TILE_SIZE
      );
      screenX = screenPos.x;
      screenY = screenPos.y;
    } else {
      // Fallback to direct calculation
      screenX = (bullet.x - gameState.camera.position.x) * TILE_SIZE * viewScaleFactor + screenWidth / 2;
      screenY = (bullet.y - gameState.camera.position.y) * TILE_SIZE * viewScaleFactor + screenHeight / 2;
    }
    
    // Skip if off screen (with a small buffer)
    const buffer = size;
    if (
      screenX < -buffer || 
      screenX > screenWidth + buffer || 
      screenY < -buffer || 
      screenY > screenHeight + buffer
    ) {
      return;
    }
    
    // Draw the bullet based on its type
    ctx.fillStyle = bullet.color || 'white';
    ctx.beginPath();
    ctx.arc(screenX, screenY, size / 2, 0, Math.PI * 2);
    ctx.fill();
  });
}

/**
 * Complete render function for game state
 */
export function renderGame() {
  // Make sure canvas is properly sized
  if (canvas2D.width !== window.innerWidth || canvas2D.height !== window.innerHeight) {
    canvas2D.width = window.innerWidth;
    canvas2D.height = window.innerHeight;
  }
  
  // Clear the canvas - first with clearRect for best performance
  ctx.clearRect(0, 0, canvas2D.width, canvas2D.height);
  
  // Then fill with a solid background color to ensure ALL old pixels are gone
  // This is especially important in strategic view to prevent ghost artifacts
  if (gameState.camera.viewType === 'strategic') {
    // Use fully opaque black background in strategic view to prevent ghosting
    ctx.fillStyle = 'rgb(0, 0, 0)';  
  } else {
    // Use standard black in other views
    ctx.fillStyle = 'rgb(0, 0, 0)';
  }
  ctx.fillRect(0, 0, canvas2D.width, canvas2D.height);
  
  // Draw level (different based on view type)
  // Note: We don't import these functions directly to avoid circular references
  // Instead, we get them from the global scope
  const viewType = gameState.camera.viewType;
  
  try {
    // Log the availability of render functions (only occasionally to avoid console spam)
    if (Math.random() < 0.01) {
      console.log(`Render functions available: topdown=${typeof window.renderTopDownView === 'function'}, strategic=${typeof window.renderStrategicView === 'function'}`);
    }
    
    if (viewType === 'top-down') {
      if (typeof window.renderTopDownView === 'function') {
        window.renderTopDownView();
      } else {
        console.error("Top-down view render function not available");
      }
    } else if (viewType === 'strategic') {
      if (typeof window.renderStrategicView === 'function') {
        window.renderStrategicView();
      } else {
        console.error("Strategic view render function not available - make sure renderStrategic.js is loaded and window.renderStrategicView is set");
      }
    } else {
      console.error(`Unknown view type ${viewType}`);
    }
  } catch (error) {
    console.error("Error rendering game view:", error);
  }
  
  // Draw entities
  renderBullets();
  renderEnemies();
  renderPlayers();
  renderCharacter();
  
  // Draw UI elements
  renderUI();
  
  // Run coordinate system test if debug mode is enabled
  if (gameState.camera && gameState.camera.debugMode) {
    try {
      // Import directly to avoid circular dependencies
      const { testCoordinateSystem } = window.coordinateUtils;
      if (typeof testCoordinateSystem === 'function') {
        testCoordinateSystem(ctx, gameState.camera);
      }
    } catch (error) {
      console.error("Error testing coordinate system:", error);
    }
  }
}

/**
 * Render UI elements
 */
function renderUI() {
  // Draw player health bar
  if (gameState.character && gameState.character.health !== undefined) {
    const health = gameState.character.health;
    const maxHealth = gameState.character.maxHealth || 100;
    const healthPercent = health / maxHealth;
    
    const barWidth = 200;
    const barHeight = 20;
    const barX = 20;
    const barY = canvas2D.height - barHeight - 20;
    
    // Background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(barX, barY, barWidth, barHeight);
    
    // Health
    ctx.fillStyle = healthPercent > 0.6 ? 'green' : healthPercent > 0.3 ? 'yellow' : 'red';
    ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
    
    // Border
    ctx.strokeStyle = 'white';
    ctx.strokeRect(barX, barY, barWidth, barHeight);
    
    // Text
    ctx.fillStyle = 'white';
    ctx.font = '14px Arial';
    ctx.fillText(`Health: ${Math.round(health)}/${maxHealth}`, barX + 10, barY + 15);
  }
  
  // Draw network status
  if (gameState.networkManager) {
    const status = gameState.networkManager.isConnected() ? 'Connected' : 'Disconnected';
    ctx.fillStyle = gameState.networkManager.isConnected() ? 'green' : 'red';
    ctx.font = '12px Arial';
    ctx.fillText(`Server: ${status}`, canvas2D.width - 120, 20);
    
    // Add player counter to UI
    const playerCount = gameState.playerManager?.players.size || 0;
    const totalPlayers = playerCount + 1; // Add 1 for local player
    ctx.fillStyle = 'white';
    ctx.fillText(`Players: ${totalPlayers} (${playerCount} others)`, canvas2D.width - 120, 40);
  }
}

/**
 * Render all players (except the local player)
 */
export function renderPlayers() {
  // Skip if no player manager
  if (!gameState.playerManager) {
    console.error("Cannot render players: playerManager not available in gameState");
    return;
  }
  
  // Log minimally, only when really needed
  if (Math.random() < 0.01) { // Just 1% of frames
    //console.log(`[renderPlayers] Rendering ${gameState.playerManager.players.size} players. Local ID: ${gameState.playerManager.localPlayerId}`);
  }
  
  try {
    // Delegate rendering to the player manager's render method
    gameState.playerManager.render(ctx, gameState.camera.position);
  } catch (error) {
    console.error("Error rendering players:", error);
  }
}

/**
 * Render all items on the ground
 */
export function renderItems() {
  // Get items from itemManager
  if (!gameState.itemManager) {
    return;
  }
  
  // Get items for rendering
  const items = gameState.itemManager.getGroundItemsForRender ? 
                gameState.itemManager.getGroundItemsForRender() : [];
  
  // If no items, nothing to render
  if (!items || !Array.isArray(items) || items.length === 0) {
    return;
  }
  
  // Get item sprite sheet
  const itemSheetObj = spriteManager.getSpriteSheet('item_sprites');
  if (!itemSheetObj) {
    console.warn("Item sprite sheet not loaded");
    return;
  }
  const itemSpriteSheet = itemSheetObj.image;
  
  // Get view scaling factor
  const viewType = gameState.camera?.viewType || 'top-down';
  const viewScaleFactor = viewType === 'strategic' ? 0.5 : 1.0;
  
  // Get screen dimensions
  const screenWidth = canvas2D.width;
  const screenHeight = canvas2D.height;
  
  // Use camera's worldToScreen method if available for consistent coordinate transformation
  const useCamera = gameState.camera && typeof gameState.camera.worldToScreen === 'function';
  
  // Render each item
  items.forEach(item => {
    try {
      // Scale dimensions based on view type
      const width = item.width * SCALE * viewScaleFactor;
      const height = item.height * SCALE * viewScaleFactor;
      
      // FIXED: Use camera's worldToScreen method for consistent coordinate transformation
      let screenX, screenY;
      
      if (useCamera) {
        // Use camera's consistent transformation method
        const screenPos = gameState.camera.worldToScreen(
          item.x, 
          item.y, 
          screenWidth, 
          screenHeight, 
          TILE_SIZE
        );
        screenX = screenPos.x;
        screenY = screenPos.y;
      } else {
        // Fallback to direct calculation
        screenX = (item.x - gameState.camera.position.x) * TILE_SIZE * viewScaleFactor + screenWidth / 2;
        screenY = (item.y - gameState.camera.position.y) * TILE_SIZE * viewScaleFactor + screenHeight / 2;
      }
      
      // Skip if off screen (with buffer)
      const buffer = width;
      if (screenX < -buffer || screenX > screenWidth + buffer || 
          screenY < -buffer || screenY > screenHeight + buffer) {
        return;
      }
      
      // Draw the item
      ctx.drawImage(
        itemSpriteSheet,
        item.spriteX || 0, item.spriteY || 0, 
        item.width || 16, item.height || 16,
        screenX - width/2, screenY - height/2, width, height
      );
      
      // Draw item name for close items
      if (gameState.player) {
        const distanceToPlayer = Math.sqrt(
          Math.pow(item.x - gameState.player.x, 2) + 
          Math.pow(item.y - gameState.player.y, 2)
        );
        
        // Only show names for items close to the player
        if (distanceToPlayer < 2.5) {
          ctx.font = '12px Arial';
          ctx.fillStyle = 'white';
          ctx.textAlign = 'center';
          ctx.fillText(item.name || 'Unknown Item', screenX, screenY + height/2 + 15);
        }
      }
    } catch (error) {
      console.error("Error rendering item:", error);
    }
  });
}