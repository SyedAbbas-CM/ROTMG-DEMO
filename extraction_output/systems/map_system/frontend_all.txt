# MAP SYSTEM - FRONTEND

Extraction Date: 2025-04-27T00:27:23.366Z



## FILE: ClientMapManager.js.txt

```javascript
// public/src/map/ClientMapManager.js

import { Tile } from './tile.js';
import { TILE_IDS, CHUNK_SIZE } from '../constants/constants.js';
import { gameState } from '../game/gamestate.js';

/**
 * ClientMapManager - Handles loading, caching, and rendering map data from server
 */
export class ClientMapManager {
    /**
     * Create a new client map manager
     * @param {Object} options - Manager options
     * @param {NetworkManager} options.networkManager - Network manager for map data requests
     */
    constructor(options = {}) {
        this.networkManager = options.networkManager;
        this.activeMapId = null;
        this.mapMetadata = null;
        this.chunks = new Map(); // Chunk cache: "x,y" -> chunk data
        this.tileSize = 12; // Default tile size
        this.chunkSize = 16; // Default chunk size
        this.width = 0;
        this.height = 0;
        this.visibleChunks = []; // Currently visible chunks
        this.pendingChunks = new Set(); // Chunks we're currently requesting
        this.maxCachedChunks = 100; // Maximum chunks to keep in memory
        this.chunkLoadDistance = 2; // How many chunks to load around player
        
        // CRITICAL: Default to false to use server's map data
        this.proceduralEnabled = false;
        
        this.fallbackTileTypes = {
            [TILE_IDS.FLOOR]: 'floor',
            [TILE_IDS.WALL]: 'wall',
            [TILE_IDS.OBSTACLE]: 'obstacle',
            [TILE_IDS.WATER]: 'water',
            [TILE_IDS.MOUNTAIN]: 'mountain'
        };
        
        // LRU (Least Recently Used) tracking for chunk cache
        this.chunkLastAccessed = new Map(); // "x,y" -> timestamp
        
        // Event listeners
        this.eventListeners = {};
        
        console.log("ClientMapManager initialized, procedural generation disabled");
    }
    
    /**
     * Initialize the map with metadata from server
     * @param {Object} data - Map metadata
     */
    initMap(data) {
        this.activeMapId = data.mapId;
        this.mapMetadata = data;
        this.tileSize = data.tileSize || this.tileSize;
        this.chunkSize = data.chunkSize || this.chunkSize;
        this.width = data.width || 0;
        this.height = data.height || 0;
        
        console.log(`Map initialized: ${this.activeMapId} (${this.width}x${this.height})`);
        console.log(`Map properties: tileSize=${this.tileSize}, chunkSize=${this.chunkSize}`);
        
        // Clear existing chunks
        this.chunks.clear();
        this.chunkLastAccessed.clear();
        this.pendingChunks.clear();
        
        // CRITICAL: Always disable procedural generation
        this.proceduralEnabled = false;
        
        // Immediately request chunks around player position
        if (gameState && gameState.character) {
            this.updateVisibleChunks(gameState.character.x, gameState.character.y);
        }
        
        // Dispatch event
        this.dispatchEvent('mapinitialized', { mapId: this.activeMapId });
    }
    
    /**
     * Set chunk data received from server
     * @param {number} chunkX - Chunk X coordinate
     * @param {number} chunkY - Chunk Y coordinate
     * @param {Object} chunkData - Chunk data from server
     */
    setChunkData(chunkX, chunkY, chunkData) {
        const key = `${chunkX},${chunkY}`;
        
        // Track time for performance measurement
        const startTime = performance.now();
        
        // Process chunk data to match our format
        const processedChunk = this.processChunkData(chunkData);
        
        // Store chunk
        this.chunks.set(key, processedChunk);
        this.chunkLastAccessed.set(key, Date.now());
        
        // Remove from pending
        this.pendingChunks.delete(key);
        
        // Calculate processing time
        const processingTime = (performance.now() - startTime).toFixed(2);
        
        // Log more detailed chunk info but keep it infrequent to avoid spam
        if (Math.random() < 0.2) { // Only log 20% of chunks
            console.log(`[MapManager] Received chunk at (${chunkX}, ${chunkY}): ${processedChunk.length} rows x ${processedChunk[0]?.length || 0} cols (processed in ${processingTime}ms)`);
            
            // Count tile types for debugging
            const tileCounts = {};
            if (processedChunk && Array.isArray(processedChunk)) {
                for (const row of processedChunk) {
                    for (const tile of row) {
                        const type = tile?.type || 'unknown';
                        tileCounts[type] = (tileCounts[type] || 0) + 1;
                    }
                }
                // Log tile distribution
                console.log(`[MapManager] Chunk ${key} tile distribution:`, tileCounts);
            }
        }
        
        // Trim cache if needed
        this.trimChunkCache();
        
        // Dispatch event
        this.dispatchEvent('chunkloaded', { chunkX, chunkY });
    }
    
    /**
     * Process chunk data from server into our format
     * @param {Object} chunkData - Chunk data from server
     * @returns {Array} Processed chunk data
     */
    processChunkData(chunkData) {
        // Log the structure of the incoming data to help diagnose issues
        console.log(`Processing chunk data: type=${typeof chunkData}`, 
                    chunkData ? 
                    `keys=${Object.keys(chunkData).join(',')}` : 
                    'chunkData is null/undefined');
                    
        // If the chunk data is already in the right format, return it
        if (Array.isArray(chunkData)) {
            console.log(`Chunk data is already an array with ${chunkData.length} rows`);
            return chunkData;
        }
        
        // Convert from server format to client format
        const processedData = [];
        
        // Different possible formats the server might send
        let tilesArray = null;
        
        // Try to extract tiles array from different possible formats
        if (chunkData && typeof chunkData === 'object') {
            if (chunkData.tiles && Array.isArray(chunkData.tiles)) {
                tilesArray = chunkData.tiles;
                console.log(`Found tiles array in chunkData.tiles with ${tilesArray.length} rows`);
            } else if (chunkData.data && Array.isArray(chunkData.data)) {
                tilesArray = chunkData.data;
                console.log(`Found tiles array in chunkData.data with ${tilesArray.length} rows`);
            } else if (Array.isArray(chunkData.data?.tiles)) {
                tilesArray = chunkData.data.tiles;
                console.log(`Found tiles array in chunkData.data.tiles with ${tilesArray.length} rows`);
            }
        }
        
        // Process tiles array if it exists
        if (tilesArray && Array.isArray(tilesArray)) {
            for (let y = 0; y < tilesArray.length; y++) {
                const row = [];
                for (let x = 0; x < tilesArray[y].length; x++) {
                    const tileData = tilesArray[y][x];
                    let tileType, tileHeight;
                    
                    // Handle different possible formats
                    if (typeof tileData === 'number') {
                        tileType = tileData;
                        tileHeight = 0;
                    } else if (tileData && typeof tileData === 'object') {
                        tileType = tileData.type;
                        tileHeight = tileData.height || 0;
                    } else {
                        tileType = TILE_IDS.FLOOR; // Default
                        tileHeight = 0;
                    }
                    
                    // Create tile instance
                    row.push(new Tile(tileType, tileHeight));
                }
                processedData.push(row);
            }
            
            console.log(`Processed chunk data: ${processedData.length} rows x ${processedData[0]?.length || 0} columns`);
        } else {
            console.warn('No valid tiles array found in chunk data, creating default floor tiles');
            
            // Create default chunk data
            for (let y = 0; y < this.chunkSize; y++) {
                const row = [];
                for (let x = 0; x < this.chunkSize; x++) {
                    row.push(new Tile(TILE_IDS.FLOOR, 0));
                }
                processedData.push(row);
            }
            
            console.log(`Created default chunk data: ${processedData.length} rows x ${processedData[0].length} columns`);
        }
        
        return processedData;
    }
    
    /**
     * Update visible chunks based on player position
     * @param {number} playerX - Player X position in world coordinates
     * @param {number} playerY - Player Y position in world coordinates
     */
    updateVisibleChunks(playerX, playerY) {
        if (!this.networkManager) {
            console.warn("Cannot update visible chunks: network manager not available");
            return;
        }
        
        // Convert player position to tile coordinates first
        const playerTileX = Math.floor(playerX / this.tileSize);
        const playerTileY = Math.floor(playerY / this.tileSize);
        
        // Log map boundaries for debugging
        if (Math.random() < 0.01) { // Only log occasionally
            console.log(`Map boundaries: width=${this.width}, height=${this.height}`);
            console.log(`Player position in tiles: (${playerTileX}, ${playerTileY})`);
        }
        
        // Ensure player stays within map bounds (important!)
        if (this.width > 0 && this.height > 0) {
            if (playerTileX < 0 || playerTileX >= this.width || playerTileY < 0 || playerTileY >= this.height) {
                console.warn(`Player outside map bounds: (${playerTileX}, ${playerTileY}) - Map size: ${this.width}x${this.height}`);
                // Don't update chunks for out-of-bounds player
                return;
            }
        }
        
        // Convert player position to chunk coordinates (integers)
        const centerChunkX = Math.floor(playerTileX / this.chunkSize);
        const centerChunkY = Math.floor(playerTileY / this.chunkSize);
        
        // Get chunks in view distance
        const newVisibleChunks = [];
        const chunksRequested = []; // Track new chunk requests for logging
        
        // Determine valid chunk range based on map size
        const maxChunkX = this.width > 0 ? Math.ceil(this.width / this.chunkSize) - 1 : Infinity;
        const maxChunkY = this.height > 0 ? Math.ceil(this.height / this.chunkSize) - 1 : Infinity;
        
        for (let dy = -this.chunkLoadDistance; dy <= this.chunkLoadDistance; dy++) {
            for (let dx = -this.chunkLoadDistance; dx <= this.chunkLoadDistance; dx++) {
                const chunkX = centerChunkX + dx;
                const chunkY = centerChunkY + dy;
                
                // Skip if out of map bounds
                if (chunkX < 0 || chunkY < 0 || chunkX > maxChunkX || chunkY > maxChunkY) {
                    continue;
                }
                
                // Calculate chunk start in tile coordinates
                const chunkStartX = chunkX * this.chunkSize;
                const chunkStartY = chunkY * this.chunkSize;
                
                // Skip if entire chunk is outside map bounds
                if (chunkStartX >= this.width || chunkStartY >= this.height) {
                    continue;
                }
                
                const key = `${chunkX},${chunkY}`;
                newVisibleChunks.push({ x: chunkX, y: chunkY, key });
                
                // Update last accessed time
                if (this.chunks.has(key)) {
                    this.chunkLastAccessed.set(key, Date.now());
                }
                // Request chunk if not already loaded or pending
                else if (!this.pendingChunks.has(key)) {
                    this.pendingChunks.add(key);
                    try {
                        this.networkManager.requestChunk(chunkX, chunkY);
                        chunksRequested.push(`(${chunkX},${chunkY})`);
                    } catch (error) {
                        console.error(`Error requesting chunk (${chunkX}, ${chunkY}):`, error);
                        this.pendingChunks.delete(key);
                    }
                }
            }
        }
        
        // Log chunk requests in a single message to reduce console spam
        if (chunksRequested.length > 0) {
            console.log(`[MapManager] Requested ${chunksRequested.length} new chunks: ${chunksRequested.join(', ')}`);
        }
        
        // Update visible chunks list
        this.visibleChunks = newVisibleChunks;
    }
    
    /**
     * Update visible chunks without making network requests
     * Use this to prevent flickering in strategic view
     * @param {number} playerX - Player X position
     * @param {number} playerY - Player Y position
     * @param {number} [customChunkDistance] - Optional chunk load distance
     */
    updateVisibleChunksLocally(playerX, playerY, customChunkDistance) {
        // Log local update
        console.log(`[MapManager] Updating visible chunks LOCALLY around (${playerX.toFixed(1)}, ${playerY.toFixed(1)})`);
        
        // Convert player position to chunk coordinates
        const centerChunkX = Math.floor(playerX / (this.tileSize * this.chunkSize));
        const centerChunkY = Math.floor(playerY / (this.tileSize * this.chunkSize));
        
        // Use custom distance if provided, otherwise use default
        const effectiveChunkLoadDistance = customChunkDistance !== undefined ? 
            customChunkDistance : this.chunkLoadDistance;
        
        console.log(`[MapManager] Local update center chunk: (${centerChunkX}, ${centerChunkY}), distance: ${effectiveChunkLoadDistance}`);
        
        // Update visible chunks list without requesting any new chunks
        const newVisibleChunks = [];
        const missingChunks = []; // Track chunks that would be loaded if we were making network requests
        
        // Build list of currently visible chunks
        for (let dy = -effectiveChunkLoadDistance; dy <= effectiveChunkLoadDistance; dy++) {
            for (let dx = -effectiveChunkLoadDistance; dx <= effectiveChunkLoadDistance; dx++) {
                const chunkX = centerChunkX + dx;
                const chunkY = centerChunkY + dy;
                
                // Skip if out of map bounds
                if (this.mapMetadata && this.width > 0 && this.height > 0) {
                    const chunkStartX = chunkX * this.chunkSize;
                    const chunkStartY = chunkY * this.chunkSize;
                    
                    if (chunkStartX < 0 || chunkStartY < 0 || 
                        chunkStartX >= this.width || 
                        chunkStartY >= this.height) {
                        continue;
                    }
                }
                
                const key = `${chunkX},${chunkY}`;
                
                // Add to visible chunks list
                newVisibleChunks.push({ x: chunkX, y: chunkY, key });
                
                // Update last accessed time for existing chunks
                if (this.chunks.has(key)) {
                    this.chunkLastAccessed.set(key, Date.now());
                } else {
                    // Track missing chunks (only done for debugging)
                    missingChunks.push(`(${chunkX},${chunkY})`);
                }
                // No network requests here, unlike updateVisibleChunks
            }
        }
        
        // Log missing chunks for debugging
        if (missingChunks.length > 0) {
            console.log(`[MapManager] ${missingChunks.length} chunks in view distance not loaded: ${missingChunks.join(', ')}`);
        }
        
        // Update the visible chunks list
        this.visibleChunks = newVisibleChunks;
        
        // No trimming of the cache here to avoid any visual jitter
        
        // Update last position for next call
        this._lastPlayerPosition = { x: centerChunkX, y: centerChunkY };
        
        return {
            center: { x: centerChunkX, y: centerChunkY },
            loadedChunks: this.visibleChunks.length - missingChunks.length,
            missingChunks: missingChunks.length
        };
    }
    
    /**
     * Trim the chunk cache to stay under the maximum limit
     */
    trimChunkCache() {
        if (this.chunks.size <= this.maxCachedChunks) {
            return;
        }
        
        // Get chunks sorted by last accessed time (oldest first)
        const sortedChunks = Array.from(this.chunkLastAccessed.entries())
            .sort((a, b) => a[1] - b[1]);
        
        // Calculate how many to remove
        const removeCount = this.chunks.size - this.maxCachedChunks;
        
        // Remove oldest chunks
        for (let i = 0; i < removeCount; i++) {
            const [key] = sortedChunks[i];
            this.chunks.delete(key);
            this.chunkLastAccessed.delete(key);
        }
        
            console.log(`Trimmed ${removeCount} chunks from cache`);
    }
    
    /**
     * Get a specific chunk
     * @param {number} chunkX - Chunk X coordinate
     * @param {number} chunkY - Chunk Y coordinate
     * @returns {Array|null} Chunk data or null if not loaded
     */
    getChunk(chunkX, chunkY) {
        const key = `${chunkX},${chunkY}`;
        
        // Update last accessed time
        if (this.chunks.has(key)) {
            this.chunkLastAccessed.set(key, Date.now());
            return this.chunks.get(key);
        }
        
        // Request chunk if not already pending
        if (this.networkManager && !this.pendingChunks.has(key)) {
            this.pendingChunks.add(key);
            try {
                this.networkManager.requestChunk(chunkX, chunkY);
                console.log(`Requested chunk (${chunkX}, ${chunkY}) on-demand`);
            } catch (error) {
                console.error(`Error requesting chunk (${chunkX}, ${chunkY}):`, error);
                this.pendingChunks.delete(key);
            }
        }
        
        return null;
    }
    
    /**
     * Get a specific tile
     * @param {number} x - Tile X coordinate
     * @param {number} y - Tile Y coordinate
     * @returns {Tile|null} Tile object or null if not found
     */
    getTile(x, y) {
        // STRICT MAP BOUNDARY CHECK: Only allow coordinates within map bounds
        if (x < 0 || y < 0 || (this.width > 0 && x >= this.width) || (this.height > 0 && y >= this.height)) {
            console.log(`Attempted to get tile outside map bounds: (${x}, ${y}), map size: ${this.width}x${this.height}`);
            return new Tile(TILE_IDS.WALL, 0); // Return wall for out-of-bounds
        }
        
        // Convert to chunk coordinates
        const chunkX = Math.floor(x / this.chunkSize);
        const chunkY = Math.floor(y / this.chunkSize);
        const localX = ((x % this.chunkSize) + this.chunkSize) % this.chunkSize; // Handle negative values
        const localY = ((y % this.chunkSize) + this.chunkSize) % this.chunkSize; // Handle negative values
        
        // Get chunk
        const chunk = this.getChunk(chunkX, chunkY);
        
        // No chunk data available
        if (!chunk) {
            console.log(`No chunk data for (${chunkX}, ${chunkY}), requesting from server`);
            // Request the chunk if network manager is available
            if (this.networkManager) {
                this.networkManager.requestChunk(chunkX, chunkY);
            }
            
            // Return wall tile instead of fallback
            return new Tile(TILE_IDS.WALL, 0);
        }
        
        // Get tile from chunk
        try {
            return chunk[localY][localX];
        } catch (e) {
            console.error(`Error getting tile at (${x}, ${y}) from chunk (${chunkX}, ${chunkY}):`, e);
            return new Tile(TILE_IDS.WALL, 0);
        }
    }
    
    /**
     * Get tiles in a range (for rendering)
     * @param {number} startX - Start X coordinate
     * @param {number} startY - Start Y coordinate
     * @param {number} endX - End X coordinate
     * @param {number} endY - End Y coordinate
     * @returns {Array} Array of tile objects
     */
    getTilesInRange(startX, startY, endX, endY) {
        const tiles = [];
        
        for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
                const tile = this.getTile(x, y);
                if (tile) {
                    tiles.push({ x, y, tile });
                }
            }
        }
        
        return tiles;
    }
    
    /**
     * Check if a position is a wall or obstacle
     * @param {number} x - World X coordinate (not tile coordinates)
     * @param {number} y - World Y coordinate (not tile coordinates)
     * @returns {boolean} True if wall or obstacle
     */
    isWallOrObstacle(x, y) {
        // Track collision checks in global stats
        if (window.COLLISION_STATS) {
            window.COLLISION_STATS.totalWallChecks++;
        }

        // DEBUGGING: Enhanced coordinate conversion debugging
        const debugWalls = Math.random() < 0.02; // Reduce logging frequency to 2% of checks
        
        if (debugWalls) {
            console.log(`WALL CHECK at world (${x.toFixed(4)}, ${y.toFixed(4)})`);
        }
        
        // Add more debugging info for problematic coordinates
        const isProblematicCoord = (
            (Math.abs(x - 5) < 1.0 && Math.abs(y - 5) < 1.0) || // Near 5,5
            (Math.abs(x - 23.99) < 0.1 && Math.abs(y - 24) < 0.1) || // Near the reported coordinate mismatch
            debugWalls // Randomly selected checks
        );
        
        if (isProblematicCoord) {
            console.log(`DETAILED WALL CHECK at world (${x.toFixed(4)}, ${y.toFixed(4)}):
- Using tileSize: ${this.tileSize}, map dimensions: ${this.width}x${this.height}
- Raw tile calculation: (${(x / this.tileSize).toFixed(4)}, ${(y / this.tileSize).toFixed(4)})
- Converting to tile: (${Math.floor(x / this.tileSize)}, ${Math.floor(y / this.tileSize)})
- Percentage within tile: (${((x % this.tileSize) / this.tileSize).toFixed(4)}, ${((y % this.tileSize) / this.tileSize).toFixed(4)})`);
        }

        // Check if we're dealing with a possibly incorrect server-sent position
        const specialCaseBoundary = 10; // Special handling for small coordinates that might be in tiles already
        if (x < specialCaseBoundary && y < specialCaseBoundary && this.tileSize > 1) {
            // Check if these might actually be tile coordinates sent mistakenly as world coordinates
            // Get the tile directly to check
            const tile = this.getTile(Math.floor(x), Math.floor(y));
            if (tile) {
                const isWall = tile.type === TILE_IDS.WALL || 
                      tile.type === TILE_IDS.OBSTACLE || 
                      tile.type === TILE_IDS.MOUNTAIN ||
                      tile.type === TILE_IDS.WATER;
                
                if (isProblematicCoord) {
                    console.warn(`COORDINATE FIX ATTEMPT: Interpreted small world coord (${x.toFixed(4)}, ${y.toFixed(4)}) ` +
                             `as tile coord (${Math.floor(x)}, ${Math.floor(y)}), isWall=${isWall}, tileType=${tile.type}`);
                }
                
                if (isWall) {
                    // Track wall collision in global stats
                    if (window.COLLISION_STATS) {
                        window.COLLISION_STATS.wallCollisions++;
                        window.COLLISION_STATS.lastWallCollision = Date.now();
                    }
                    return true;
                }
            }
        }
        
        // Convert from world coordinates to tile coordinates - regular handling
        const tileX = Math.floor(x / this.tileSize);
        const tileY = Math.floor(y / this.tileSize);
        
        // Enhanced debugging for coordinate conversion issues
        if (isProblematicCoord) {
            // Calculate tile boundaries
            const tileLeft = tileX * this.tileSize;
            const tileRight = (tileX + 1) * this.tileSize;
            const tileTop = tileY * this.tileSize;
            const tileBottom = (tileY + 1) * this.tileSize;
            
            // Calculate distance to each boundary
            const distToLeft = x - tileLeft;
            const distToRight = tileRight - x;
            const distToTop = y - tileTop;
            const distToBottom = tileBottom - y;
            
            // Find closest boundary
            const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
            let closestEdge = "unknown";
            if (minDist === distToLeft) closestEdge = "left";
            else if (minDist === distToRight) closestEdge = "right";
            else if (minDist === distToTop) closestEdge = "top";
            else if (minDist === distToBottom) closestEdge = "bottom";
            
            console.log(`DETAILED TILE INFO for world (${x.toFixed(4)}, ${y.toFixed(4)}) -> tile (${tileX}, ${tileY}):
- Tile boundaries: Left=${tileLeft}, Right=${tileRight}, Top=${tileTop}, Bottom=${tileBottom}
- Distance to edges: Left=${distToLeft.toFixed(4)}, Right=${distToRight.toFixed(4)}, Top=${distToTop.toFixed(4)}, Bottom=${distToBottom.toFixed(4)}
- Closest edge: ${closestEdge} (${minDist.toFixed(4)} units)
- Percentage within tile: x=${((x - tileLeft) / this.tileSize).toFixed(4)}, y=${((y - tileTop) / this.tileSize).toFixed(4)}
- Tile center: (${(tileLeft + this.tileSize/2).toFixed(4)}, ${(tileTop + this.tileSize/2).toFixed(4)})
- Distance from center: ${Math.sqrt(Math.pow(x - (tileLeft + this.tileSize/2), 2) + Math.pow(y - (tileTop + this.tileSize/2), 2)).toFixed(4)}`);
            
            // Check surrounding tiles
            const surroundingTiles = [];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const checkX = tileX + dx;
                    const checkY = tileY + dy;
                    if (checkX >= 0 && checkY >= 0 && checkX < this.width && checkY < this.height) {
                        const checkTile = this.getTile(checkX, checkY);
                        if (checkTile) {
                            const isBlocking = checkTile.type === TILE_IDS.WALL || 
                                               checkTile.type === TILE_IDS.OBSTACLE || 
                                               checkTile.type === TILE_IDS.MOUNTAIN ||
                                               checkTile.type === TILE_IDS.WATER;
                            surroundingTiles.push({
                                x: checkX, 
                                y: checkY, 
                                type: checkTile.type,
                                isWall: isBlocking
                            });
                        } else {
                            surroundingTiles.push({
                                x: checkX, 
                                y: checkY, 
                                type: "no-tile",
                                isWall: true
                            });
                        }
                    }
                }
            }
            console.log(`Surrounding tiles (3x3 grid):`);
            for (let y = -1; y <= 1; y++) {
                let row = '';
                for (let x = -1; x <= 1; x++) {
                    const tile = surroundingTiles.find(t => t.x === tileX + x && t.y === tileY + y);
                    if (tile) {
                        row += tile.isWall ? 'W' : '.';
                    } else {
                        row += 'X'; // Out of bounds
                    }
                }
                console.log(row);
            }
        }
        
        // Map boundary check
        if (tileX < 0 || tileY < 0 || (this.width > 0 && tileX >= this.width) || (this.height > 0 && tileY >= this.height)) {
            // Treat outside of map as wall
            if (isProblematicCoord) {
                console.log(`WALL CHECK RESULT: TRUE (out of map bounds) - tile (${tileX}, ${tileY}) is outside map bounds ${this.width}x${this.height}`);
            }
            
            // Track wall collision in global stats (map boundary)
            if (window.COLLISION_STATS) {
                window.COLLISION_STATS.wallCollisions++;
                window.COLLISION_STATS.lastWallCollision = Date.now();
            }
            
            return true;
        }
        
        // Get actual tile
        const tile = this.getTile(tileX, tileY);
        
        // If no tile found, treat as obstacle
        if (!tile) {
            if (isProblematicCoord) {
                console.log(`WALL CHECK RESULT: TRUE (no tile) - getTile(${tileX}, ${tileY}) returned null`);
            }
            
            // Track wall collision in global stats (no tile)
            if (window.COLLISION_STATS) {
                window.COLLISION_STATS.wallCollisions++;
                window.COLLISION_STATS.lastWallCollision = Date.now();
            }
            
            return true;
        }
        
        // IMPROVED: Use tile's isWalkable method if available
        if (typeof tile.isWalkable === 'function') {
            const result = !tile.isWalkable();
            if (isProblematicCoord) {
                console.log(`WALL CHECK RESULT: ${result} (using tile.isWalkable()) - tile (${tileX}, ${tileY}) type ${tile.type}`);
            }
            
            // Track wall collision in global stats if collision detected
            if (result && window.COLLISION_STATS) {
                window.COLLISION_STATS.wallCollisions++;
                window.COLLISION_STATS.lastWallCollision = Date.now();
            }
            
            return result;
        }
        
        // IMPROVED: Use isWalkable property if it exists
        if (tile.properties && tile.properties.isWalkable !== undefined) {
            const result = !tile.properties.isWalkable;
            if (isProblematicCoord) {
                console.log(`WALL CHECK RESULT: ${result} (using tile.properties.isWalkable) - tile (${tileX}, ${tileY}) type ${tile.type}`);
            }
            
            // Track wall collision in global stats if collision detected
            if (result && window.COLLISION_STATS) {
                window.COLLISION_STATS.wallCollisions++;
                window.COLLISION_STATS.lastWallCollision = Date.now();
            }
            
            return result;
        }
        
        // Fallback: Check tile type as before for backward compatibility
        const result = tile.type === TILE_IDS.WALL || 
               tile.type === TILE_IDS.OBSTACLE || 
               tile.type === TILE_IDS.MOUNTAIN ||
               tile.type === TILE_IDS.WATER || 
               (tile.type === TILE_IDS.LAVA && TILE_IDS.LAVA !== undefined);
               
        if (isProblematicCoord) {
            console.log(`WALL CHECK RESULT: ${result} (using tile type check) - tile (${tileX}, ${tileY}) type ${tile.type}`);
        }
        
        // Track wall collision in global stats if collision detected
        if (result && window.COLLISION_STATS) {
            window.COLLISION_STATS.wallCollisions++;
            window.COLLISION_STATS.lastWallCollision = Date.now();
            
            // Store information about the wall for the debug overlay
            const wallInfo = {
                tileX,
                tileY,
                worldX: (tileX + 0.5) * this.tileSize,
                worldY: (tileY + 0.5) * this.tileSize,
                type: tile.type,
                timestamp: Date.now()
            };
            
            // Add to last walls array, limited to 10 entries
            if (!window.COLLISION_STATS.lastWalls) {
                window.COLLISION_STATS.lastWalls = [];
            }
            window.COLLISION_STATS.lastWalls.unshift(wallInfo);
            if (window.COLLISION_STATS.lastWalls.length > 10) {
                window.COLLISION_STATS.lastWalls.pop();
            }
        }
               
        return result;
    }
    
    /**
     * Generate a fallback tile when chunk not loaded
     * THIS FUNCTION IS DISABLED - We want to strictly respect map boundaries
     * @param {number} x - Tile X coordinate
     * @param {number} y - Tile Y coordinate
     * @returns {Tile} Fallback tile
     */
    /* DISABLED FALLBACK TILE GENERATION
    generateFallbackTile(x, y) {
        // Use a simple pattern for fallback tiles
        // Make map edges walls, interior floor
        if (x < 0 || y < 0 || (this.width > 0 && x >= this.width) || (this.height > 0 && y >= this.height)) {
            return new Tile(TILE_IDS.WALL, 0);
        }
        
        // Checkerboard pattern
        const isEven = (x + y) % 2 === 0;
        const tileType = isEven ? TILE_IDS.FLOOR : TILE_IDS.FLOOR;
        
        return new Tile(tileType, 0);
    }
    */
    
    /**
     * Add event listener
     * @param {string} event - Event name
     * @param {Function} callback - Event callback
     */
    addEventListener(event, callback) {
        if (!this.eventListeners[event]) {
            this.eventListeners[event] = [];
        }
        this.eventListeners[event].push(callback);
    }
    
    /**
     * Remove event listener
     * @param {string} event - Event name
     * @param {Function} callback - Event callback
     */
    removeEventListener(event, callback) {
        if (!this.eventListeners[event]) return;
        const index = this.eventListeners[event].indexOf(callback);
        if (index !== -1) {
            this.eventListeners[event].splice(index, 1);
        }
    }
    
    /**
     * Dispatch an event
     * @param {string} event - Event name
     * @param {Object} data - Event data
     */
    dispatchEvent(event, data) {
        if (!this.eventListeners[event]) return;
        for (const callback of this.eventListeners[event]) {
            callback(data);
        }
    }
    
    /**
     * Print debug information about the current map state
     * @param {boolean} [showFullChunks=false] - Whether to print full chunk data
     */
    debugPrintMapInfo(showFullChunks = false) {
        console.log('=== MAP MANAGER DEBUG INFO ===');
        console.log(`Map ID: ${this.activeMapId || 'None'}`);
        console.log(`Map Size: ${this.width}x${this.height}`);
        console.log(`Tile Size: ${this.tileSize}, Chunk Size: ${this.chunkSize}`);
        console.log(`Procedural Generation: ${this.proceduralEnabled ? 'Enabled' : 'Disabled'}`);
        console.log(`Loaded Chunks: ${this.chunks.size}`);
        console.log(`Pending Chunks: ${this.pendingChunks.size}`);
        console.log(`Visible Chunks: ${this.visibleChunks.length}`);
        
        // Print chunk locations
        const chunkLocations = Array.from(this.chunks.keys()).map(key => {
            const [x, y] = key.split(',').map(Number);
            return `(${x},${y})`;
        });
        console.log(`Chunk Locations: ${chunkLocations.join(', ')}`);
        
        // Print chunk data if requested
        if (showFullChunks) {
            console.log('=== CHUNK DATA ===');
            this.chunks.forEach((chunk, key) => {
                console.log(`Chunk ${key}:`);
                this.printChunkVisually(key, chunk);
            });
        }
        
        console.log('=============================');
    }
    
    /**
     * Print a visual representation of a chunk to the console
     * @param {string} chunkKey - The chunk key (e.g. "0,0")
     * @param {Array} chunk - The chunk data
     */
    printChunkVisually(chunkKey, chunk) {
        if (!chunk || !Array.isArray(chunk)) {
            console.log(`Chunk ${chunkKey} has invalid data format`);
            return;
        }
        
        // Define tile type symbols for visual representation
        const symbols = {
            [TILE_IDS.FLOOR]: '.',
            [TILE_IDS.WALL]: '#',
            [TILE_IDS.OBSTACLE]: 'O',
            [TILE_IDS.WATER]: '~',
            [TILE_IDS.MOUNTAIN]: '^',
            'default': '?'
        };
        
        console.log(`Chunk ${chunkKey} - ${chunk.length}x${chunk[0]?.length || 0}:`);
        
        // Build visual representation
        const visual = [];
        for (let y = 0; y < chunk.length; y++) {
            let row = '';
            for (let x = 0; x < chunk[y].length; x++) {
                const tile = chunk[y][x];
                const tileType = tile?.type || 'default';
                row += symbols[tileType] || symbols['default'];
            }
            visual.push(row);
        }
        
        // Print the visual representation
        visual.forEach(row => console.log(row));
    }
    
    /**
     * Visualize the loaded map in the browser console with color
     * @param {number} centerX - Center tile X coordinate
     * @param {number} centerY - Center tile Y coordinate
     * @param {number} width - Width in tiles to visualize
     * @param {number} height - Height in tiles to visualize
     */
    visualizeMap(centerX = null, centerY = null, width = 40, height = 20) {
        console.log('=== MAP VISUALIZATION ===');
        
        // If no center specified, use player position
        if (centerX === null || centerY === null) {
            if (gameState && gameState.character) {
                centerX = Math.floor(gameState.character.x);
                centerY = Math.floor(gameState.character.y);
            } else {
                centerX = 0;
                centerY = 0;
            }
        }
        
        console.log(`Map centered at (${centerX}, ${centerY}), showing ${width}x${height} tiles`);
        
        // Calculate boundaries
        const startX = Math.floor(centerX - width / 2);
        const startY = Math.floor(centerY - height / 2);
        const endX = startX + width;
        const endY = startY + height;
        
        // Define colors for different tile types
        const colors = {
            [TILE_IDS.FLOOR]: 'color: #8a8a8a', // Gray
            [TILE_IDS.WALL]: 'color: #d43f3f', // Red
            [TILE_IDS.OBSTACLE]: 'color: #d49f3f', // Orange
            [TILE_IDS.WATER]: 'color: #3f8ad4', // Blue
            [TILE_IDS.MOUNTAIN]: 'color: #6f6f6f', // Dark gray
            'current': 'color: #ffffff; background-color: #ff0000', // White on red for player position
            'default': 'color: #ffffff' // White
        };
        
        // Define symbols for tile types
        const symbols = {
            [TILE_IDS.FLOOR]: '·',
            [TILE_IDS.WALL]: '█',
            [TILE_IDS.OBSTACLE]: '▒',
            [TILE_IDS.WATER]: '≈',
            [TILE_IDS.MOUNTAIN]: '▲',
            'current': '⊕',
            'default': '?'
        };
        
        // Track which chunks are loaded or missing
        const loadedChunks = new Set();
        const missingChunks = new Set();
        
        // Build the visualization row by row
        for (let y = startY; y < endY; y++) {
            let row = '%c';
            let formats = [];
            
            for (let x = startX; x < endX; x++) {
                // Check if this is the player position
                const isPlayerPos = (x === centerX && y === centerY);
                
                if (isPlayerPos) {
                    row += symbols['current'];
                    formats.push(colors['current']);
                    continue;
                }
                
                // Get tile type
                const tile = this.getTile(x, y);
                
                // Track chunk status
                const chunkX = Math.floor(x / this.chunkSize);
                const chunkY = Math.floor(y / this.chunkSize);
                const chunkKey = `${chunkX},${chunkY}`;
                
                if (this.chunks.has(chunkKey)) {
                    loadedChunks.add(chunkKey);
                } else {
                    missingChunks.add(chunkKey);
                }
                
                // Add appropriate symbol with color
                if (tile) {
                    const tileType = tile.type;
                    row += '%c' + (symbols[tileType] || symbols['default']);
                    formats.push(colors[tileType] || colors['default']);
                    } else {
                    row += '%c' + '.';
                    formats.push('color: #333333'); // Dark gray for unknown/missing
                }
            }
            
            // Print the row with formats
            console.log(row, ...formats);
        }
        
        // Print chunk information
        console.log('Loaded chunks: ' + Array.from(loadedChunks).join(', '));
        console.log('Missing chunks: ' + Array.from(missingChunks).join(', '));
        console.log('===========================');
        
        // Return summary
        return {
            center: { x: centerX, y: centerY },
            loadedChunks: loadedChunks.size,
            missingChunks: missingChunks.size,
            tilesShown: width * height
        };
    }
    
    /**
     * Save current map data to a file
     * @returns {Object} Map data object
     */
    saveMapData() {
        // Get map dimensions
        const width = this.width || 64;
        const height = this.height || 64;
        
        console.log(`Saving map with dimensions ${width}x${height}`);
        
        // Initialize with 0 (floor) as default
        const tileMap = Array(height).fill().map(() => Array(width).fill(0));
        
        // Keep track of chunks and tiles processed
        const loadedChunks = new Set();
        const tilesFound = 0;
        
        // Process all loaded chunks
        for (const [key, chunk] of this.chunks.entries()) {
            const [chunkX, chunkY] = key.split(',').map(Number);
            const startX = chunkX * this.chunkSize;
            const startY = chunkY * this.chunkSize;
            
            loadedChunks.add(key);
            
            // Process each tile in the chunk
            if (chunk && Array.isArray(chunk)) {
                for (let y = 0; y < chunk.length; y++) {
                    if (!chunk[y]) continue;
                    
                    for (let x = 0; x < chunk[y].length; x++) {
                        if (!chunk[y][x]) continue;
                        
                        const globalX = startX + x;
                        const globalY = startY + y;
                        
                        // Make sure we're within the map bounds
                        if (globalX >= 0 && globalX < width && globalY >= 0 && globalY < height) {
                            if (chunk[y][x].type !== undefined) {
                                tileMap[globalY][globalX] = chunk[y][x].type;
                            }
                        }
                    }
                }
            }
        }
        
        // Format JSON with one row per line for readability
        const formattedJson = "[\n" + 
            tileMap.map(row => "  " + JSON.stringify(row)).join(",\n") + 
            "\n]";
        
        // Save the map using the browser's download capability
        try {
            const blob = new Blob([formattedJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `client_map_direct_${this.activeMapId || 'unknown'}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log(`Map data saved to ${a.download} (${loadedChunks.size} chunks)`);
            
            // Make the save map function available globally for debugging
            window.clientMapData = tileMap;
            console.log("Map data also available at window.clientMapData");
            
            return { 
                tileMap, 
                loadedChunks: loadedChunks.size,
                width,
                height
            };
        } catch (error) {
            console.error("Error saving map data:", error);
            return null;
        }
    }
}
```

---


## FILE: tile.js.txt

```javascript
// src/map/tile.js

/**
 * Enhanced Tile class with more flexible properties for rendering and collision
 */
export class Tile {
    /**
     * Create a new tile
     * @param {number} type - The TILE_IDS value of this tile
     * @param {number} height - Height value for 3D rendering (0 = flat)
     * @param {Object} properties - Additional tile properties
     * @param {number} [properties.spriteIndex] - Override the default sprite index for this tile type
     * @param {boolean} [properties.isWalkable] - Override the walkability for this tile type
     * @param {boolean} [properties.isTransparent] - Whether light can pass through this tile
     * @param {Object} [properties.customData] - Any additional custom data for this tile
     * @param {number} [properties.variation] - Variation index for tiles with multiple appearances
     */
    constructor(type, height = 0, properties = {}) {
      this.type = type; // e.g., TILE_IDS.FLOOR, TILE_IDS.WALL, etc.
      this.height = height; // Height value for 3D rendering
      
      // Default properties based on type
      const defaultProps = {
        isWalkable: ![1, 2, 3, 4].includes(type), // All except WALL, OBSTACLE, WATER, MOUNTAIN are walkable
        isTransparent: type !== 1, // All except WALL are transparent
        variation: 0, // Default variation
      };
      
      // Merge default properties with provided properties
      this.properties = {...defaultProps, ...properties};
    }
    
    /**
     * Check if this tile allows walking
     * @returns {boolean} True if walkable
     */
    isWalkable() {
      return !!this.properties.isWalkable;
    }
    
    /**
     * Get the sprite index for rendering, which might be different from the tile type
     * @returns {number} Sprite index to use for rendering
     */
    getSpriteIndex() {
      // If a specific sprite is specified, use it
      if (this.properties.spriteIndex !== undefined) {
        return this.properties.spriteIndex;
      }
      
      // Calculate sprite based on type and variation
      const variation = this.properties.variation || 0;
      return this.type + (variation * 10); // Leaving room for variations
    }
    
    /**
     * Create a copy of this tile with modified properties
     * @param {Object} newProperties - Properties to update
     * @returns {Tile} New tile with updated properties
     */
    withProperties(newProperties) {
      return new Tile(
        this.type,
        this.height,
        {...this.properties, ...newProperties}
      );
    }
    
    /**
     * Check if this tile blocks movement (is wall or obstacle)
     * @returns {boolean} True if tile blocks movement
     */
    isBlockingMovement() {
      return !this.isWalkable();
    }
  }
  
```

---


## FILE: camera.js.txt

```javascript
// src/camera.js
import { createLogger } from './utils/logger.js';

// Create a logger for the camera module
const logger = createLogger('camera');

export class Camera {
  constructor(viewType, position = { x: 0, y: 0 }, zoom = 1) {
    this.viewType = viewType; // 'top-down', 'first-person', 'strategic'
    this.position = position; // { x, y }
    this.zoom = zoom; // For top-down and strategic views
    this.rotation = { pitch: 0, yaw: 0 }; // For first-person view
    
    // View scaling factors based on view type
    this.viewScaleFactors = {
      'top-down': 4.0,
      'first-person': 1.0,
      'strategic': 0.5 // Make strategic view show more of the map
    };
    
    // Debug mode - set to false by default
    this.debugMode = false;
  }

  move(dx, dy) {
    this.position.x += dx;
    this.position.y += dy;
  }

  setZoom(zoomLevel) {
    this.zoom = zoomLevel;
  }

  setRotation(pitch, yaw) {
    this.rotation.pitch = pitch;
    this.rotation.yaw = yaw;
  }

  /**
   * Updates the camera's position to the specified coordinates.
   * @param {Object} newPosition - { x, y } coordinates to set the camera position.
   */
  updatePosition(newPosition) {
    if (newPosition.x !== undefined) this.position.x = newPosition.x;
    if (newPosition.y !== undefined) this.position.y = newPosition.y;
    
    // Log camera position when in debug mode
    if (this.debugMode) {
      console.log(`Camera position updated to: (${this.position.x.toFixed(2)}, ${this.position.y.toFixed(2)})`);
    }
  }

  /**
   * Updates the camera's rotation to the specified values.
   * @param {Object} newRotation - { pitch, yaw } angles in radians.
   */
  updateRotation(newRotation) {
    if (newRotation.pitch !== undefined) this.rotation.pitch = newRotation.pitch;
    if (newRotation.yaw !== undefined) this.rotation.yaw = newRotation.yaw;
  }
  
  /**
   * Gets the current view scale factor based on view type
   * @returns {number} The scale factor for the current view
   */
  getViewScaleFactor() {
    return this.viewScaleFactors[this.viewType] || 1.0;
  }
  
  /**
   * Converts world coordinates to screen coordinates.
   * @param {number} worldX - X coordinate in world space
   * @param {number} worldY - Y coordinate in world space
   * @param {number} screenWidth - Width of the canvas
   * @param {number} screenHeight - Height of the canvas
   * @param {number} tileSize - Tile size in pixels
   * @returns {Object} Screen coordinates {x, y}
   */
  worldToScreen(worldX, worldY, screenWidth, screenHeight, tileSize) {
    const scaleFactor = this.getViewScaleFactor();
    // This formula transforms world coordinates to screen coordinates
    const screenX = (worldX - this.position.x) * tileSize * scaleFactor + screenWidth / 2;
    const screenY = (worldY - this.position.y) * tileSize * scaleFactor + screenHeight / 2;
    
    // Debug logging (only occasionally to avoid spamming console)
    if (this.debugMode && Math.random() < 0.01) {
      console.log(`worldToScreen: 
        World (${worldX}, ${worldY}) 
        Camera (${this.position.x}, ${this.position.y}) 
        Screen (${screenX}, ${screenY})
        TileSize: ${tileSize}, ScaleFactor: ${scaleFactor}
      `);
    }
    
    return { x: screenX, y: screenY };
  }
  
  /**
   * Toggle debug mode
   * @returns {boolean} The new debug mode state
   */
  toggleDebugMode() {
    this.debugMode = !this.debugMode;
    logger.info(`Camera debug mode ${this.debugMode ? 'enabled' : 'disabled'}`);
    return this.debugMode;
  }
  
  /**
   * Get the scaling factor to apply to entity sizes based on view type
   * @param {number} baseScale - Base scale factor (usually SCALE constant)
   * @returns {number} Effective scale to use for entity rendering
   */
  getEntityScaleFactor(baseScale = 1) {
    return baseScale * this.getViewScaleFactor();
  }
  
  /**
   * Determines if a world coordinate is visible on screen
   * @param {number} worldX - X coordinate in world space
   * @param {number} worldY - Y coordinate in world space
   * @param {number} width - Entity width in world units
   * @param {number} height - Entity height in world units
   * @param {number} screenWidth - Width of the canvas
   * @param {number} screenHeight - Height of the canvas
   * @param {number} tileSize - Tile size in pixels
   * @param {number} buffer - Extra buffer to add around screen (for culling)
   * @returns {boolean} Whether the entity is on screen
   */
  isOnScreen(worldX, worldY, width, height, screenWidth, screenHeight, tileSize, buffer = 0) {
    const screen = this.worldToScreen(worldX, worldY, screenWidth, screenHeight, tileSize);
    const scaleFactor = this.getViewScaleFactor();
    
    // Extend buffer in strategic view
    const viewBuffer = this.viewType === 'strategic' ? buffer * 2 : buffer;
    
    // Use the scaled entity dimensions
    const scaledWidth = width * tileSize * scaleFactor;
    const scaledHeight = height * tileSize * scaleFactor;
    
    return screen.x + scaledWidth/2 + viewBuffer >= 0 && 
           screen.x - scaledWidth/2 - viewBuffer <= screenWidth &&
           screen.y + scaledHeight/2 + viewBuffer >= 0 && 
           screen.y - scaledHeight/2 - viewBuffer <= screenHeight;
  }
}

```

---


## FILE: coordinateUtils.js.txt

```javascript
/**
 * coordinateUtils.js
 * Utility functions for handling world-to-screen coordinate transformations
 */

import { TILE_SIZE, SCALE } from '../constants/constants.js';

/**
 * CoordinateUtils - Helper for transforming between coordinate systems
 */
export class CoordinateUtils {
  constructor() {
    this.tileSize = TILE_SIZE;
    this.debugMode = false;
  }
  
  /**
   * Convert grid coordinates to world coordinates
   * In our game, grid and world coordinates are the same numerically,
   * but they have different semantic meanings
   */
  gridToWorld(gridX, gridY) {
    return {
      x: gridX,
      y: gridY
    };
  }
  
  /**
   * Convert world coordinates to grid coordinates
   * For fractional world coordinates, this returns the grid cell the coordinates are in
   */
  worldToGrid(worldX, worldY) {
    return {
      x: Math.floor(worldX),
      y: Math.floor(worldY)
    };
  }
  
  /**
   * Convert grid coordinates to screen coordinates
   * @param {number} gridX - X position in grid space
   * @param {number} gridY - Y position in grid space
   * @param {Object} camera - Camera with position and view type
   * @param {number} screenWidth - Screen width in pixels
   * @param {number} screenHeight - Screen height in pixels
   * @returns {Object} Screen coordinates {x, y}
   */
  gridToScreen(gridX, gridY, camera, screenWidth, screenHeight) {
    // First convert to world coordinates
    const worldPos = this.gridToWorld(gridX, gridY);
    
    // Then use world to screen
    return this.worldToScreen(worldPos.x, worldPos.y, camera, screenWidth, screenHeight);
  }
  
  /**
   * Convert world coordinates to screen coordinates
   * @param {number} worldX - X position in world space
   * @param {number} worldY - Y position in world space
   * @param {Object} camera - Camera with position and view type
   * @param {number} screenWidth - Screen width in pixels
   * @param {number} screenHeight - Screen height in pixels
   * @returns {Object} Screen coordinates {x, y}
   */
  worldToScreen(worldX, worldY, camera, screenWidth, screenHeight) {
    const viewType = camera.viewType || 'top-down';
    let scaleFactor = 1.0;
    
    // Get scale factor based on view type
    if (viewType === 'strategic') {
      scaleFactor = 0.5;
    } else if (viewType === 'top-down') {
      scaleFactor = 1.0;
    }
    
    // Calculate screen coordinates
    const screenX = (worldX - camera.position.x) * this.tileSize * scaleFactor + screenWidth / 2;
    const screenY = (worldY - camera.position.y) * this.tileSize * scaleFactor + screenHeight / 2;
    
    if (this.debugMode) {
      console.log(`World (${worldX}, ${worldY}) -> Screen (${screenX}, ${screenY})`);
    }
    
    return { x: screenX, y: screenY };
  }
  
  /**
   * Convert screen coordinates to world coordinates
   * @param {number} screenX - X position in screen space
   * @param {number} screenY - Y position in screen space
   * @param {Object} camera - Camera with position and view type
   * @param {number} screenWidth - Screen width in pixels
   * @param {number} screenHeight - Screen height in pixels
   * @returns {Object} World coordinates {x, y}
   */
  screenToWorld(screenX, screenY, camera, screenWidth, screenHeight) {
    const viewType = camera.viewType || 'top-down';
    let scaleFactor = 1.0;
    
    // Get scale factor based on view type
    if (viewType === 'strategic') {
      scaleFactor = 0.5;
    } else if (viewType === 'top-down') {
      scaleFactor = 1.0;
    }
    
    // Calculate world coordinates
    const worldX = ((screenX - screenWidth / 2) / (this.tileSize * scaleFactor)) + camera.position.x;
    const worldY = ((screenY - screenHeight / 2) / (this.tileSize * scaleFactor)) + camera.position.y;
    
    return { x: worldX, y: worldY };
  }
  
  /**
   * Convert screen coordinates to grid coordinates
   * @param {number} screenX - X position in screen space
   * @param {number} screenY - Y position in screen space
   * @param {Object} camera - Camera with position and view type
   * @param {number} screenWidth - Screen width in pixels
   * @param {number} screenHeight - Screen height in pixels
   * @returns {Object} Grid coordinates {x, y}
   */
  screenToGrid(screenX, screenY, camera, screenWidth, screenHeight) {
    // First convert to world coordinates
    const worldPos = this.screenToWorld(screenX, screenY, camera, screenWidth, screenHeight);
    
    // Then convert to grid
    return this.worldToGrid(worldPos.x, worldPos.y);
  }
  
  /**
   * Toggle debug mode
   * @returns {boolean} New debug mode state
   */
  toggleDebug() {
    this.debugMode = !this.debugMode;
    return this.debugMode;
  }
}

// Create and export singleton instance
export const coordinateUtils = new CoordinateUtils();

/**
 * Initialize coordinate utilities and make them available globally
 * This makes the utilities accessible to all parts of the codebase
 */
export function initCoordinateUtils() {
  console.log('Coordinate utilities initialized');
  
  // Add to window for debugging if needed
  window.coordinateUtils = coordinateUtils;
  
  return coordinateUtils;
}

// Auto-initialize when imported
initCoordinateUtils();

/**
 * Run a visual test of the coordinate system
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} camera - Camera object
 */
export function testCoordinateSystem(ctx, camera) {
  const screenWidth = ctx.canvas.width;
  const screenHeight = ctx.canvas.height;
  
  // Draw a grid of test points
  ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
  ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
  ctx.lineWidth = 1;
  ctx.font = '10px Arial';
  
  // Draw test points in a grid around the camera
  const gridSize = 5; // Draw a 5x5 grid
  for (let x = -gridSize; x <= gridSize; x++) {
    for (let y = -gridSize; y <= gridSize; y++) {
      // Get grid position relative to camera
      const gridX = Math.floor(camera.position.x) + x;
      const gridY = Math.floor(camera.position.y) + y;
      
      // Convert to screen coordinates
      const screenPos = coordinateUtils.gridToScreen(gridX, gridY, camera, screenWidth, screenHeight);
      
      // Draw point
      ctx.beginPath();
      ctx.arc(screenPos.x, screenPos.y, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw grid coordinates (only on some points to avoid clutter)
      if (x % 2 === 0 && y % 2 === 0) {
        ctx.fillText(`(${gridX},${gridY})`, screenPos.x + 5, screenPos.y - 5);
      }
      
      // Draw tile outline
      const tileSize = TILE_SIZE * (camera.viewType === 'strategic' ? 0.5 : 1.0);
      ctx.strokeRect(
        screenPos.x - tileSize / 2,
        screenPos.y - tileSize / 2,
        tileSize,
        tileSize
      );
    }
  }
  
  // Draw camera position
  const cameraPosScreen = {
    x: screenWidth / 2,
    y: screenHeight / 2
  };
  
  ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
  ctx.beginPath();
  ctx.arc(cameraPosScreen.x, cameraPosScreen.y, 5, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw text for camera position
  ctx.fillText(`Camera: (${camera.position.x.toFixed(1)},${camera.position.y.toFixed(1)})`, 
               cameraPosScreen.x + 10, cameraPosScreen.y);
} 
```

---
