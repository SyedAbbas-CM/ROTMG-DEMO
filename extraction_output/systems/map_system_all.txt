# COMPLETE MAP SYSTEM (FRONTEND + BACKEND)

Extraction Date: 2025-04-27T00:27:23.367Z

This file contains all code related to the map system from both frontend and backend.


# FRONTEND CODE



## FILE: /map_system/frontend/ClientMapManager.js

```javascript
// public/src/map/ClientMapManager.js

import { Tile } from './tile.js';
import { TILE_IDS, CHUNK_SIZE } from '../constants/constants.js';
import { gameState } from '../game/gamestate.js';

/**
 * ClientMapManager - Handles loading, caching, and rendering map data from server
 */
export class ClientMapManager {
    /**
     * Create a new client map manager
     * @param {Object} options - Manager options
     * @param {NetworkManager} options.networkManager - Network manager for map data requests
     */
    constructor(options = {}) {
        this.networkManager = options.networkManager;
        this.activeMapId = null;
        this.mapMetadata = null;
        this.chunks = new Map(); // Chunk cache: "x,y" -> chunk data
        this.tileSize = 12; // Default tile size
        this.chunkSize = 16; // Default chunk size
        this.width = 0;
        this.height = 0;
        this.visibleChunks = []; // Currently visible chunks
        this.pendingChunks = new Set(); // Chunks we're currently requesting
        this.maxCachedChunks = 100; // Maximum chunks to keep in memory
        this.chunkLoadDistance = 2; // How many chunks to load around player
        
        // CRITICAL: Default to false to use server's map data
        this.proceduralEnabled = false;
        
        this.fallbackTileTypes = {
            [TILE_IDS.FLOOR]: 'floor',
            [TILE_IDS.WALL]: 'wall',
            [TILE_IDS.OBSTACLE]: 'obstacle',
            [TILE_IDS.WATER]: 'water',
            [TILE_IDS.MOUNTAIN]: 'mountain'
        };
        
        // LRU (Least Recently Used) tracking for chunk cache
        this.chunkLastAccessed = new Map(); // "x,y" -> timestamp
        
        // Event listeners
        this.eventListeners = {};
        
        console.log("ClientMapManager initialized, procedural generation disabled");
    }
    
    /**
     * Initialize the map with metadata from server
     * @param {Object} data - Map metadata
     */
    initMap(data) {
        this.activeMapId = data.mapId;
        this.mapMetadata = data;
        this.tileSize = data.tileSize || this.tileSize;
        this.chunkSize = data.chunkSize || this.chunkSize;
        this.width = data.width || 0;
        this.height = data.height || 0;
        
        console.log(`Map initialized: ${this.activeMapId} (${this.width}x${this.height})`);
        console.log(`Map properties: tileSize=${this.tileSize}, chunkSize=${this.chunkSize}`);
        
        // Clear existing chunks
        this.chunks.clear();
        this.chunkLastAccessed.clear();
        this.pendingChunks.clear();
        
        // CRITICAL: Always disable procedural generation
        this.proceduralEnabled = false;
        
        // Immediately request chunks around player position
        if (gameState && gameState.character) {
            this.updateVisibleChunks(gameState.character.x, gameState.character.y);
        }
        
        // Dispatch event
        this.dispatchEvent('mapinitialized', { mapId: this.activeMapId });
    }
    
    /**
     * Set chunk data received from server
     * @param {number} chunkX - Chunk X coordinate
     * @param {number} chunkY - Chunk Y coordinate
     * @param {Object} chunkData - Chunk data from server
     */
    setChunkData(chunkX, chunkY, chunkData) {
        const key = `${chunkX},${chunkY}`;
        
        // Track time for performance measurement
        const startTime = performance.now();
        
        // Process chunk data to match our format
        const processedChunk = this.processChunkData(chunkData);
        
        // Store chunk
        this.chunks.set(key, processedChunk);
        this.chunkLastAccessed.set(key, Date.now());
        
        // Remove from pending
        this.pendingChunks.delete(key);
        
        // Calculate processing time
        const processingTime = (performance.now() - startTime).toFixed(2);
        
        // Log more detailed chunk info but keep it infrequent to avoid spam
        if (Math.random() < 0.2) { // Only log 20% of chunks
            console.log(`[MapManager] Received chunk at (${chunkX}, ${chunkY}): ${processedChunk.length} rows x ${processedChunk[0]?.length || 0} cols (processed in ${processingTime}ms)`);
            
            // Count tile types for debugging
            const tileCounts = {};
            if (processedChunk && Array.isArray(processedChunk)) {
                for (const row of processedChunk) {
                    for (const tile of row) {
                        const type = tile?.type || 'unknown';
                        tileCounts[type] = (tileCounts[type] || 0) + 1;
                    }
                }
                // Log tile distribution
                console.log(`[MapManager] Chunk ${key} tile distribution:`, tileCounts);
            }
        }
        
        // Trim cache if needed
        this.trimChunkCache();
        
        // Dispatch event
        this.dispatchEvent('chunkloaded', { chunkX, chunkY });
    }
    
    /**
     * Process chunk data from server into our format
     * @param {Object} chunkData - Chunk data from server
     * @returns {Array} Processed chunk data
     */
    processChunkData(chunkData) {
        // Log the structure of the incoming data to help diagnose issues
        console.log(`Processing chunk data: type=${typeof chunkData}`, 
                    chunkData ? 
                    `keys=${Object.keys(chunkData).join(',')}` : 
                    'chunkData is null/undefined');
                    
        // If the chunk data is already in the right format, return it
        if (Array.isArray(chunkData)) {
            console.log(`Chunk data is already an array with ${chunkData.length} rows`);
            return chunkData;
        }
        
        // Convert from server format to client format
        const processedData = [];
        
        // Different possible formats the server might send
        let tilesArray = null;
        
        // Try to extract tiles array from different possible formats
        if (chunkData && typeof chunkData === 'object') {
            if (chunkData.tiles && Array.isArray(chunkData.tiles)) {
                tilesArray = chunkData.tiles;
                console.log(`Found tiles array in chunkData.tiles with ${tilesArray.length} rows`);
            } else if (chunkData.data && Array.isArray(chunkData.data)) {
                tilesArray = chunkData.data;
                console.log(`Found tiles array in chunkData.data with ${tilesArray.length} rows`);
            } else if (Array.isArray(chunkData.data?.tiles)) {
                tilesArray = chunkData.data.tiles;
                console.log(`Found tiles array in chunkData.data.tiles with ${tilesArray.length} rows`);
            }
        }
        
        // Process tiles array if it exists
        if (tilesArray && Array.isArray(tilesArray)) {
            for (let y = 0; y < tilesArray.length; y++) {
                const row = [];
                for (let x = 0; x < tilesArray[y].length; x++) {
                    const tileData = tilesArray[y][x];
                    let tileType, tileHeight;
                    
                    // Handle different possible formats
                    if (typeof tileData === 'number') {
                        tileType = tileData;
                        tileHeight = 0;
                    } else if (tileData && typeof tileData === 'object') {
                        tileType = tileData.type;
                        tileHeight = tileData.height || 0;
                    } else {
                        tileType = TILE_IDS.FLOOR; // Default
                        tileHeight = 0;
                    }
                    
                    // Create tile instance
                    row.push(new Tile(tileType, tileHeight));
                }
                processedData.push(row);
            }
            
            console.log(`Processed chunk data: ${processedData.length} rows x ${processedData[0]?.length || 0} columns`);
        } else {
            console.warn('No valid tiles array found in chunk data, creating default floor tiles');
            
            // Create default chunk data
            for (let y = 0; y < this.chunkSize; y++) {
                const row = [];
                for (let x = 0; x < this.chunkSize; x++) {
                    row.push(new Tile(TILE_IDS.FLOOR, 0));
                }
                processedData.push(row);
            }
            
            console.log(`Created default chunk data: ${processedData.length} rows x ${processedData[0].length} columns`);
        }
        
        return processedData;
    }
    
    /**
     * Update visible chunks based on player position
     * @param {number} playerX - Player X position in world coordinates
     * @param {number} playerY - Player Y position in world coordinates
     */
    updateVisibleChunks(playerX, playerY) {
        if (!this.networkManager) {
            console.warn("Cannot update visible chunks: network manager not available");
            return;
        }
        
        // Convert player position to tile coordinates first
        const playerTileX = Math.floor(playerX / this.tileSize);
        const playerTileY = Math.floor(playerY / this.tileSize);
        
        // Log map boundaries for debugging
        if (Math.random() < 0.01) { // Only log occasionally
            console.log(`Map boundaries: width=${this.width}, height=${this.height}`);
            console.log(`Player position in tiles: (${playerTileX}, ${playerTileY})`);
        }
        
        // Ensure player stays within map bounds (important!)
        if (this.width > 0 && this.height > 0) {
            if (playerTileX < 0 || playerTileX >= this.width || playerTileY < 0 || playerTileY >= this.height) {
                console.warn(`Player outside map bounds: (${playerTileX}, ${playerTileY}) - Map size: ${this.width}x${this.height}`);
                // Don't update chunks for out-of-bounds player
                return;
            }
        }
        
        // Convert player position to chunk coordinates (integers)
        const centerChunkX = Math.floor(playerTileX / this.chunkSize);
        const centerChunkY = Math.floor(playerTileY / this.chunkSize);
        
        // Get chunks in view distance
        const newVisibleChunks = [];
        const chunksRequested = []; // Track new chunk requests for logging
        
        // Determine valid chunk range based on map size
        const maxChunkX = this.width > 0 ? Math.ceil(this.width / this.chunkSize) - 1 : Infinity;
        const maxChunkY = this.height > 0 ? Math.ceil(this.height / this.chunkSize) - 1 : Infinity;
        
        for (let dy = -this.chunkLoadDistance; dy <= this.chunkLoadDistance; dy++) {
            for (let dx = -this.chunkLoadDistance; dx <= this.chunkLoadDistance; dx++) {
                const chunkX = centerChunkX + dx;
                const chunkY = centerChunkY + dy;
                
                // Skip if out of map bounds
                if (chunkX < 0 || chunkY < 0 || chunkX > maxChunkX || chunkY > maxChunkY) {
                    continue;
                }
                
                // Calculate chunk start in tile coordinates
                const chunkStartX = chunkX * this.chunkSize;
                const chunkStartY = chunkY * this.chunkSize;
                
                // Skip if entire chunk is outside map bounds
                if (chunkStartX >= this.width || chunkStartY >= this.height) {
                    continue;
                }
                
                const key = `${chunkX},${chunkY}`;
                newVisibleChunks.push({ x: chunkX, y: chunkY, key });
                
                // Update last accessed time
                if (this.chunks.has(key)) {
                    this.chunkLastAccessed.set(key, Date.now());
                }
                // Request chunk if not already loaded or pending
                else if (!this.pendingChunks.has(key)) {
                    this.pendingChunks.add(key);
                    try {
                        this.networkManager.requestChunk(chunkX, chunkY);
                        chunksRequested.push(`(${chunkX},${chunkY})`);
                    } catch (error) {
                        console.error(`Error requesting chunk (${chunkX}, ${chunkY}):`, error);
                        this.pendingChunks.delete(key);
                    }
                }
            }
        }
        
        // Log chunk requests in a single message to reduce console spam
        if (chunksRequested.length > 0) {
            console.log(`[MapManager] Requested ${chunksRequested.length} new chunks: ${chunksRequested.join(', ')}`);
        }
        
        // Update visible chunks list
        this.visibleChunks = newVisibleChunks;
    }
    
    /**
     * Update visible chunks without making network requests
     * Use this to prevent flickering in strategic view
     * @param {number} playerX - Player X position
     * @param {number} playerY - Player Y position
     * @param {number} [customChunkDistance] - Optional chunk load distance
     */
    updateVisibleChunksLocally(playerX, playerY, customChunkDistance) {
        // Log local update
        console.log(`[MapManager] Updating visible chunks LOCALLY around (${playerX.toFixed(1)}, ${playerY.toFixed(1)})`);
        
        // Convert player position to chunk coordinates
        const centerChunkX = Math.floor(playerX / (this.tileSize * this.chunkSize));
        const centerChunkY = Math.floor(playerY / (this.tileSize * this.chunkSize));
        
        // Use custom distance if provided, otherwise use default
        const effectiveChunkLoadDistance = customChunkDistance !== undefined ? 
            customChunkDistance : this.chunkLoadDistance;
        
        console.log(`[MapManager] Local update center chunk: (${centerChunkX}, ${centerChunkY}), distance: ${effectiveChunkLoadDistance}`);
        
        // Update visible chunks list without requesting any new chunks
        const newVisibleChunks = [];
        const missingChunks = []; // Track chunks that would be loaded if we were making network requests
        
        // Build list of currently visible chunks
        for (let dy = -effectiveChunkLoadDistance; dy <= effectiveChunkLoadDistance; dy++) {
            for (let dx = -effectiveChunkLoadDistance; dx <= effectiveChunkLoadDistance; dx++) {
                const chunkX = centerChunkX + dx;
                const chunkY = centerChunkY + dy;
                
                // Skip if out of map bounds
                if (this.mapMetadata && this.width > 0 && this.height > 0) {
                    const chunkStartX = chunkX * this.chunkSize;
                    const chunkStartY = chunkY * this.chunkSize;
                    
                    if (chunkStartX < 0 || chunkStartY < 0 || 
                        chunkStartX >= this.width || 
                        chunkStartY >= this.height) {
                        continue;
                    }
                }
                
                const key = `${chunkX},${chunkY}`;
                
                // Add to visible chunks list
                newVisibleChunks.push({ x: chunkX, y: chunkY, key });
                
                // Update last accessed time for existing chunks
                if (this.chunks.has(key)) {
                    this.chunkLastAccessed.set(key, Date.now());
                } else {
                    // Track missing chunks (only done for debugging)
                    missingChunks.push(`(${chunkX},${chunkY})`);
                }
                // No network requests here, unlike updateVisibleChunks
            }
        }
        
        // Log missing chunks for debugging
        if (missingChunks.length > 0) {
            console.log(`[MapManager] ${missingChunks.length} chunks in view distance not loaded: ${missingChunks.join(', ')}`);
        }
        
        // Update the visible chunks list
        this.visibleChunks = newVisibleChunks;
        
        // No trimming of the cache here to avoid any visual jitter
        
        // Update last position for next call
        this._lastPlayerPosition = { x: centerChunkX, y: centerChunkY };
        
        return {
            center: { x: centerChunkX, y: centerChunkY },
            loadedChunks: this.visibleChunks.length - missingChunks.length,
            missingChunks: missingChunks.length
        };
    }
    
    /**
     * Trim the chunk cache to stay under the maximum limit
     */
    trimChunkCache() {
        if (this.chunks.size <= this.maxCachedChunks) {
            return;
        }
        
        // Get chunks sorted by last accessed time (oldest first)
        const sortedChunks = Array.from(this.chunkLastAccessed.entries())
            .sort((a, b) => a[1] - b[1]);
        
        // Calculate how many to remove
        const removeCount = this.chunks.size - this.maxCachedChunks;
        
        // Remove oldest chunks
        for (let i = 0; i < removeCount; i++) {
            const [key] = sortedChunks[i];
            this.chunks.delete(key);
            this.chunkLastAccessed.delete(key);
        }
        
            console.log(`Trimmed ${removeCount} chunks from cache`);
    }
    
    /**
     * Get a specific chunk
     * @param {number} chunkX - Chunk X coordinate
     * @param {number} chunkY - Chunk Y coordinate
     * @returns {Array|null} Chunk data or null if not loaded
     */
    getChunk(chunkX, chunkY) {
        const key = `${chunkX},${chunkY}`;
        
        // Update last accessed time
        if (this.chunks.has(key)) {
            this.chunkLastAccessed.set(key, Date.now());
            return this.chunks.get(key);
        }
        
        // Request chunk if not already pending
        if (this.networkManager && !this.pendingChunks.has(key)) {
            this.pendingChunks.add(key);
            try {
                this.networkManager.requestChunk(chunkX, chunkY);
                console.log(`Requested chunk (${chunkX}, ${chunkY}) on-demand`);
            } catch (error) {
                console.error(`Error requesting chunk (${chunkX}, ${chunkY}):`, error);
                this.pendingChunks.delete(key);
            }
        }
        
        return null;
    }
    
    /**
     * Get a specific tile
     * @param {number} x - Tile X coordinate
     * @param {number} y - Tile Y coordinate
     * @returns {Tile|null} Tile object or null if not found
     */
    getTile(x, y) {
        // STRICT MAP BOUNDARY CHECK: Only allow coordinates within map bounds
        if (x < 0 || y < 0 || (this.width > 0 && x >= this.width) || (this.height > 0 && y >= this.height)) {
            console.log(`Attempted to get tile outside map bounds: (${x}, ${y}), map size: ${this.width}x${this.height}`);
            return new Tile(TILE_IDS.WALL, 0); // Return wall for out-of-bounds
        }
        
        // Convert to chunk coordinates
        const chunkX = Math.floor(x / this.chunkSize);
        const chunkY = Math.floor(y / this.chunkSize);
        const localX = ((x % this.chunkSize) + this.chunkSize) % this.chunkSize; // Handle negative values
        const localY = ((y % this.chunkSize) + this.chunkSize) % this.chunkSize; // Handle negative values
        
        // Get chunk
        const chunk = this.getChunk(chunkX, chunkY);
        
        // No chunk data available
        if (!chunk) {
            console.log(`No chunk data for (${chunkX}, ${chunkY}), requesting from server`);
            // Request the chunk if network manager is available
            if (this.networkManager) {
                this.networkManager.requestChunk(chunkX, chunkY);
            }
            
            // Return wall tile instead of fallback
            return new Tile(TILE_IDS.WALL, 0);
        }
        
        // Get tile from chunk
        try {
            return chunk[localY][localX];
        } catch (e) {
            console.error(`Error getting tile at (${x}, ${y}) from chunk (${chunkX}, ${chunkY}):`, e);
            return new Tile(TILE_IDS.WALL, 0);
        }
    }
    
    /**
     * Get tiles in a range (for rendering)
     * @param {number} startX - Start X coordinate
     * @param {number} startY - Start Y coordinate
     * @param {number} endX - End X coordinate
     * @param {number} endY - End Y coordinate
     * @returns {Array} Array of tile objects
     */
    getTilesInRange(startX, startY, endX, endY) {
        const tiles = [];
        
        for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
                const tile = this.getTile(x, y);
                if (tile) {
                    tiles.push({ x, y, tile });
                }
            }
        }
        
        return tiles;
    }
    
    /**
     * Check if a position is a wall or obstacle
     * @param {number} x - World X coordinate (not tile coordinates)
     * @param {number} y - World Y coordinate (not tile coordinates)
     * @returns {boolean} True if wall or obstacle
     */
    isWallOrObstacle(x, y) {
        // Track collision checks in global stats
        if (window.COLLISION_STATS) {
            window.COLLISION_STATS.totalWallChecks++;
        }

        // DEBUGGING: Enhanced coordinate conversion debugging
        const debugWalls = Math.random() < 0.02; // Reduce logging frequency to 2% of checks
        
        if (debugWalls) {
            console.log(`WALL CHECK at world (${x.toFixed(4)}, ${y.toFixed(4)})`);
        }
        
        // Add more debugging info for problematic coordinates
        const isProblematicCoord = (
            (Math.abs(x - 5) < 1.0 && Math.abs(y - 5) < 1.0) || // Near 5,5
            (Math.abs(x - 23.99) < 0.1 && Math.abs(y - 24) < 0.1) || // Near the reported coordinate mismatch
            debugWalls // Randomly selected checks
        );
        
        if (isProblematicCoord) {
            console.log(`DETAILED WALL CHECK at world (${x.toFixed(4)}, ${y.toFixed(4)}):
- Using tileSize: ${this.tileSize}, map dimensions: ${this.width}x${this.height}
- Raw tile calculation: (${(x / this.tileSize).toFixed(4)}, ${(y / this.tileSize).toFixed(4)})
- Converting to tile: (${Math.floor(x / this.tileSize)}, ${Math.floor(y / this.tileSize)})
- Percentage within tile: (${((x % this.tileSize) / this.tileSize).toFixed(4)}, ${((y % this.tileSize) / this.tileSize).toFixed(4)})`);
        }

        // Check if we're dealing with a possibly incorrect server-sent position
        const specialCaseBoundary = 10; // Special handling for small coordinates that might be in tiles already
        if (x < specialCaseBoundary && y < specialCaseBoundary && this.tileSize > 1) {
            // Check if these might actually be tile coordinates sent mistakenly as world coordinates
            // Get the tile directly to check
            const tile = this.getTile(Math.floor(x), Math.floor(y));
            if (tile) {
                const isWall = tile.type === TILE_IDS.WALL || 
                      tile.type === TILE_IDS.OBSTACLE || 
                      tile.type === TILE_IDS.MOUNTAIN ||
                      tile.type === TILE_IDS.WATER;
                
                if (isProblematicCoord) {
                    console.warn(`COORDINATE FIX ATTEMPT: Interpreted small world coord (${x.toFixed(4)}, ${y.toFixed(4)}) ` +
                             `as tile coord (${Math.floor(x)}, ${Math.floor(y)}), isWall=${isWall}, tileType=${tile.type}`);
                }
                
                if (isWall) {
                    // Track wall collision in global stats
                    if (window.COLLISION_STATS) {
                        window.COLLISION_STATS.wallCollisions++;
                        window.COLLISION_STATS.lastWallCollision = Date.now();
                    }
                    return true;
                }
            }
        }
        
        // Convert from world coordinates to tile coordinates - regular handling
        const tileX = Math.floor(x / this.tileSize);
        const tileY = Math.floor(y / this.tileSize);
        
        // Enhanced debugging for coordinate conversion issues
        if (isProblematicCoord) {
            // Calculate tile boundaries
            const tileLeft = tileX * this.tileSize;
            const tileRight = (tileX + 1) * this.tileSize;
            const tileTop = tileY * this.tileSize;
            const tileBottom = (tileY + 1) * this.tileSize;
            
            // Calculate distance to each boundary
            const distToLeft = x - tileLeft;
            const distToRight = tileRight - x;
            const distToTop = y - tileTop;
            const distToBottom = tileBottom - y;
            
            // Find closest boundary
            const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
            let closestEdge = "unknown";
            if (minDist === distToLeft) closestEdge = "left";
            else if (minDist === distToRight) closestEdge = "right";
            else if (minDist === distToTop) closestEdge = "top";
            else if (minDist === distToBottom) closestEdge = "bottom";
            
            console.log(`DETAILED TILE INFO for world (${x.toFixed(4)}, ${y.toFixed(4)}) -> tile (${tileX}, ${tileY}):
- Tile boundaries: Left=${tileLeft}, Right=${tileRight}, Top=${tileTop}, Bottom=${tileBottom}
- Distance to edges: Left=${distToLeft.toFixed(4)}, Right=${distToRight.toFixed(4)}, Top=${distToTop.toFixed(4)}, Bottom=${distToBottom.toFixed(4)}
- Closest edge: ${closestEdge} (${minDist.toFixed(4)} units)
- Percentage within tile: x=${((x - tileLeft) / this.tileSize).toFixed(4)}, y=${((y - tileTop) / this.tileSize).toFixed(4)}
- Tile center: (${(tileLeft + this.tileSize/2).toFixed(4)}, ${(tileTop + this.tileSize/2).toFixed(4)})
- Distance from center: ${Math.sqrt(Math.pow(x - (tileLeft + this.tileSize/2), 2) + Math.pow(y - (tileTop + this.tileSize/2), 2)).toFixed(4)}`);
            
            // Check surrounding tiles
            const surroundingTiles = [];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const checkX = tileX + dx;
                    const checkY = tileY + dy;
                    if (checkX >= 0 && checkY >= 0 && checkX < this.width && checkY < this.height) {
                        const checkTile = this.getTile(checkX, checkY);
                        if (checkTile) {
                            const isBlocking = checkTile.type === TILE_IDS.WALL || 
                                               checkTile.type === TILE_IDS.OBSTACLE || 
                                               checkTile.type === TILE_IDS.MOUNTAIN ||
                                               checkTile.type === TILE_IDS.WATER;
                            surroundingTiles.push({
                                x: checkX, 
                                y: checkY, 
                                type: checkTile.type,
                                isWall: isBlocking
                            });
                        } else {
                            surroundingTiles.push({
                                x: checkX, 
                                y: checkY, 
                                type: "no-tile",
                                isWall: true
                            });
                        }
                    }
                }
            }
            console.log(`Surrounding tiles (3x3 grid):`);
            for (let y = -1; y <= 1; y++) {
                let row = '';
                for (let x = -1; x <= 1; x++) {
                    const tile = surroundingTiles.find(t => t.x === tileX + x && t.y === tileY + y);
                    if (tile) {
                        row += tile.isWall ? 'W' : '.';
                    } else {
                        row += 'X'; // Out of bounds
                    }
                }
                console.log(row);
            }
        }
        
        // Map boundary check
        if (tileX < 0 || tileY < 0 || (this.width > 0 && tileX >= this.width) || (this.height > 0 && tileY >= this.height)) {
            // Treat outside of map as wall
            if (isProblematicCoord) {
                console.log(`WALL CHECK RESULT: TRUE (out of map bounds) - tile (${tileX}, ${tileY}) is outside map bounds ${this.width}x${this.height}`);
            }
            
            // Track wall collision in global stats (map boundary)
            if (window.COLLISION_STATS) {
                window.COLLISION_STATS.wallCollisions++;
                window.COLLISION_STATS.lastWallCollision = Date.now();
            }
            
            return true;
        }
        
        // Get actual tile
        const tile = this.getTile(tileX, tileY);
        
        // If no tile found, treat as obstacle
        if (!tile) {
            if (isProblematicCoord) {
                console.log(`WALL CHECK RESULT: TRUE (no tile) - getTile(${tileX}, ${tileY}) returned null`);
            }
            
            // Track wall collision in global stats (no tile)
            if (window.COLLISION_STATS) {
                window.COLLISION_STATS.wallCollisions++;
                window.COLLISION_STATS.lastWallCollision = Date.now();
            }
            
            return true;
        }
        
        // IMPROVED: Use tile's isWalkable method if available
        if (typeof tile.isWalkable === 'function') {
            const result = !tile.isWalkable();
            if (isProblematicCoord) {
                console.log(`WALL CHECK RESULT: ${result} (using tile.isWalkable()) - tile (${tileX}, ${tileY}) type ${tile.type}`);
            }
            
            // Track wall collision in global stats if collision detected
            if (result && window.COLLISION_STATS) {
                window.COLLISION_STATS.wallCollisions++;
                window.COLLISION_STATS.lastWallCollision = Date.now();
            }
            
            return result;
        }
        
        // IMPROVED: Use isWalkable property if it exists
        if (tile.properties && tile.properties.isWalkable !== undefined) {
            const result = !tile.properties.isWalkable;
            if (isProblematicCoord) {
                console.log(`WALL CHECK RESULT: ${result} (using tile.properties.isWalkable) - tile (${tileX}, ${tileY}) type ${tile.type}`);
            }
            
            // Track wall collision in global stats if collision detected
            if (result && window.COLLISION_STATS) {
                window.COLLISION_STATS.wallCollisions++;
                window.COLLISION_STATS.lastWallCollision = Date.now();
            }
            
            return result;
        }
        
        // Fallback: Check tile type as before for backward compatibility
        const result = tile.type === TILE_IDS.WALL || 
               tile.type === TILE_IDS.OBSTACLE || 
               tile.type === TILE_IDS.MOUNTAIN ||
               tile.type === TILE_IDS.WATER || 
               (tile.type === TILE_IDS.LAVA && TILE_IDS.LAVA !== undefined);
               
        if (isProblematicCoord) {
            console.log(`WALL CHECK RESULT: ${result} (using tile type check) - tile (${tileX}, ${tileY}) type ${tile.type}`);
        }
        
        // Track wall collision in global stats if collision detected
        if (result && window.COLLISION_STATS) {
            window.COLLISION_STATS.wallCollisions++;
            window.COLLISION_STATS.lastWallCollision = Date.now();
            
            // Store information about the wall for the debug overlay
            const wallInfo = {
                tileX,
                tileY,
                worldX: (tileX + 0.5) * this.tileSize,
                worldY: (tileY + 0.5) * this.tileSize,
                type: tile.type,
                timestamp: Date.now()
            };
            
            // Add to last walls array, limited to 10 entries
            if (!window.COLLISION_STATS.lastWalls) {
                window.COLLISION_STATS.lastWalls = [];
            }
            window.COLLISION_STATS.lastWalls.unshift(wallInfo);
            if (window.COLLISION_STATS.lastWalls.length > 10) {
                window.COLLISION_STATS.lastWalls.pop();
            }
        }
               
        return result;
    }
    
    /**
     * Generate a fallback tile when chunk not loaded
     * THIS FUNCTION IS DISABLED - We want to strictly respect map boundaries
     * @param {number} x - Tile X coordinate
     * @param {number} y - Tile Y coordinate
     * @returns {Tile} Fallback tile
     */
    /* DISABLED FALLBACK TILE GENERATION
    generateFallbackTile(x, y) {
        // Use a simple pattern for fallback tiles
        // Make map edges walls, interior floor
        if (x < 0 || y < 0 || (this.width > 0 && x >= this.width) || (this.height > 0 && y >= this.height)) {
            return new Tile(TILE_IDS.WALL, 0);
        }
        
        // Checkerboard pattern
        const isEven = (x + y) % 2 === 0;
        const tileType = isEven ? TILE_IDS.FLOOR : TILE_IDS.FLOOR;
        
        return new Tile(tileType, 0);
    }
    */
    
    /**
     * Add event listener
     * @param {string} event - Event name
     * @param {Function} callback - Event callback
     */
    addEventListener(event, callback) {
        if (!this.eventListeners[event]) {
            this.eventListeners[event] = [];
        }
        this.eventListeners[event].push(callback);
    }
    
    /**
     * Remove event listener
     * @param {string} event - Event name
     * @param {Function} callback - Event callback
     */
    removeEventListener(event, callback) {
        if (!this.eventListeners[event]) return;
        const index = this.eventListeners[event].indexOf(callback);
        if (index !== -1) {
            this.eventListeners[event].splice(index, 1);
        }
    }
    
    /**
     * Dispatch an event
     * @param {string} event - Event name
     * @param {Object} data - Event data
     */
    dispatchEvent(event, data) {
        if (!this.eventListeners[event]) return;
        for (const callback of this.eventListeners[event]) {
            callback(data);
        }
    }
    
    /**
     * Print debug information about the current map state
     * @param {boolean} [showFullChunks=false] - Whether to print full chunk data
     */
    debugPrintMapInfo(showFullChunks = false) {
        console.log('=== MAP MANAGER DEBUG INFO ===');
        console.log(`Map ID: ${this.activeMapId || 'None'}`);
        console.log(`Map Size: ${this.width}x${this.height}`);
        console.log(`Tile Size: ${this.tileSize}, Chunk Size: ${this.chunkSize}`);
        console.log(`Procedural Generation: ${this.proceduralEnabled ? 'Enabled' : 'Disabled'}`);
        console.log(`Loaded Chunks: ${this.chunks.size}`);
        console.log(`Pending Chunks: ${this.pendingChunks.size}`);
        console.log(`Visible Chunks: ${this.visibleChunks.length}`);
        
        // Print chunk locations
        const chunkLocations = Array.from(this.chunks.keys()).map(key => {
            const [x, y] = key.split(',').map(Number);
            return `(${x},${y})`;
        });
        console.log(`Chunk Locations: ${chunkLocations.join(', ')}`);
        
        // Print chunk data if requested
        if (showFullChunks) {
            console.log('=== CHUNK DATA ===');
            this.chunks.forEach((chunk, key) => {
                console.log(`Chunk ${key}:`);
                this.printChunkVisually(key, chunk);
            });
        }
        
        console.log('=============================');
    }
    
    /**
     * Print a visual representation of a chunk to the console
     * @param {string} chunkKey - The chunk key (e.g. "0,0")
     * @param {Array} chunk - The chunk data
     */
    printChunkVisually(chunkKey, chunk) {
        if (!chunk || !Array.isArray(chunk)) {
            console.log(`Chunk ${chunkKey} has invalid data format`);
            return;
        }
        
        // Define tile type symbols for visual representation
        const symbols = {
            [TILE_IDS.FLOOR]: '.',
            [TILE_IDS.WALL]: '#',
            [TILE_IDS.OBSTACLE]: 'O',
            [TILE_IDS.WATER]: '~',
            [TILE_IDS.MOUNTAIN]: '^',
            'default': '?'
        };
        
        console.log(`Chunk ${chunkKey} - ${chunk.length}x${chunk[0]?.length || 0}:`);
        
        // Build visual representation
        const visual = [];
        for (let y = 0; y < chunk.length; y++) {
            let row = '';
            for (let x = 0; x < chunk[y].length; x++) {
                const tile = chunk[y][x];
                const tileType = tile?.type || 'default';
                row += symbols[tileType] || symbols['default'];
            }
            visual.push(row);
        }
        
        // Print the visual representation
        visual.forEach(row => console.log(row));
    }
    
    /**
     * Visualize the loaded map in the browser console with color
     * @param {number} centerX - Center tile X coordinate
     * @param {number} centerY - Center tile Y coordinate
     * @param {number} width - Width in tiles to visualize
     * @param {number} height - Height in tiles to visualize
     */
    visualizeMap(centerX = null, centerY = null, width = 40, height = 20) {
        console.log('=== MAP VISUALIZATION ===');
        
        // If no center specified, use player position
        if (centerX === null || centerY === null) {
            if (gameState && gameState.character) {
                centerX = Math.floor(gameState.character.x);
                centerY = Math.floor(gameState.character.y);
            } else {
                centerX = 0;
                centerY = 0;
            }
        }
        
        console.log(`Map centered at (${centerX}, ${centerY}), showing ${width}x${height} tiles`);
        
        // Calculate boundaries
        const startX = Math.floor(centerX - width / 2);
        const startY = Math.floor(centerY - height / 2);
        const endX = startX + width;
        const endY = startY + height;
        
        // Define colors for different tile types
        const colors = {
            [TILE_IDS.FLOOR]: 'color: #8a8a8a', // Gray
            [TILE_IDS.WALL]: 'color: #d43f3f', // Red
            [TILE_IDS.OBSTACLE]: 'color: #d49f3f', // Orange
            [TILE_IDS.WATER]: 'color: #3f8ad4', // Blue
            [TILE_IDS.MOUNTAIN]: 'color: #6f6f6f', // Dark gray
            'current': 'color: #ffffff; background-color: #ff0000', // White on red for player position
            'default': 'color: #ffffff' // White
        };
        
        // Define symbols for tile types
        const symbols = {
            [TILE_IDS.FLOOR]: '·',
            [TILE_IDS.WALL]: '█',
            [TILE_IDS.OBSTACLE]: '▒',
            [TILE_IDS.WATER]: '≈',
            [TILE_IDS.MOUNTAIN]: '▲',
            'current': '⊕',
            'default': '?'
        };
        
        // Track which chunks are loaded or missing
        const loadedChunks = new Set();
        const missingChunks = new Set();
        
        // Build the visualization row by row
        for (let y = startY; y < endY; y++) {
            let row = '%c';
            let formats = [];
            
            for (let x = startX; x < endX; x++) {
                // Check if this is the player position
                const isPlayerPos = (x === centerX && y === centerY);
                
                if (isPlayerPos) {
                    row += symbols['current'];
                    formats.push(colors['current']);
                    continue;
                }
                
                // Get tile type
                const tile = this.getTile(x, y);
                
                // Track chunk status
                const chunkX = Math.floor(x / this.chunkSize);
                const chunkY = Math.floor(y / this.chunkSize);
                const chunkKey = `${chunkX},${chunkY}`;
                
                if (this.chunks.has(chunkKey)) {
                    loadedChunks.add(chunkKey);
                } else {
                    missingChunks.add(chunkKey);
                }
                
                // Add appropriate symbol with color
                if (tile) {
                    const tileType = tile.type;
                    row += '%c' + (symbols[tileType] || symbols['default']);
                    formats.push(colors[tileType] || colors['default']);
                    } else {
                    row += '%c' + '.';
                    formats.push('color: #333333'); // Dark gray for unknown/missing
                }
            }
            
            // Print the row with formats
            console.log(row, ...formats);
        }
        
        // Print chunk information
        console.log('Loaded chunks: ' + Array.from(loadedChunks).join(', '));
        console.log('Missing chunks: ' + Array.from(missingChunks).join(', '));
        console.log('===========================');
        
        // Return summary
        return {
            center: { x: centerX, y: centerY },
            loadedChunks: loadedChunks.size,
            missingChunks: missingChunks.size,
            tilesShown: width * height
        };
    }
    
    /**
     * Save current map data to a file
     * @returns {Object} Map data object
     */
    saveMapData() {
        // Get map dimensions
        const width = this.width || 64;
        const height = this.height || 64;
        
        console.log(`Saving map with dimensions ${width}x${height}`);
        
        // Initialize with 0 (floor) as default
        const tileMap = Array(height).fill().map(() => Array(width).fill(0));
        
        // Keep track of chunks and tiles processed
        const loadedChunks = new Set();
        const tilesFound = 0;
        
        // Process all loaded chunks
        for (const [key, chunk] of this.chunks.entries()) {
            const [chunkX, chunkY] = key.split(',').map(Number);
            const startX = chunkX * this.chunkSize;
            const startY = chunkY * this.chunkSize;
            
            loadedChunks.add(key);
            
            // Process each tile in the chunk
            if (chunk && Array.isArray(chunk)) {
                for (let y = 0; y < chunk.length; y++) {
                    if (!chunk[y]) continue;
                    
                    for (let x = 0; x < chunk[y].length; x++) {
                        if (!chunk[y][x]) continue;
                        
                        const globalX = startX + x;
                        const globalY = startY + y;
                        
                        // Make sure we're within the map bounds
                        if (globalX >= 0 && globalX < width && globalY >= 0 && globalY < height) {
                            if (chunk[y][x].type !== undefined) {
                                tileMap[globalY][globalX] = chunk[y][x].type;
                            }
                        }
                    }
                }
            }
        }
        
        // Format JSON with one row per line for readability
        const formattedJson = "[\n" + 
            tileMap.map(row => "  " + JSON.stringify(row)).join(",\n") + 
            "\n]";
        
        // Save the map using the browser's download capability
        try {
            const blob = new Blob([formattedJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `client_map_direct_${this.activeMapId || 'unknown'}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log(`Map data saved to ${a.download} (${loadedChunks.size} chunks)`);
            
            // Make the save map function available globally for debugging
            window.clientMapData = tileMap;
            console.log("Map data also available at window.clientMapData");
            
            return { 
                tileMap, 
                loadedChunks: loadedChunks.size,
                width,
                height
            };
        } catch (error) {
            console.error("Error saving map data:", error);
            return null;
        }
    }
}
```

---


## FILE: /map_system/frontend/tile.js

```javascript
// src/map/tile.js

/**
 * Enhanced Tile class with more flexible properties for rendering and collision
 */
export class Tile {
    /**
     * Create a new tile
     * @param {number} type - The TILE_IDS value of this tile
     * @param {number} height - Height value for 3D rendering (0 = flat)
     * @param {Object} properties - Additional tile properties
     * @param {number} [properties.spriteIndex] - Override the default sprite index for this tile type
     * @param {boolean} [properties.isWalkable] - Override the walkability for this tile type
     * @param {boolean} [properties.isTransparent] - Whether light can pass through this tile
     * @param {Object} [properties.customData] - Any additional custom data for this tile
     * @param {number} [properties.variation] - Variation index for tiles with multiple appearances
     */
    constructor(type, height = 0, properties = {}) {
      this.type = type; // e.g., TILE_IDS.FLOOR, TILE_IDS.WALL, etc.
      this.height = height; // Height value for 3D rendering
      
      // Default properties based on type
      const defaultProps = {
        isWalkable: ![1, 2, 3, 4].includes(type), // All except WALL, OBSTACLE, WATER, MOUNTAIN are walkable
        isTransparent: type !== 1, // All except WALL are transparent
        variation: 0, // Default variation
      };
      
      // Merge default properties with provided properties
      this.properties = {...defaultProps, ...properties};
    }
    
    /**
     * Check if this tile allows walking
     * @returns {boolean} True if walkable
     */
    isWalkable() {
      return !!this.properties.isWalkable;
    }
    
    /**
     * Get the sprite index for rendering, which might be different from the tile type
     * @returns {number} Sprite index to use for rendering
     */
    getSpriteIndex() {
      // If a specific sprite is specified, use it
      if (this.properties.spriteIndex !== undefined) {
        return this.properties.spriteIndex;
      }
      
      // Calculate sprite based on type and variation
      const variation = this.properties.variation || 0;
      return this.type + (variation * 10); // Leaving room for variations
    }
    
    /**
     * Create a copy of this tile with modified properties
     * @param {Object} newProperties - Properties to update
     * @returns {Tile} New tile with updated properties
     */
    withProperties(newProperties) {
      return new Tile(
        this.type,
        this.height,
        {...this.properties, ...newProperties}
      );
    }
    
    /**
     * Check if this tile blocks movement (is wall or obstacle)
     * @returns {boolean} True if tile blocks movement
     */
    isBlockingMovement() {
      return !this.isWalkable();
    }
  }
  
```

---


## FILE: /map_system/frontend/camera.js

```javascript
// src/camera.js
import { createLogger } from './utils/logger.js';

// Create a logger for the camera module
const logger = createLogger('camera');

export class Camera {
  constructor(viewType, position = { x: 0, y: 0 }, zoom = 1) {
    this.viewType = viewType; // 'top-down', 'first-person', 'strategic'
    this.position = position; // { x, y }
    this.zoom = zoom; // For top-down and strategic views
    this.rotation = { pitch: 0, yaw: 0 }; // For first-person view
    
    // View scaling factors based on view type
    this.viewScaleFactors = {
      'top-down': 4.0,
      'first-person': 1.0,
      'strategic': 0.5 // Make strategic view show more of the map
    };
    
    // Debug mode - set to false by default
    this.debugMode = false;
  }

  move(dx, dy) {
    this.position.x += dx;
    this.position.y += dy;
  }

  setZoom(zoomLevel) {
    this.zoom = zoomLevel;
  }

  setRotation(pitch, yaw) {
    this.rotation.pitch = pitch;
    this.rotation.yaw = yaw;
  }

  /**
   * Updates the camera's position to the specified coordinates.
   * @param {Object} newPosition - { x, y } coordinates to set the camera position.
   */
  updatePosition(newPosition) {
    if (newPosition.x !== undefined) this.position.x = newPosition.x;
    if (newPosition.y !== undefined) this.position.y = newPosition.y;
    
    // Log camera position when in debug mode
    if (this.debugMode) {
      console.log(`Camera position updated to: (${this.position.x.toFixed(2)}, ${this.position.y.toFixed(2)})`);
    }
  }

  /**
   * Updates the camera's rotation to the specified values.
   * @param {Object} newRotation - { pitch, yaw } angles in radians.
   */
  updateRotation(newRotation) {
    if (newRotation.pitch !== undefined) this.rotation.pitch = newRotation.pitch;
    if (newRotation.yaw !== undefined) this.rotation.yaw = newRotation.yaw;
  }
  
  /**
   * Gets the current view scale factor based on view type
   * @returns {number} The scale factor for the current view
   */
  getViewScaleFactor() {
    return this.viewScaleFactors[this.viewType] || 1.0;
  }
  
  /**
   * Converts world coordinates to screen coordinates.
   * @param {number} worldX - X coordinate in world space
   * @param {number} worldY - Y coordinate in world space
   * @param {number} screenWidth - Width of the canvas
   * @param {number} screenHeight - Height of the canvas
   * @param {number} tileSize - Tile size in pixels
   * @returns {Object} Screen coordinates {x, y}
   */
  worldToScreen(worldX, worldY, screenWidth, screenHeight, tileSize) {
    const scaleFactor = this.getViewScaleFactor();
    // This formula transforms world coordinates to screen coordinates
    const screenX = (worldX - this.position.x) * tileSize * scaleFactor + screenWidth / 2;
    const screenY = (worldY - this.position.y) * tileSize * scaleFactor + screenHeight / 2;
    
    // Debug logging (only occasionally to avoid spamming console)
    if (this.debugMode && Math.random() < 0.01) {
      console.log(`worldToScreen: 
        World (${worldX}, ${worldY}) 
        Camera (${this.position.x}, ${this.position.y}) 
        Screen (${screenX}, ${screenY})
        TileSize: ${tileSize}, ScaleFactor: ${scaleFactor}
      `);
    }
    
    return { x: screenX, y: screenY };
  }
  
  /**
   * Toggle debug mode
   * @returns {boolean} The new debug mode state
   */
  toggleDebugMode() {
    this.debugMode = !this.debugMode;
    logger.info(`Camera debug mode ${this.debugMode ? 'enabled' : 'disabled'}`);
    return this.debugMode;
  }
  
  /**
   * Get the scaling factor to apply to entity sizes based on view type
   * @param {number} baseScale - Base scale factor (usually SCALE constant)
   * @returns {number} Effective scale to use for entity rendering
   */
  getEntityScaleFactor(baseScale = 1) {
    return baseScale * this.getViewScaleFactor();
  }
  
  /**
   * Determines if a world coordinate is visible on screen
   * @param {number} worldX - X coordinate in world space
   * @param {number} worldY - Y coordinate in world space
   * @param {number} width - Entity width in world units
   * @param {number} height - Entity height in world units
   * @param {number} screenWidth - Width of the canvas
   * @param {number} screenHeight - Height of the canvas
   * @param {number} tileSize - Tile size in pixels
   * @param {number} buffer - Extra buffer to add around screen (for culling)
   * @returns {boolean} Whether the entity is on screen
   */
  isOnScreen(worldX, worldY, width, height, screenWidth, screenHeight, tileSize, buffer = 0) {
    const screen = this.worldToScreen(worldX, worldY, screenWidth, screenHeight, tileSize);
    const scaleFactor = this.getViewScaleFactor();
    
    // Extend buffer in strategic view
    const viewBuffer = this.viewType === 'strategic' ? buffer * 2 : buffer;
    
    // Use the scaled entity dimensions
    const scaledWidth = width * tileSize * scaleFactor;
    const scaledHeight = height * tileSize * scaleFactor;
    
    return screen.x + scaledWidth/2 + viewBuffer >= 0 && 
           screen.x - scaledWidth/2 - viewBuffer <= screenWidth &&
           screen.y + scaledHeight/2 + viewBuffer >= 0 && 
           screen.y - scaledHeight/2 - viewBuffer <= screenHeight;
  }
}

```

---


## FILE: /map_system/frontend/coordinateUtils.js

```javascript
/**
 * coordinateUtils.js
 * Utility functions for handling world-to-screen coordinate transformations
 */

import { TILE_SIZE, SCALE } from '../constants/constants.js';

/**
 * CoordinateUtils - Helper for transforming between coordinate systems
 */
export class CoordinateUtils {
  constructor() {
    this.tileSize = TILE_SIZE;
    this.debugMode = false;
  }
  
  /**
   * Convert grid coordinates to world coordinates
   * In our game, grid and world coordinates are the same numerically,
   * but they have different semantic meanings
   */
  gridToWorld(gridX, gridY) {
    return {
      x: gridX,
      y: gridY
    };
  }
  
  /**
   * Convert world coordinates to grid coordinates
   * For fractional world coordinates, this returns the grid cell the coordinates are in
   */
  worldToGrid(worldX, worldY) {
    return {
      x: Math.floor(worldX),
      y: Math.floor(worldY)
    };
  }
  
  /**
   * Convert grid coordinates to screen coordinates
   * @param {number} gridX - X position in grid space
   * @param {number} gridY - Y position in grid space
   * @param {Object} camera - Camera with position and view type
   * @param {number} screenWidth - Screen width in pixels
   * @param {number} screenHeight - Screen height in pixels
   * @returns {Object} Screen coordinates {x, y}
   */
  gridToScreen(gridX, gridY, camera, screenWidth, screenHeight) {
    // First convert to world coordinates
    const worldPos = this.gridToWorld(gridX, gridY);
    
    // Then use world to screen
    return this.worldToScreen(worldPos.x, worldPos.y, camera, screenWidth, screenHeight);
  }
  
  /**
   * Convert world coordinates to screen coordinates
   * @param {number} worldX - X position in world space
   * @param {number} worldY - Y position in world space
   * @param {Object} camera - Camera with position and view type
   * @param {number} screenWidth - Screen width in pixels
   * @param {number} screenHeight - Screen height in pixels
   * @returns {Object} Screen coordinates {x, y}
   */
  worldToScreen(worldX, worldY, camera, screenWidth, screenHeight) {
    const viewType = camera.viewType || 'top-down';
    let scaleFactor = 1.0;
    
    // Get scale factor based on view type
    if (viewType === 'strategic') {
      scaleFactor = 0.5;
    } else if (viewType === 'top-down') {
      scaleFactor = 1.0;
    }
    
    // Calculate screen coordinates
    const screenX = (worldX - camera.position.x) * this.tileSize * scaleFactor + screenWidth / 2;
    const screenY = (worldY - camera.position.y) * this.tileSize * scaleFactor + screenHeight / 2;
    
    if (this.debugMode) {
      console.log(`World (${worldX}, ${worldY}) -> Screen (${screenX}, ${screenY})`);
    }
    
    return { x: screenX, y: screenY };
  }
  
  /**
   * Convert screen coordinates to world coordinates
   * @param {number} screenX - X position in screen space
   * @param {number} screenY - Y position in screen space
   * @param {Object} camera - Camera with position and view type
   * @param {number} screenWidth - Screen width in pixels
   * @param {number} screenHeight - Screen height in pixels
   * @returns {Object} World coordinates {x, y}
   */
  screenToWorld(screenX, screenY, camera, screenWidth, screenHeight) {
    const viewType = camera.viewType || 'top-down';
    let scaleFactor = 1.0;
    
    // Get scale factor based on view type
    if (viewType === 'strategic') {
      scaleFactor = 0.5;
    } else if (viewType === 'top-down') {
      scaleFactor = 1.0;
    }
    
    // Calculate world coordinates
    const worldX = ((screenX - screenWidth / 2) / (this.tileSize * scaleFactor)) + camera.position.x;
    const worldY = ((screenY - screenHeight / 2) / (this.tileSize * scaleFactor)) + camera.position.y;
    
    return { x: worldX, y: worldY };
  }
  
  /**
   * Convert screen coordinates to grid coordinates
   * @param {number} screenX - X position in screen space
   * @param {number} screenY - Y position in screen space
   * @param {Object} camera - Camera with position and view type
   * @param {number} screenWidth - Screen width in pixels
   * @param {number} screenHeight - Screen height in pixels
   * @returns {Object} Grid coordinates {x, y}
   */
  screenToGrid(screenX, screenY, camera, screenWidth, screenHeight) {
    // First convert to world coordinates
    const worldPos = this.screenToWorld(screenX, screenY, camera, screenWidth, screenHeight);
    
    // Then convert to grid
    return this.worldToGrid(worldPos.x, worldPos.y);
  }
  
  /**
   * Toggle debug mode
   * @returns {boolean} New debug mode state
   */
  toggleDebug() {
    this.debugMode = !this.debugMode;
    return this.debugMode;
  }
}

// Create and export singleton instance
export const coordinateUtils = new CoordinateUtils();

/**
 * Initialize coordinate utilities and make them available globally
 * This makes the utilities accessible to all parts of the codebase
 */
export function initCoordinateUtils() {
  console.log('Coordinate utilities initialized');
  
  // Add to window for debugging if needed
  window.coordinateUtils = coordinateUtils;
  
  return coordinateUtils;
}

// Auto-initialize when imported
initCoordinateUtils();

/**
 * Run a visual test of the coordinate system
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} camera - Camera object
 */
export function testCoordinateSystem(ctx, camera) {
  const screenWidth = ctx.canvas.width;
  const screenHeight = ctx.canvas.height;
  
  // Draw a grid of test points
  ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
  ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
  ctx.lineWidth = 1;
  ctx.font = '10px Arial';
  
  // Draw test points in a grid around the camera
  const gridSize = 5; // Draw a 5x5 grid
  for (let x = -gridSize; x <= gridSize; x++) {
    for (let y = -gridSize; y <= gridSize; y++) {
      // Get grid position relative to camera
      const gridX = Math.floor(camera.position.x) + x;
      const gridY = Math.floor(camera.position.y) + y;
      
      // Convert to screen coordinates
      const screenPos = coordinateUtils.gridToScreen(gridX, gridY, camera, screenWidth, screenHeight);
      
      // Draw point
      ctx.beginPath();
      ctx.arc(screenPos.x, screenPos.y, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw grid coordinates (only on some points to avoid clutter)
      if (x % 2 === 0 && y % 2 === 0) {
        ctx.fillText(`(${gridX},${gridY})`, screenPos.x + 5, screenPos.y - 5);
      }
      
      // Draw tile outline
      const tileSize = TILE_SIZE * (camera.viewType === 'strategic' ? 0.5 : 1.0);
      ctx.strokeRect(
        screenPos.x - tileSize / 2,
        screenPos.y - tileSize / 2,
        tileSize,
        tileSize
      );
    }
  }
  
  // Draw camera position
  const cameraPosScreen = {
    x: screenWidth / 2,
    y: screenHeight / 2
  };
  
  ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
  ctx.beginPath();
  ctx.arc(cameraPosScreen.x, cameraPosScreen.y, 5, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw text for camera position
  ctx.fillText(`Camera: (${camera.position.x.toFixed(1)},${camera.position.y.toFixed(1)})`, 
               cameraPosScreen.x + 10, cameraPosScreen.y);
} 
```

---

# BACKEND CODE



## FILE: /map_system/backend/MapManager.js

```javascript
// File: /src/managers/MapManager.js

import { TILE_IDS, CHUNK_SIZE, TILE_SIZE } from './world/constants.js';
import { PerlinNoise } from './world/PerlinNoise.js';
import { Tile } from './world/tile.js';
import { EnhancedPerlinNoise } from './world/AdvancedPerlinNoise.js';
/**
 * MapManager handles the game world, tiles, and chunks.
 * This is a unified implementation that consolidates functionality
 * from both the original MapManager and GameMap classes.
 */
export class MapManager {
  /**
   * Creates a map manager
   */
  constructor(options = {}) {
    this.chunks = new Map(); // Map of "x,y" -> chunk data
    this.width = 0;          // Width of the world in tiles
    this.height = 0;         // Height of the world in tiles
    this.tileSize = options.tileSize || TILE_SIZE;  // Size of each tile in pixels
    
    // For procedural generation
    this.perlin = new EnhancedPerlinNoise(options.seed || Math.random());
    this.proceduralEnabled = true;
    this.isFixedMap = false;
    
    // Map storage (for server)
    this.mapStoragePath = options.mapStoragePath || '';
    this.maps = new Map(); // For storing multiple maps (id -> mapData)
    this.nextMapId = 1;
  }
  
  /**
   * Generate or load a world
   * @param {number} width - Width of the world in tiles
   * @param {number} height - Height of the world in tiles
   * @param {Object} options - Additional options
   * @returns {string} Map ID
   */
  generateWorld(width, height, options = {}) {
    this.width = width;
    this.height = height;
    
    // Clear existing chunks
    this.chunks.clear();
    
    console.log(`World initialized with size ${width}x${height}`);
    
    // Create a map ID
    const mapId = `map_${this.nextMapId++}`;
    
    // Store map metadata
    this.maps.set(mapId, {
      id: mapId,
      width,
      height,
      tileSize: this.tileSize,
      chunkSize: CHUNK_SIZE,
      name: options.name || 'Untitled Map',
      procedural: this.proceduralEnabled,
      seed: this.perlin.seed
    });
    
    return mapId;
  }
  
  /**
   * Get world info for clients
   * @param {string} mapId - Map ID
   * @returns {Object} World metadata
   */
  getMapInfo(mapId) {
    if (mapId && this.maps.has(mapId)) {
      return this.maps.get(mapId);
    }
    
    return {
      width: this.width,
      height: this.height,
      tileSize: this.tileSize,
      chunkSize: CHUNK_SIZE
    };
  }
  
  /**
   * Get data for a specific chunk
   * @param {string} mapId - Map ID
   * @param {number} chunkX - Chunk X coordinate
   * @param {number} chunkY - Chunk Y coordinate
   * @returns {Object|null} Chunk data or null if not found
   */
  getChunkData(mapId, chunkX, chunkY) {
    const key = `${mapId || 'default'}_${chunkX},${chunkY}`;
    
    // If chunk exists in cache, return it
    if (this.chunks.has(key)) {
      return this.chunks.get(key);
    }
    
    // Otherwise generate it
    if (this.proceduralEnabled && !this.isFixedMap) {
      const chunkData = this.generateChunkData(chunkX, chunkY);
      this.chunks.set(key, chunkData);
      return chunkData;
    }
    
    return null;
  }
  
  /**
   * Generate data for a chunk procedurally using RotMG-style terrain generation
   * @param {number} chunkRow - Chunk row (Y coordinate)
   * @param {number} chunkCol - Chunk column (X coordinate)
   * @returns {Object} Generated chunk data
   */
  generateChunkData(chunkRow, chunkCol) {
    const tiles = [];
    
    // Parameters for multi-octave noise
    const OCTAVES = 4;        // Number of noise layers to blend
    const PERSISTENCE = 0.5;  // How much each octave contributes
    const BASE_SCALE = 50;    // Base scale/zoom of the noise (higher = more zoomed out)
    
    for (let y = 0; y < CHUNK_SIZE; y++) {
      const row = [];
      for (let x = 0; x < CHUNK_SIZE; x++) {
        const globalX = chunkCol * CHUNK_SIZE + x;
        const globalY = chunkRow * CHUNK_SIZE + y;
        
        // Skip if out of world bounds
        if (globalX >= this.width || globalY >= this.height) {
          row.push(new Tile(TILE_IDS.WALL)); // Use wall for out of bounds
          continue;
        }
        
        // Generate multiple octaves of noise for more natural terrain
        let height = 0;
        let amplitude = 1.0;
        let frequency = 1.0;
        let maxValue = 0;
        
        // Sum multiple noise octaves
        for (let o = 0; o < OCTAVES; o++) {
          // Scale coordinates based on frequency
          const sampleX = globalX / (BASE_SCALE / frequency);
          const sampleY = globalY / (BASE_SCALE / frequency);
          
          // Add scaled noise value
          height += this.perlin.get(sampleX, sampleY) * amplitude;
          
          // Keep track of max possible value for normalization
          maxValue += amplitude;
          
          // Increase frequency, decrease amplitude for next octave
          amplitude *= PERSISTENCE;
          frequency *= 2;
        }
        
        // Normalize to -1 to 1 range
        height /= maxValue;
        
        // Apply a curve to create more interesting terrain
        // Emphasize extremes (more mountains and water, less flat land)
        height = Math.pow(height, 3);
        
        // For coasts: add a high-frequency noise to create more jagged coastlines
        if (height > -0.4 && height < -0.2) {
          const coastDetail = this.perlin.get(globalX / 10, globalY / 10) * 0.1;
          height += coastDetail;
        }
        
        // Determine tile type based on height and position
        const tileType = this.determineTileType(height, globalX, globalY);
        
        row.push(new Tile(tileType, height));
      }
      tiles.push(row);
    }
    
    return {
      x: chunkCol,
      y: chunkRow,
      tiles: tiles
    };
  }
  
  /**
   * Determine tile type based on height value and create biomes like in RotMG
   * @param {number} heightValue - Perlin noise height value
   * @param {number} x - Global X coordinate
   * @param {number} y - Global Y coordinate
   * @returns {number} TILE_IDS value
   */
  determineTileType(heightValue, x, y) {
    // Absolute border walls
    if (x === 0 || y === 0 || x === this.width - 1 || y === this.height - 1) {
      return TILE_IDS.WALL;
    }
    
    // Generate additional noise values for biome variety
    // Use different frequency/scale for variety
    const temperatureNoise = this.perlin.get(x / 100, y / 100);  
    const moistureNoise = this.perlin.get(x / 80 + 500, y / 80 + 500);
    
    // Determine biome based on height, temperature and moisture
    // RotMG-style biome system
    
    // Deep water
    if (heightValue < -0.6) {
      return TILE_IDS.WATER;
    }
    
    // Shallow water/beaches
    if (heightValue < -0.3) {
      // Sometimes place obstacles in shallow water (like reeds or rocks)
      if (moistureNoise > 0.7 && Math.random() < 0.03) {
        return TILE_IDS.OBSTACLE;
      }
      return TILE_IDS.WATER;
    }
    
    // Lowlands (main gameplay areas)
    if (heightValue < 0.2) {
      // Cold biomes with temperature noise
      if (temperatureNoise < -0.5) {
        // Occasionally place obstacles (like ice formations)
        if (Math.random() < 0.02 && moistureNoise > 0.5) {
          return TILE_IDS.OBSTACLE;
        }
        return TILE_IDS.FLOOR; // Could be a special "snow" tile if we add more tile types
      }
      
      // Wet/swampy areas with high moisture
      if (moistureNoise > 0.6) {
        // More obstacles in swampy areas (like bogs)
        if (Math.random() < 0.05) {
          return TILE_IDS.OBSTACLE;
        }
        return TILE_IDS.FLOOR;
      }
      
      // Desert-like areas (low moisture, high temperature)
      if (moistureNoise < -0.3 && temperatureNoise > 0.4) {
        // Few obstacles in deserts
        if (Math.random() < 0.01) {
          return TILE_IDS.OBSTACLE;
        }
        return TILE_IDS.FLOOR;
      }
      
      // Default lowland (grassy fields)
      // Place natural obstacles occasionally
      if (Math.random() < 0.02) {
        return TILE_IDS.OBSTACLE;
      }
      return TILE_IDS.FLOOR;
    }
    
    // Hills and forests (medium elevation)
    if (heightValue < 0.5) {
      // Denser obstacles in hilly/forest areas
      if (Math.random() < 0.1 + (moistureNoise * 0.1)) {
        return TILE_IDS.OBSTACLE;
      }
      return TILE_IDS.FLOOR;
    }
    
    // Mountains (high elevation)
    if (heightValue < 0.7) {
      // Very dense obstacles in mountains
      if (Math.random() < 0.3) {
        return TILE_IDS.OBSTACLE;
      }
      // Some walls in mountains too
      if (Math.random() < 0.15) {
        return TILE_IDS.WALL;
      }
      return TILE_IDS.MOUNTAIN;
    }
    
    // Peaks (highest elevation)
    // Almost impassable
    if (Math.random() < 0.7) {
      return TILE_IDS.WALL;
    }
    return TILE_IDS.MOUNTAIN;
  }
  
  /**
   * Get a specific tile
   * @param {number} x - Tile X coordinate
   * @param {number} y - Tile Y coordinate
   * @returns {Tile|null} Tile object or null if not found
   */
  getTile(x, y) {
    // Convert to chunk coordinates
    const chunkX = Math.floor(x / CHUNK_SIZE);
    const chunkY = Math.floor(y / CHUNK_SIZE);
    const localX = x % CHUNK_SIZE;
    const localY = y % CHUNK_SIZE;
    
    // Get chunk
    const chunk = this.getChunkData(null, chunkX, chunkY);
    if (!chunk) return null;
    
    // Get tile from chunk
    return chunk.tiles[localY][localX];
  }
  
  /**
   * Get the tile type at a specific coordinate
   * @param {number} x - Tile X coordinate
   * @param {number} y - Tile Y coordinate
   * @returns {number|null} Tile type or null if not found
   */
  getTileType(x, y) {
    const tile = this.getTile(x, y);
    return tile ? tile.type : null;
  }
  
  /**
   * Check if a position is a wall or out of bounds
   * @param {number} x - World X coordinate
   * @param {number} y - World Y coordinate
   * @returns {boolean} True if wall or out of bounds
   */
  isWallOrOutOfBounds(x, y) {
    // Convert to tile coordinates
    const tileX = Math.floor(x / this.tileSize);
    const tileY = Math.floor(y / this.tileSize);
    
    // Debug coordinate conversion occasionally
    if (Math.random() < 0.0001) {
      console.log(`[SERVER] Wall check: World (${x.toFixed(2)}, ${y.toFixed(2)}) -> Tile (${tileX}, ${tileY})`);
    }
    
    // Check if out of bounds
    if (tileX < 0 || tileY < 0 || tileX >= this.width || tileY >= this.height) {
      return true;
    }
    
    // Get tile type
    const tileType = this.getTileType(tileX, tileY);
    
    // Check if wall or other solid obstacle
    const isBlocked = tileType === TILE_IDS.WALL || 
                     tileType === TILE_IDS.MOUNTAIN || 
                     tileType === TILE_IDS.WATER;
    
    // Debug collisions occasionally
    if (isBlocked && Math.random() < 0.0001) {
      console.log(`[SERVER] Collision at tile (${tileX}, ${tileY}), type: ${tileType}`);
    }
    
    return isBlocked;
  }
  
  /**
   * Load a fixed map from a JSON file
   * @param {string} url - URL or path to map JSON file
   * @returns {Promise<string>} - Promise resolving to map ID
   */
  async loadFixedMap(url) {
    try {
      let mapData;
      
      // Browser fetch
      if (typeof fetch === 'function') {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Failed to load map: ${response.statusText}`);
        }
        mapData = await response.json();
      } 
      // Node.js file read
      else if (typeof require === 'function') {
        const fs = require('fs');
        const path = require('path');
        const resolvedPath = path.isAbsolute(url) ? url : path.join(this.mapStoragePath, url);
        const data = fs.readFileSync(resolvedPath, 'utf8');
        mapData = JSON.parse(data);
      }
      else {
        throw new Error('No valid method to load map data');
      }
      
      // Set map data and get ID
      const mapId = this.setMapData(mapData);
      this.isFixedMap = true;
      this.proceduralEnabled = false;
      console.log('Fixed map loaded successfully:', mapId);
      return mapId;
    } catch (error) {
      console.error('Failed to load fixed map:', error);
      throw error;
    }
  }
  
  /**
   * Save map to a file
   * @param {string} mapId - Map ID to save
   * @param {string} filename - Filename to save as
   * @returns {Promise<boolean>} - Promise resolving to success status
   */
  async saveMap(mapId, filename) {
    if (!this.maps.has(mapId)) {
      console.error(`Map ${mapId} not found`);
      return false;
    }
    
    // Check if we're running in Node.js - use dynamic import for ES modules
    let fs, path;
    try {
      // Use dynamic import for ES modules
      const fsModule = await import('fs');
      const pathModule = await import('path');
      fs = fsModule.default || fsModule;
      path = pathModule.default || pathModule;
      console.log("Using ES dynamic import");
    } catch (e) {
      console.error("Cannot access the file system:", e.message);
      return false;
    }
    
    try {
      // Get map metadata
      const mapData = this.maps.get(mapId);
      console.log(`DEBUG: Preparing to save map ${mapId} with dimensions ${mapData.width}x${mapData.height}`);
      
      // Make sure directory exists
      if (!fs.existsSync(this.mapStoragePath)) {
        console.log(`DEBUG: Creating map storage directory: ${this.mapStoragePath}`);
        fs.mkdirSync(this.mapStoragePath, { recursive: true });
      }
      
      // Collect all chunks for this map
      const chunks = {};
      for (const [key, chunk] of this.chunks.entries()) {
        if (key.startsWith(`${mapId}_`)) {
          chunks[key.substring(mapId.length + 1)] = chunk;
        }
      }
      
      console.log(`DEBUG: Found ${Object.keys(chunks).length} chunks to save`);
      
      // Prepare the full map data
      const fullMapData = {
        ...mapData,
        chunks
      };
      
      // Save to file
      const filePath = path.join(this.mapStoragePath, filename);
      console.log(`DEBUG: Attempting to save map to path: ${filePath}`);
      
      // Create maps directory if it doesn't exist
      if (!fs.existsSync(path.dirname(filePath))) {
        fs.mkdirSync(path.dirname(filePath), { recursive: true });
        console.log(`DEBUG: Created directory: ${path.dirname(filePath)}`);
      }
      
      fs.writeFileSync(filePath, JSON.stringify(fullMapData, null, 2));
      
      console.log(`Map saved to ${filePath} successfully!`);
      return true;
    } catch (error) {
      console.error('Failed to save map:', error);
      console.error(`ERROR DETAILS: ${error.message}`);
      console.error(`Stack trace: ${error.stack}`);
      console.error(`Map storage path: ${this.mapStoragePath}`);
      return false;
    }
  }
  
  /**
   * Save map as a simple 2D array of tile types
   * @param {string} mapId - Map ID to save
   * @param {string} filename - Filename to save as
   * @returns {Promise<boolean>} - Promise resolving to success status
   */
  async saveSimpleMap(mapId, filename) {
    if (!this.maps.has(mapId)) {
      console.error(`Map ${mapId} not found`);
      return false;
    }
    
    // Check if we're running in Node.js - use dynamic import for ES modules
    let fs, path;
    try {
      // Use dynamic import for ES modules
      const fsModule = await import('fs');
      const pathModule = await import('path');
      fs = fsModule.default || fsModule;
      path = pathModule.default || pathModule;
      console.log("Using ES dynamic import");
    } catch (e) {
      console.error("Cannot access the file system:", e.message);
      return false;
    }
    
    try {
      // Get map metadata
      const mapData = this.maps.get(mapId);
      const width = mapData.width;
      const height = mapData.height;
      
      console.log(`DEBUG: Preparing to save simple map ${mapId} with dimensions ${width}x${height}`);
      
      // Make sure directory exists
      if (!fs.existsSync(this.mapStoragePath)) {
        console.log(`DEBUG: Creating map storage directory: ${this.mapStoragePath}`);
        fs.mkdirSync(this.mapStoragePath, { recursive: true });
      }
      
      // Create a 2D array initialized with -1 (unknown)
      const tileMap = Array(height).fill().map(() => Array(width).fill(-1));
      
      // FIXED: Use the direct approach to get tile types
      console.log(`Trying direct tile lookup for map ${mapId} - width=${width}, height=${height}`);
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          // Get tile directly using getTile method
          const tile = this.getTile(x, y);
          if (tile) {
            tileMap[y][x] = tile.type;
          }
        }
      }
      
      // Check if we still have all -1s, if so try the chunk approach as backup
      let allNegativeOne = true;
      for (let y = 0; y < height && allNegativeOne; y++) {
        for (let x = 0; x < width && allNegativeOne; x++) {
          if (tileMap[y][x] !== -1) {
            allNegativeOne = false;
            break;
          }
        }
      }
      
      // If all still -1, try the chunk approach
      if (allNegativeOne) {
        console.log(`WARNING: Direct tile lookup failed, trying chunk-based approach`);
        let processedChunks = 0;
        
        for (const [key, chunk] of this.chunks.entries()) {
          // Log all keys for debugging
          console.log(`DEBUG: Checking chunk key: ${key} for map prefix ${mapId}_`);
          
          if (!key.startsWith(`${mapId}_`)) continue;
          
          const chunkKey = key.substring(mapId.length + 1);
          const [chunkX, chunkY] = chunkKey.split(',').map(Number);
          const startX = chunkX * this.maps.get(mapId).chunkSize;
          const startY = chunkY * this.maps.get(mapId).chunkSize;
          
          console.log(`DEBUG: Processing chunk ${chunkKey} at position (${startX}, ${startY})`);
          
          // Debug chunk data structure
          console.log(`DEBUG: Chunk structure: ${JSON.stringify(Object.keys(chunk))}`);
          console.log(`DEBUG: Chunk tiles length: ${chunk.tiles ? chunk.tiles.length : 'undefined'}`);
          
          // Fill in the tile types from this chunk
          if (chunk.tiles) {
            for (let y = 0; y < chunk.tiles.length; y++) {
              if (!chunk.tiles[y]) continue;
              
              for (let x = 0; x < chunk.tiles[y].length; x++) {
                const globalX = startX + x;
                const globalY = startY + y;
                
                // Skip if outside map bounds
                if (globalX >= width || globalY >= height) continue;
                
                const tile = chunk.tiles[y][x];
                if (tile) {
                  tileMap[globalY][globalX] = tile.type;
                }
              }
            }
          }
          
          processedChunks++;
        }
        
        console.log(`DEBUG: Processed ${processedChunks} chunks for the simple map`);
      }
      
      // Save to file
      const filePath = path.join(this.mapStoragePath, filename);
      console.log(`DEBUG: Attempting to save simple map to path: ${filePath}`);
      
      // Create maps directory if it doesn't exist
      if (!fs.existsSync(path.dirname(filePath))) {
        fs.mkdirSync(path.dirname(filePath), { recursive: true });
        console.log(`DEBUG: Created directory: ${path.dirname(filePath)}`);
      }
      
      // Format the map with one row per line for readability
      const formattedJson = "[\n" + 
        tileMap.map(row => "  " + JSON.stringify(row)).join(",\n") + 
        "\n]";
      
      fs.writeFileSync(filePath, formattedJson);
      
      console.log(`Simple map saved to ${filePath} successfully!`);
      return true;
    } catch (error) {
      console.error('Failed to save simple map:', error);
      console.error(`ERROR DETAILS: ${error.message}`);
      console.error(`Stack trace: ${error.stack}`);
      console.error(`Map storage path: ${this.mapStoragePath}`);
      return false;
    }
  }
  
  /**
   * Sets the map data from a loaded map
   * @param {Object} mapData - The map data object
   * @returns {string} Map ID
   */
  setMapData(mapData) {
    const mapId = mapData.id || `map_${this.nextMapId++}`;
    
    // Clear existing chunks for this map
    for (const [key] of this.chunks.entries()) {
      if (key.startsWith(`${mapId}_`)) {
        this.chunks.delete(key);
      }
    }
    
    // Store metadata
    this.maps.set(mapId, {
      id: mapId,
      width: mapData.width,
      height: mapData.height,
      tileSize: mapData.tileSize || this.tileSize,
      chunkSize: mapData.chunkSize || CHUNK_SIZE,
      name: mapData.name || 'Loaded Map',
      procedural: false
    });
    
    // Update current dimensions
    this.width = mapData.width;
    this.height = mapData.height;
    
    // Load chunks if provided
    if (mapData.chunks) {
      for (const [chunkKey, chunkData] of Object.entries(mapData.chunks)) {
        this.chunks.set(`${mapId}_${chunkKey}`, chunkData);
      }
    }
    
    return mapId;
  }
  
  /**
   * Function to get tiles in a range
   * @param {number} xStart - Start X coordinate
   * @param {number} yStart - Start Y coordinate 
   * @param {number} xEnd - End X coordinate
   * @param {number} yEnd - End Y coordinate
   * @returns {Array} Array of tile objects with coordinates
   */
  getTilesInRange(xStart, yStart, xEnd, yEnd) {
    const tiles = [];
    for (let y = yStart; y <= yEnd; y++) {
      for (let x = xStart; x <= xEnd; x++) {
        const tile = this.getTile(x, y);
        if (tile) {
          tiles.push({ x, y, tile });
        }
      }
    }
    return tiles;
  }
  
  /**
   * Enable procedural generation
   */
  enableProceduralGeneration() {
    this.proceduralEnabled = true;
    this.isFixedMap = false;
  }
  
  /**
   * Disable procedural generation
   */
  disableProceduralGeneration() {
    this.proceduralEnabled = false;
  }
  
  /**
   * Create a procedural map (server-side helper)
   * @param {Object} options - Map options
   * @returns {string} Map ID
   */
  createProceduralMap(options = {}) {
    const width = options.width || 256;
    const height = options.height || 256;
    this.enableProceduralGeneration();
    return this.generateWorld(width, height, options);
  }
  
  /**
   * Get map metadata (server-side helper)
   * @param {string} mapId - Map ID
   * @returns {Object} Map metadata
   */
  getMapMetadata(mapId) {
    return this.maps.has(mapId) ? this.maps.get(mapId) : null;
  }
}

// Export a singleton instance for client use
export const mapManager = new MapManager();

// For CommonJS compatibility
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    MapManager,
    mapManager
  };
}
```

---


## FILE: /map_system/backend/AdvancedPerlinNoise.js

```javascript
// Enhanced PerlinNoise class with additional features
export class EnhancedPerlinNoise {
    constructor(seed = Math.random()) {
      this.seed = seed;
      this.gradients = {};
      this.memory = {};
    }
  
    // Generate a random gradient vector
    randomGradient(ix, iy) {
      const random = 2920 * Math.sin(ix * 21942 + iy * 171324 + this.seed * 8912) *
                    Math.cos(ix * 23157 * iy * 217832 + this.seed * 9758);
      return { x: Math.cos(random), y: Math.sin(random) };
    }
  
    // Dot product of the distance and gradient vectors
    dotGridGradient(ix, iy, x, y) {
      const key = `${ix},${iy}`;
      const gradient = this.gradients[key] || (this.gradients[key] = this.randomGradient(ix, iy));
  
      const dx = x - ix;
      const dy = y - iy;
  
      return dx * gradient.x + dy * gradient.y;
    }
  
    // Improved smoothing function (smoother than linear interpolation)
    fade(t) {
      return t * t * t * (t * (t * 6 - 15) + 10);
    }
  
    // Interpolation function
    lerp(a0, a1, w) {
      return (1 - w) * a0 + w * a1;
    }
  
    // Compute Perlin noise at coordinates x, y
    get(x, y) {
      const memKey = `${x.toFixed(3)},${y.toFixed(3)}`;
      if (this.memory[memKey] !== undefined) {
        return this.memory[memKey];
      }
      
      const x0 = Math.floor(x);
      const x1 = x0 + 1;
      const y0 = Math.floor(y);
      const y1 = y0 + 1;
  
      // Interpolation weights with improved smoothing
      const sx = this.fade(x - x0);
      const sy = this.fade(y - y0);
  
      // Interpolate between grid point gradients
      const n0 = this.dotGridGradient(x0, y0, x, y);
      const n1 = this.dotGridGradient(x1, y0, x, y);
      const ix0 = this.lerp(n0, n1, sx);
  
      const n2 = this.dotGridGradient(x0, y1, x, y);
      const n3 = this.dotGridGradient(x1, y1, x, y);
      const ix1 = this.lerp(n2, n3, sx);
  
      const value = this.lerp(ix0, ix1, sy);
      
      // Cache result for repeated lookups
      this.memory[memKey] = value;
      
      return value;
    }
    
    // Fractal Brownian Motion (fBm) - multiple octaves of noise
    fbm(x, y, octaves = 6, lacunarity = 2.0, persistence = 0.5) {
      let total = 0;
      let frequency = 1;
      let amplitude = 1;
      let maxValue = 0;
      
      for (let i = 0; i < octaves; i++) {
        total += this.get(x * frequency, y * frequency) * amplitude;
        maxValue += amplitude;
        
        // Increase frequency, decrease amplitude for each octave
        amplitude *= persistence;
        frequency *= lacunarity;
      }
      
      return total / maxValue;
    }
    
    // Ridged multifractal noise - creates ridges and valleys
    ridged(x, y, octaves = 6, lacunarity = 2.0, persistence = 0.5) {
      let total = 0;
      let frequency = 1;
      let amplitude = 1;
      let maxValue = 0;
      
      for (let i = 0; i < octaves; i++) {
        // Get noise value
        let noise = this.get(x * frequency, y * frequency);
        
        // Transform to create ridges
        noise = 1 - Math.abs(noise);
        noise = noise * noise; // Square for sharper ridges
        
        total += noise * amplitude;
        maxValue += amplitude;
        
        amplitude *= persistence;
        frequency *= lacunarity;
      }
      
      return total / maxValue;
    }
    
    // Domain warping - distorts the input space for more organic patterns
    warp(x, y, strength = 10.0) {
      // Warp the input coordinates
      const warpX = x + this.get(x * 0.05, y * 0.05) * strength;
      const warpY = y + this.get(x * 0.05 + 100, y * 0.05 + 100) * strength;
      
      // Get noise at warped coordinates
      return this.get(warpX, warpY);
    }
    
    // Clear cache to save memory
    clearCache() {
      this.memory = {};
    }
  }
  
  // Enhanced MapGenerator class using the improved noise generation
  export class EnhancedMapGenerator {
    constructor(options = {}) {
      this.seed = options.seed || Math.random();
      this.perlin = new EnhancedPerlinNoise(this.seed);
      
      // Map dimensions
      this.width = options.width || 256;
      this.height = options.height || 256;
      
      // Optional parameters
      this.waterLevel = options.waterLevel || 0.3;
      this.mountainLevel = options.mountainLevel || 0.7;
      this.forestLevel = options.forestLevel || 0.5;
      
      // Configure tile IDs
      this.TILE_IDS = options.TILE_IDS || {
        FLOOR: 0,
        WALL: 1,
        OBSTACLE: 2,
        WATER: 3,
        MOUNTAIN: 4
      };
    }
    
    // Generate a complete world map
    generateWorld() {
      // Create temperature and moisture maps
      const temperatureMap = this.generateTemperatureMap();
      const moistureMap = this.generateMoistureMap();
      
      // Generate base terrain using multiple noise techniques
      const heightMap = this.generateHeightMap();
      
      // Convert height map to tile types
      const tiles = this.convertToTiles(heightMap, temperatureMap, moistureMap);
      
      // Ensure map edges have walls
      this.addMapBorders(tiles);
      
      // Generate rivers if desired
      // this.generateRivers(tiles, heightMap);
      
      return {
        width: this.width,
        height: this.height,
        tiles: tiles,
        seed: this.seed
      };
    }
    
    // Generate temperature variation across the map (equator to poles)
    generateTemperatureMap() {
      const map = Array(this.height).fill().map(() => Array(this.width).fill(0));
      
      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          // Base temperature gradient from south to north (equator in middle)
          const latitudeFactor = 1.0 - Math.abs((y / this.height) - 0.5) * 2;
          
          // Add some noise for local variations
          const noise = this.perlin.get(x * 0.01, y * 0.01) * 0.2;
          
          map[y][x] = latitudeFactor * 0.8 + noise;
        }
      }
      
      return map;
    }
    
    // Generate moisture map (used for biome determination)
    generateMoistureMap() {
      const map = Array(this.height).fill().map(() => Array(this.width).fill(0));
      
      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          // Use domain warping for more interesting moisture patterns
          const warpX = x + this.perlin.get(x * 0.02, y * 0.02) * 20;
          const warpY = y + this.perlin.get(x * 0.02 + 40, y * 0.02 + 30) * 20;
          
          map[y][x] = this.perlin.fbm(warpX * 0.01, warpY * 0.01, 4, 2.0, 0.5);
        }
      }
      
      return map;
    }
    
    // Generate base height map using multiple noise techniques
    generateHeightMap() {
      const map = Array(this.height).fill().map(() => Array(this.width).fill(0));
      
      // Parameter for continent vs detailed noise
      const continentScale = 0.002; // Large scale continent shapes
      const detailScale = 0.01;     // Medium scale terrain features
      const microScale = 0.05;      // Small scale details
      
      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          // Continent shapes (large scale)
          const continentNoise = this.perlin.fbm(x * continentScale, y * continentScale, 3, 2.0, 0.5);
          
          // Apply some ridged noise for mountain ranges
          const ridgeNoise = this.perlin.ridged(x * detailScale, y * detailScale, 4, 2.0, 0.5);
          
          // Detailed noise
          const detailNoise = this.perlin.fbm(x * microScale, y * microScale, 3, 2.0, 0.5);
          
          // Combine the different scales
          const combinedNoise = continentNoise * 0.6 + ridgeNoise * 0.3 + detailNoise * 0.1;
          
          // Apply curve to emphasize landmasses and oceans
          map[y][x] = this.applyHeightCurve(combinedNoise);
        }
      }
      
      return map;
    }
    
    // Apply non-linear curve to height values to create clearer distinctions
    applyHeightCurve(height) {
      // This makes flatter areas for oceans and land, with steeper transitions
      if (height < this.waterLevel - 0.1) {
        // Deep ocean
        return height * 0.5;
      } else if (height < this.waterLevel + 0.1) {
        // Coastline transition
        return this.waterLevel + (height - this.waterLevel) * 0.8;
      } else if (height > this.mountainLevel) {
        // Mountains get exaggerated
        return this.mountainLevel + (height - this.mountainLevel) * 1.5;
      }
      
      // Normal lands
      return height;
    }
    
    // Convert height map to actual tile types
    convertToTiles(heightMap, temperatureMap, moistureMap) {
      const tiles = Array(this.height).fill().map(() => Array(this.width).fill(0));
      
      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          const height = heightMap[y][x];
          const temperature = temperatureMap[y][x];
          const moisture = moistureMap[y][x];
          
          // Use determineTileType to set the tile type
          tiles[y][x] = this.determineTileType(height, temperature, moisture, x, y);
        }
      }
      
      return tiles;
    }
    
    // Determine tile type based on height, temperature, and moisture
    determineTileType(height, temperature, moisture, x, y) {
      // We're explicitly NOT checking for map borders here!
      // That will be handled separately to ensure only the edges get walls
      
      // Determine base tile type from height
      if (height < this.waterLevel) {
        return this.TILE_IDS.WATER;
      } else if (height > this.mountainLevel) {
        return this.TILE_IDS.MOUNTAIN;
      } else {
        // Land tiles - could be floor or obstacle based on biome
        if (moisture > this.forestLevel && temperature > 0.3) {
          // Forest/obstacle in moderate to wet areas
          return this.TILE_IDS.OBSTACLE;
        } else {
          // Basic floor for most land
          return this.TILE_IDS.FLOOR;
        }
      }
    }
    
    // Add walls only at map borders
    addMapBorders(tiles) {
      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          // Only put walls at the absolute edges of the map
          if (x === 0 || y === 0 || x === this.width - 1 || y === this.height - 1) {
            tiles[y][x] = this.TILE_IDS.WALL;
          }
        }
      }
    }
    
    // Generate a chunk for the given coordinates
    generateChunkData(chunkRow, chunkCol, chunkSize) {
      const tiles = [];
      
      for (let y = 0; y < chunkSize; y++) {
        const row = [];
        for (let x = 0; x < chunkSize; x++) {
          const globalX = chunkCol * chunkSize + x;
          const globalY = chunkRow * chunkSize + y;
          
          // Check if this position is within the world bounds
          if (globalX >= this.width || globalY >= this.height || globalX < 0 || globalY < 0) {
            // Out of bounds - use floor instead of wall
            row.push({ type: this.TILE_IDS.FLOOR, height: 0 });
            continue;
          }
          
          // Generate the necessary data for this tile
          const heightValue = this.getHeightAt(globalX, globalY);
          const temperature = this.getTemperatureAt(globalX, globalY);
          const moisture = this.getMoistureAt(globalX, globalY);
          
          // Determine tile type (excluding border walls, those are added separately)
          const tileType = this.determineTileType(heightValue, temperature, moisture, globalX, globalY);
          
          // Create a tile object with the type and height value
          row.push({ type: tileType, height: heightValue });
        }
        tiles.push(row);
      }
      
      // Now check and apply border walls ONLY at the edges of the world
      for (let y = 0; y < chunkSize; y++) {
        for (let x = 0; x < chunkSize; x++) {
          const globalX = chunkCol * chunkSize + x;
          const globalY = chunkRow * chunkSize + y;
          
          // Only put walls at the absolute edges of the map
          if (globalX === 0 || globalY === 0 || 
              globalX === this.width - 1 || globalY === this.height - 1) {
            tiles[y][x] = { type: this.TILE_IDS.WALL, height: 0 };
          }
        }
      }
      
      return {
        x: chunkCol,
        y: chunkRow,
        tiles: tiles
      };
    }
    
    // Helper methods to get values at specific coordinates
    getHeightAt(x, y) {
      const continentNoise = this.perlin.fbm(x * 0.002, y * 0.002, 3, 2.0, 0.5);
      const ridgeNoise = this.perlin.ridged(x * 0.01, y * 0.01, 4, 2.0, 0.5);
      const detailNoise = this.perlin.fbm(x * 0.05, y * 0.05, 3, 2.0, 0.5);
      
      const combinedNoise = continentNoise * 0.6 + ridgeNoise * 0.3 + detailNoise * 0.1;
      return this.applyHeightCurve(combinedNoise);
    }
    
    getTemperatureAt(x, y) {
      const latitudeFactor = 1.0 - Math.abs((y / this.height) - 0.5) * 2;
      const noise = this.perlin.get(x * 0.01, y * 0.01) * 0.2;
      return latitudeFactor * 0.8 + noise;
    }
    
    getMoistureAt(x, y) {
      const warpX = x + this.perlin.get(x * 0.02, y * 0.02) * 20;
      const warpY = y + this.perlin.get(x * 0.02 + 40, y * 0.02 + 30) * 20;
      return this.perlin.fbm(warpX * 0.01, warpY * 0.01, 4, 2.0, 0.5);
    }
  }
  
  // Example usage to replace your current MapManager implementation
  
  /**
   * Implementation to integrate with your existing code
   * This shows how to replace the procedural generation parts while
   * keeping your existing MapManager interface
   */
  export function enhanceMapManager(MapManager) {
    // Store the original methods we're going to override
    const originalGenerateChunkData = MapManager.prototype.generateChunkData;
    const originalDetermineTileType = MapManager.prototype.determineTileType;
    
    // Enhanced tile type determination
    MapManager.prototype.determineTileType = function(heightValue, x, y) {
      // ONLY put walls at the absolute edges of the map
      // This is the key fix for your wall problem
      if (x === 0 || y === 0 || x === this.width - 1 || y === this.height - 1) {
        return TILE_IDS.WALL;
      }
      
      // Use enhanced algorithm for everything else
      if (heightValue < -0.4) return TILE_IDS.WATER;
      if (heightValue < 0.3) return TILE_IDS.FLOOR; // Increased this threshold for more floor tiles
      if (heightValue < 0.6) return TILE_IDS.OBSTACLE; // Moved obstacle threshold up
      return TILE_IDS.MOUNTAIN;
    };
    
    // Enhanced chunk generation with better noise
    MapManager.prototype.generateChunkData = function(chunkRow, chunkCol) {
      // Check if we've already created an enhanced perlin instance
      if (!this.enhancedPerlin) {
        this.enhancedPerlin = new EnhancedPerlinNoise(this.perlin.seed);
      }
      
      const tiles = [];
      
      for (let y = 0; y < CHUNK_SIZE; y++) {
        const row = [];
        for (let x = 0; x < CHUNK_SIZE; x++) {
          const globalX = chunkCol * CHUNK_SIZE + x;
          const globalY = chunkRow * CHUNK_SIZE + y;
          
          // Skip if out of world bounds
          if (globalX >= this.width || globalY >= this.height) {
            row.push(new Tile(TILE_IDS.FLOOR)); // Use FLOOR instead of WALL for out of bounds
            continue;
          }
          
          // Use enhanced noise functions for better terrain
          // Combined noise at different scales
          const continentNoise = this.enhancedPerlin.fbm(globalX * 0.002, globalY * 0.002, 3, 2.0, 0.5);
          const ridgeNoise = this.enhancedPerlin.ridged(globalX * 0.01, globalY * 0.01, 4, 2.0, 0.5);
          const detailNoise = this.enhancedPerlin.fbm(globalX * 0.05, globalY * 0.05, 3, 2.0, 0.5);
          
          // Combine noise layers
          const heightValue = continentNoise * 0.6 + ridgeNoise * 0.3 + detailNoise * 0.1;
          
          // Determine tile type with our improved function
          const tileType = this.determineTileType(heightValue, globalX, globalY);
          
          row.push(new Tile(tileType, heightValue));
        }
        tiles.push(row);
      }
      
      return {
        x: chunkCol,
        y: chunkRow,
        tiles: tiles
      };
    };
    
    return MapManager;
  }
  
  // Standalone map generator that you can use if you prefer
  export class ImprovedMapManager {
    constructor(options = {}) {
      this.chunks = new Map(); // Map of "x,y" -> chunk data
      this.width = options.width || 256;
      this.height = options.height || 256;
      this.tileSize = options.tileSize || 12;
      
      // Create enhanced noise generator
      this.seed = options.seed || Math.random();
      this.perlin = new EnhancedPerlinNoise(this.seed);
      
      // Map settings
      this.proceduralEnabled = true;
      this.isFixedMap = false;
      
      console.log(`Improved MapManager initialized with seed: ${this.seed}`);
    }
    
    // Generate a new world
    generateWorld(width, height, options = {}) {
      this.width = width;
      this.height = height;
      
      // Clear existing chunks
      this.chunks.clear();
      
      console.log(`World initialized with size ${width}x${height}`);
      
      // Create a map ID
      const mapId = options.id || `map_${Date.now()}`;
      
      return mapId;
    }
    
    // Get a chunk (generate if needed)
    getChunkData(mapId, chunkX, chunkY) {
      const key = `${mapId || 'default'}_${chunkX},${chunkY}`;
      
      // If chunk exists in cache, return it
      if (this.chunks.has(key)) {
        return this.chunks.get(key);
      }
      
      // Otherwise generate it
      if (this.proceduralEnabled && !this.isFixedMap) {
        const chunkData = this.generateChunkData(chunkX, chunkY);
        this.chunks.set(key, chunkData);
        return chunkData;
      }
      
      return null;
    }
    
    // Generate chunk data with enhanced algorithm
    generateChunkData(chunkRow, chunkCol) {
      const tiles = [];
      
      for (let y = 0; y < CHUNK_SIZE; y++) {
        const row = [];
        for (let x = 0; x < CHUNK_SIZE; x++) {
          const globalX = chunkCol * CHUNK_SIZE + x;
          const globalY = chunkRow * CHUNK_SIZE + y;
          
          // Skip if out of world bounds
          if (globalX >= this.width || globalY >= this.height) {
            row.push(new Tile(TILE_IDS.FLOOR)); // Use FLOOR instead of WALL for out of bounds
            continue;
          }
          
          // Multi-scale noise for better terrain
          const continentNoise = this.perlin.fbm(globalX * 0.002, globalY * 0.002, 3, 2.0, 0.5);
          const ridgeNoise = this.perlin.ridged(globalX * 0.01, globalY * 0.01, 4, 2.0, 0.5);
          const detailNoise = this.perlin.fbm(globalX * 0.05, globalY * 0.05, 3, 2.0, 0.5);
          
          // Combined noise
          const heightValue = continentNoise * 0.6 + ridgeNoise * 0.3 + detailNoise * 0.1;
          
          // Determine tile type
          const tileType = this.determineTileType(heightValue, globalX, globalY);
          
          row.push(new Tile(tileType, heightValue));
        }
        tiles.push(row);
      }
      
      return {
        x: chunkCol,
        y: chunkRow,
        tiles: tiles
      };
    }
    
    // Enhanced tile type determination
    determineTileType(heightValue, x, y) {
      // ONLY put walls at the absolute edges of the map
      if (x === 0 || y === 0 || x === this.width - 1 || y === this.height - 1) {
        return TILE_IDS.WALL;
      }
      
      // Determine tile type based on height - adjusted thresholds
      if (heightValue < -0.4) return TILE_IDS.WATER;
      if (heightValue < 0.3) return TILE_IDS.FLOOR; // More walkable space
      if (heightValue < 0.6) return TILE_IDS.OBSTACLE;
      return TILE_IDS.MOUNTAIN;
    }
    
    // Get a specific tile
    getTile(x, y) {
      // Convert to chunk coordinates
      const chunkX = Math.floor(x / CHUNK_SIZE);
      const chunkY = Math.floor(y / CHUNK_SIZE);
      const localX = x % CHUNK_SIZE;
      const localY = y % CHUNK_SIZE;
      
      // Get chunk
      const chunk = this.getChunkData(null, chunkX, chunkY);
      if (!chunk) return null;
      
      // Get tile from chunk
      return chunk.tiles[localY][localX];
    }
    
    // Check if a position is a wall or obstacle
    isWallOrOutOfBounds(x, y) {
      // Convert to tile coordinates
      const tileX = Math.floor(x / this.tileSize);
      const tileY = Math.floor(y / this.tileSize);
      
      // Check if out of bounds
      if (tileX < 0 || tileY < 0 || tileX >= this.width || tileY >= this.height) {
        return true;
      }
      
      // Get tile type
      const tileType = this.getTileType(tileX, tileY);
      
      // Check if wall or other solid obstacle
      return tileType === TILE_IDS.WALL || 
             tileType === TILE_IDS.MOUNTAIN || 
             tileType === TILE_IDS.WATER;
    }
    
    // Get the tile type at a specific coordinate
    getTileType(x, y) {
      const tile = this.getTile(x, y);
      return tile ? tile.type : null;
    }
  }
```

---

# ANALYSIS SUGGESTIONS

When analyzing this code, focus on:

1. Coordinate system conversions between world and tile space
2. How collision detection is implemented
3. Communication between client and server
4. Potential areas for bugs or inconsistencies
